From bf0a5d4b223dfe523eb5191d0cb428f63cf04e2e Mon Sep 17 00:00:00 2001
From: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>
Date: Tue, 17 Oct 2017 23:08:07 +0300
Subject: [PATCH] drm/i915: move adjusted_x/y from crtc to cache.
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: bf0a5d4b223dfe523eb5191d0cb428f63cf04e2e
Patch-mainline: v4.15-rc1
References: FATE#322643 bsc#1055900

Move adjusted_x/y from crtc to fbc cache.

Signed-off-by: Juha-Pekka Heikkila <juhapekka.heikkila@gmail.com>
Link: https://patchwork.freedesktop.org/patch/msgid/1508270891-22186-2-git-send-email-juhapekka.heikkila@gmail.com
[vsyrjala: Add rudimentary commit message]
Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/i915_drv.h      |    8 ++++++++
 drivers/gpu/drm/i915/intel_display.c |    6 ------
 drivers/gpu/drm/i915/intel_drv.h     |    2 --
 drivers/gpu/drm/i915/intel_fbc.c     |   11 ++++++++---
 4 files changed, 16 insertions(+), 11 deletions(-)

--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -1106,6 +1106,14 @@ struct intel_fbc {
 			int src_w;
 			int src_h;
 			bool visible;
+			/*
+			 * Display surface base address adjustement for
+			 * pageflips. Note that on gen4+ this only adjusts up
+			 * to a tile, offsets within a tile are handled in
+			 * the hw itself (with the TILEOFF register).
+			 */
+			int adjusted_x;
+			int adjusted_y;
 		} plane;
 
 		struct {
--- a/drivers/gpu/drm/i915/intel_display.c
+++ b/drivers/gpu/drm/i915/intel_display.c
@@ -3306,9 +3306,6 @@ static void i9xx_update_primary_plane(st
 	else
 		crtc->dspaddr_offset = linear_offset;
 
-	crtc->adjusted_x = x;
-	crtc->adjusted_y = y;
-
 	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
 
 	if (INTEL_GEN(dev_priv) < 4) {
@@ -3577,9 +3574,6 @@ static void skylake_update_primary_plane
 
 	crtc->dspaddr_offset = surf_addr;
 
-	crtc->adjusted_x = src_x;
-	crtc->adjusted_y = src_y;
-
 	spin_lock_irqsave(&dev_priv->uncore.lock, irqflags);
 
 	if (IS_GEMINILAKE(dev_priv) || IS_CANNONLAKE(dev_priv)) {
--- a/drivers/gpu/drm/i915/intel_drv.h
+++ b/drivers/gpu/drm/i915/intel_drv.h
@@ -811,8 +811,6 @@ struct intel_crtc {
 	 * gen4+ this only adjusts up to a tile, offsets within a tile are
 	 * handled in the hw itself (with the TILEOFF register). */
 	u32 dspaddr_offset;
-	int adjusted_x;
-	int adjusted_y;
 
 	struct intel_crtc_state *config;
 
--- a/drivers/gpu/drm/i915/intel_fbc.c
+++ b/drivers/gpu/drm/i915/intel_fbc.c
@@ -71,7 +71,10 @@ static inline bool no_fbc_on_multiple_pi
  */
 static unsigned int get_crtc_fence_y_offset(struct intel_crtc *crtc)
 {
-	return crtc->base.y - crtc->adjusted_y;
+	struct drm_i915_private *dev_priv = to_i915(crtc->base.dev);
+	struct intel_fbc *fbc = &dev_priv->fbc;
+
+	return crtc->base.y - fbc->state_cache.plane.adjusted_y;
 }
 
 /*
@@ -727,8 +730,8 @@ static bool intel_fbc_hw_tracking_covers
 
 	intel_fbc_get_plane_source_size(&fbc->state_cache, &effective_w,
 					&effective_h);
-	effective_w += crtc->adjusted_x;
-	effective_h += crtc->adjusted_y;
+	effective_w += fbc->state_cache.plane.adjusted_x;
+	effective_h += fbc->state_cache.plane.adjusted_y;
 
 	return effective_w <= max_w && effective_h <= max_h;
 }
@@ -757,6 +760,8 @@ static void intel_fbc_update_state_cache
 	cache->plane.src_w = drm_rect_width(&plane_state->base.src) >> 16;
 	cache->plane.src_h = drm_rect_height(&plane_state->base.src) >> 16;
 	cache->plane.visible = plane_state->base.visible;
+	cache->plane.adjusted_x = plane_state->main.x;
+	cache->plane.adjusted_y = plane_state->main.y;
 
 	if (!cache->plane.visible)
 		return;
