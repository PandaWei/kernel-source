From 27606fd87895c3b45072a796caead8055a2f4b94 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Sat, 16 Sep 2017 21:44:13 +0100
Subject: [PATCH] drm/i915/execlists: Split insert_request()
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 27606fd87895c3b45072a796caead8055a2f4b94
Patch-mainline: v4.15-rc1
References: FATE#322643 bsc#1055900

In the next patch we will want to reinsert a request not at the end of
the priority queue, but at the front. Here we split insert_request()
into two, the first function retrieves the priority list (for reuse for
unsubmit later) and a wrapper function to insert at the end of that list
and to schedule the tasklet if we were first.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Reviewed-by: Micha≈Ç Winiarski <michal.winiarski@intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20170916204414.32762-3-chris@chris-wilson.co.uk
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_lrc.c |   35 +++++++++++++++++++----------------
 1 file changed, 19 insertions(+), 16 deletions(-)

--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -286,10 +286,10 @@ intel_lr_context_descriptor_update(struc
 	ce->lrc_desc = desc;
 }
 
-static bool
-insert_request(struct intel_engine_cs *engine,
-	       struct i915_priotree *pt,
-	       int prio)
+static struct i915_priolist *
+lookup_priolist(struct intel_engine_cs *engine,
+		struct i915_priotree *pt,
+		int prio)
 {
 	struct i915_priolist *p;
 	struct rb_node **parent, *rb;
@@ -311,8 +311,7 @@ find_priolist:
 			parent = &rb->rb_right;
 			first = false;
 		} else {
-			list_add_tail(&pt->link, &p->requests);
-			return false;
+			return p;
 		}
 	}
 
@@ -338,16 +337,14 @@ find_priolist:
 	}
 
 	p->priority = prio;
+	INIT_LIST_HEAD(&p->requests);
 	rb_link_node(&p->node, rb, parent);
 	rb_insert_color(&p->node, &engine->execlist_queue);
 
-	INIT_LIST_HEAD(&p->requests);
-	list_add_tail(&pt->link, &p->requests);
-
 	if (first)
 		engine->execlist_first = &p->node;
 
-	return first;
+	return ptr_pack_bits(p, first, 1);
 }
 
 static inline void
@@ -764,6 +761,17 @@ static void intel_lrc_irq_handler(unsign
 	intel_uncore_forcewake_put(dev_priv, engine->fw_domains);
 }
 
+static void insert_request(struct intel_engine_cs *engine,
+			   struct i915_priotree *pt,
+			   int prio)
+{
+	struct i915_priolist *p = lookup_priolist(engine, pt, prio);
+
+	list_add_tail(&pt->link, &ptr_mask_bits(p, 1)->requests);
+	if (ptr_unmask_bits(p, 1) && execlists_elsp_ready(engine))
+		tasklet_hi_schedule(&engine->irq_tasklet);
+}
+
 static void execlists_submit_request(struct drm_i915_gem_request *request)
 {
 	struct intel_engine_cs *engine = request->engine;
@@ -772,12 +780,7 @@ static void execlists_submit_request(str
 	/* Will be called from irq-context when using foreign fences. */
 	spin_lock_irqsave(&engine->timeline->lock, flags);
 
-	if (insert_request(engine,
-			   &request->priotree,
-			   request->priotree.priority)) {
-		if (execlists_elsp_ready(engine))
-			tasklet_hi_schedule(&engine->irq_tasklet);
-	}
+	insert_request(engine, &request->priotree, request->priotree.priority);
 
 	GEM_BUG_ON(!engine->execlist_first);
 	GEM_BUG_ON(list_empty(&request->priotree.link));
