From efa479352fc780b305fa186cafb5f416fdf2b2cb Mon Sep 17 00:00:00 2001
From: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Date: Tue, 15 Aug 2017 10:52:50 +0200
Subject: [PATCH] drm/nouveau: Fix merge commit
Git-commit: efa479352fc780b305fa186cafb5f416fdf2b2cb
Patch-mainline: v4.14-rc1
References: bsc#1095094

The most recent merge commit in airlied/drm-next has problems with
confusing old_crtc_state and new_crtc_state. Use the
for_each_oldnew_crtc_in_state macros to clean up the confusion,
and explicitly look at the correct state instead of looking at
asyh->state.

With these fixes it becomes more obvious what the code is trying to do,
which will hopefully prevent future confusion.

Cc: Dave Airlie <airlied@redhat.com>
Signed-off-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Signed-off-by: Dave Airlie <airlied@redhat.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/nouveau/nv50_display.c |   17 +++++++++--------
 1 file changed, 9 insertions(+), 8 deletions(-)

--- a/drivers/gpu/drm/nouveau/nv50_display.c
+++ b/drivers/gpu/drm/nouveau/nv50_display.c
@@ -3903,7 +3903,7 @@ static void
 nv50_disp_atomic_commit_tail(struct drm_atomic_state *state)
 {
 	struct drm_device *dev = state->dev;
-	struct drm_crtc_state *new_crtc_state;
+	struct drm_crtc_state *new_crtc_state, *old_crtc_state;
 	struct drm_crtc *crtc;
 	struct drm_plane_state *new_plane_state;
 	struct drm_plane *plane;
@@ -3924,13 +3924,13 @@ nv50_disp_atomic_commit_tail(struct drm_
 		mutex_lock(&disp->mutex);
 
 	/* Disable head(s). */
-	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
 		struct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);
 		struct nv50_head *head = nv50_head(crtc);
 
 		NV_ATOMIC(drm, "%s: clr %04x (set %04x)\n", crtc->name,
 			  asyh->clr.mask, asyh->set.mask);
-		if (new_crtc_state->active && !asyh->state.active)
+		if (old_crtc_state->active && !new_crtc_state->active)
 			drm_crtc_vblank_off(crtc);
 
 		if (asyh->clr.mask) {
@@ -4006,7 +4006,7 @@ nv50_disp_atomic_commit_tail(struct drm_
 	}
 
 	/* Update head(s). */
-	for_each_new_crtc_in_state(state, crtc, new_crtc_state, i) {
+	for_each_oldnew_crtc_in_state(state, crtc, old_crtc_state, new_crtc_state, i) {
 		struct nv50_head_atom *asyh = nv50_head_atom(new_crtc_state);
 		struct nv50_head *head = nv50_head(crtc);
 
@@ -4018,10 +4018,10 @@ nv50_disp_atomic_commit_tail(struct drm_
 			interlock_core = 1;
 		}
 
-		if (asyh->state.active) {
-			if (!new_crtc_state->active)
+		if (new_crtc_state->active) {
+			if (!old_crtc_state->active)
 				drm_crtc_vblank_on(crtc);
-			if (asyh->state.event)
+			if (new_crtc_state->event)
 				drm_crtc_vblank_get(crtc);
 		}
 	}
@@ -4070,11 +4070,12 @@ nv50_disp_atomic_commit_tail(struct drm_
 		if (new_crtc_state->event) {
 			unsigned long flags;
 			/* Get correct count/ts if racing with vblank irq */
-			if (crtc->state->active)
+			if (new_crtc_state->active)
 				drm_crtc_accurate_vblank_count(crtc);
 			spin_lock_irqsave(&crtc->dev->event_lock, flags);
 			drm_crtc_send_vblank_event(crtc, new_crtc_state->event);
 			spin_unlock_irqrestore(&crtc->dev->event_lock, flags);
+
 			new_crtc_state->event = NULL;
 			if (new_crtc_state->active)
 				drm_crtc_vblank_put(crtc);
