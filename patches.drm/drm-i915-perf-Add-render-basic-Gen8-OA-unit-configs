From 5182f646c7615ede9a9ba3ecd241f6cbe16829dc Mon Sep 17 00:00:00 2001
From: Robert Bragg <robert@sixbynine.org>
Date: Tue, 13 Jun 2017 12:23:02 +0100
Subject: [PATCH] drm/i915/perf: Add 'render basic' Gen8+ OA unit configs
Git-commit: 5182f646c7615ede9a9ba3ecd241f6cbe16829dc
Patch-mainline: v4.13-rc1
References: FATE#322643 bsc#1055900

Adds a static OA unit, MUX, B Counter + Flex EU configurations for basic
render metrics on Broadwell, Cherryview, Skylake and Broxton. These are
auto generated from an XML description of metric sets, currently
maintained in gputop, ref:

 https://github.com/rib/gputop
 > gputop-data/oa-*.xml
 > scripts/i915-perf-kernelgen.py

 $ make -C gputop-data -f Makefile.xml WHITELIST=RenderBasic

V2: add newlines to debug messages + fix comment (Matthew Auld)

Signed-off-by: Robert Bragg <robert@sixbynine.org>
Signed-off-by: Lionel Landwerlin <lionel.g.landwerlin@intel.com>
Reviewed-by: Matthew Auld <matthew.auld@intel.com>
Signed-off-by: Ben Widawsky <ben@bwidawsk.net>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/Makefile         |    8 
 drivers/gpu/drm/i915/i915_drv.h       |    6 
 drivers/gpu/drm/i915/i915_oa_bdw.c    |  392 ++++++++++++++++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_bdw.h    |   40 +++
 drivers/gpu/drm/i915/i915_oa_bxt.c    |  248 +++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_bxt.h    |   40 +++
 drivers/gpu/drm/i915/i915_oa_chv.c    |  238 ++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_chv.h    |   40 +++
 drivers/gpu/drm/i915/i915_oa_sklgt2.c |  238 ++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_sklgt2.h |   40 +++
 drivers/gpu/drm/i915/i915_oa_sklgt3.c |  249 +++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_sklgt3.h |   40 +++
 drivers/gpu/drm/i915/i915_oa_sklgt4.c |  260 ++++++++++++++++++++++
 drivers/gpu/drm/i915/i915_oa_sklgt4.h |   40 +++
 14 files changed, 1876 insertions(+), 3 deletions(-)
 create mode 100644 drivers/gpu/drm/i915/i915_oa_bdw.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_bdw.h
 create mode 100644 drivers/gpu/drm/i915/i915_oa_bxt.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_bxt.h
 create mode 100644 drivers/gpu/drm/i915/i915_oa_chv.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_chv.h
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt2.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt2.h
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt3.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt3.h
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt4.c
 create mode 100644 drivers/gpu/drm/i915/i915_oa_sklgt4.h

--- a/drivers/gpu/drm/i915/Makefile
+++ b/drivers/gpu/drm/i915/Makefile
@@ -129,7 +129,13 @@ i915-y += i915_vgpu.o
 
 # perf code
 i915-y += i915_perf.o \
-	  i915_oa_hsw.o
+	  i915_oa_hsw.o \
+	  i915_oa_bdw.o \
+	  i915_oa_chv.o \
+	  i915_oa_sklgt2.o \
+	  i915_oa_sklgt3.o \
+	  i915_oa_sklgt4.o \
+	  i915_oa_bxt.o
 
 ifeq ($(CONFIG_DRM_I915_GVT),y)
 i915-y += intel_gvt.o
--- a/drivers/gpu/drm/i915/i915_drv.h
+++ b/drivers/gpu/drm/i915/i915_drv.h
@@ -2418,12 +2418,14 @@ struct drm_i915_private {
 
 			int metrics_set;
 
-			const struct i915_oa_reg *mux_regs[1];
-			int mux_regs_lens[1];
+			const struct i915_oa_reg *mux_regs[2];
+			int mux_regs_lens[2];
 			int n_mux_configs;
 
 			const struct i915_oa_reg *b_counter_regs;
 			int b_counter_regs_len;
+			const struct i915_oa_reg *flex_regs;
+			int flex_regs_len;
 
 			struct {
 				struct i915_vma *vma;
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_bdw.c
@@ -0,0 +1,392 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_bdw.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_bdw = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+	{ _MMIO(0x2740), 0x00000000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic_0_slices_0x01[] = {
+	{ _MMIO(0x9888), 0x143f000f },
+	{ _MMIO(0x9888), 0x14110014 },
+	{ _MMIO(0x9888), 0x14310014 },
+	{ _MMIO(0x9888), 0x14bf000f },
+	{ _MMIO(0x9888), 0x118a0317 },
+	{ _MMIO(0x9888), 0x13837be0 },
+	{ _MMIO(0x9888), 0x3b800060 },
+	{ _MMIO(0x9888), 0x3d800005 },
+	{ _MMIO(0x9888), 0x005c4000 },
+	{ _MMIO(0x9888), 0x065c8000 },
+	{ _MMIO(0x9888), 0x085cc000 },
+	{ _MMIO(0x9888), 0x003d8000 },
+	{ _MMIO(0x9888), 0x183d0800 },
+	{ _MMIO(0x9888), 0x0a3f0023 },
+	{ _MMIO(0x9888), 0x103f0000 },
+	{ _MMIO(0x9888), 0x00584000 },
+	{ _MMIO(0x9888), 0x08584000 },
+	{ _MMIO(0x9888), 0x0a5a4000 },
+	{ _MMIO(0x9888), 0x005b4000 },
+	{ _MMIO(0x9888), 0x0e5b8000 },
+	{ _MMIO(0x9888), 0x185b2400 },
+	{ _MMIO(0x9888), 0x0a1d4000 },
+	{ _MMIO(0x9888), 0x0c1f0800 },
+	{ _MMIO(0x9888), 0x0e1faa00 },
+	{ _MMIO(0x9888), 0x00384000 },
+	{ _MMIO(0x9888), 0x0e384000 },
+	{ _MMIO(0x9888), 0x16384000 },
+	{ _MMIO(0x9888), 0x18380001 },
+	{ _MMIO(0x9888), 0x00392000 },
+	{ _MMIO(0x9888), 0x06398000 },
+	{ _MMIO(0x9888), 0x0839a000 },
+	{ _MMIO(0x9888), 0x0a391000 },
+	{ _MMIO(0x9888), 0x00104000 },
+	{ _MMIO(0x9888), 0x08104000 },
+	{ _MMIO(0x9888), 0x00110030 },
+	{ _MMIO(0x9888), 0x08110031 },
+	{ _MMIO(0x9888), 0x10110000 },
+	{ _MMIO(0x9888), 0x00134000 },
+	{ _MMIO(0x9888), 0x16130020 },
+	{ _MMIO(0x9888), 0x06308000 },
+	{ _MMIO(0x9888), 0x08308000 },
+	{ _MMIO(0x9888), 0x06311800 },
+	{ _MMIO(0x9888), 0x08311880 },
+	{ _MMIO(0x9888), 0x10310000 },
+	{ _MMIO(0x9888), 0x0e334000 },
+	{ _MMIO(0x9888), 0x16330080 },
+	{ _MMIO(0x9888), 0x0abf1180 },
+	{ _MMIO(0x9888), 0x10bf0000 },
+	{ _MMIO(0x9888), 0x0ada8000 },
+	{ _MMIO(0x9888), 0x0a9d8000 },
+	{ _MMIO(0x9888), 0x109f0002 },
+	{ _MMIO(0x9888), 0x0ab94000 },
+	{ _MMIO(0x9888), 0x0d888000 },
+	{ _MMIO(0x9888), 0x038a0380 },
+	{ _MMIO(0x9888), 0x058a000e },
+	{ _MMIO(0x9888), 0x018a8000 },
+	{ _MMIO(0x9888), 0x0f8a8000 },
+	{ _MMIO(0x9888), 0x198a8000 },
+	{ _MMIO(0x9888), 0x1b8a00a0 },
+	{ _MMIO(0x9888), 0x078a0000 },
+	{ _MMIO(0x9888), 0x098a0000 },
+	{ _MMIO(0x9888), 0x238b2820 },
+	{ _MMIO(0x9888), 0x258b2550 },
+	{ _MMIO(0x9888), 0x198c1000 },
+	{ _MMIO(0x9888), 0x0b8d8000 },
+	{ _MMIO(0x9888), 0x1f85aa80 },
+	{ _MMIO(0x9888), 0x2185aaa0 },
+	{ _MMIO(0x9888), 0x2385002a },
+	{ _MMIO(0x9888), 0x0d831021 },
+	{ _MMIO(0x9888), 0x0f83572f },
+	{ _MMIO(0x9888), 0x01835680 },
+	{ _MMIO(0x9888), 0x0383002c },
+	{ _MMIO(0x9888), 0x11830000 },
+	{ _MMIO(0x9888), 0x19835400 },
+	{ _MMIO(0x9888), 0x1b830001 },
+	{ _MMIO(0x9888), 0x05830000 },
+	{ _MMIO(0x9888), 0x07834000 },
+	{ _MMIO(0x9888), 0x09834000 },
+	{ _MMIO(0x9888), 0x0184c000 },
+	{ _MMIO(0x9888), 0x07848000 },
+	{ _MMIO(0x9888), 0x0984c000 },
+	{ _MMIO(0x9888), 0x0b84c000 },
+	{ _MMIO(0x9888), 0x0d84c000 },
+	{ _MMIO(0x9888), 0x0f84c000 },
+	{ _MMIO(0x9888), 0x0384c000 },
+	{ _MMIO(0x9888), 0x05844000 },
+	{ _MMIO(0x9888), 0x1b80c137 },
+	{ _MMIO(0x9888), 0x1d80c147 },
+	{ _MMIO(0x9888), 0x21800000 },
+	{ _MMIO(0x9888), 0x1180c000 },
+	{ _MMIO(0x9888), 0x17808000 },
+	{ _MMIO(0x9888), 0x1980c000 },
+	{ _MMIO(0x9888), 0x1f80c000 },
+	{ _MMIO(0x9888), 0x1380c000 },
+	{ _MMIO(0x9888), 0x15804000 },
+	{ _MMIO(0x9888), 0x4d801110 },
+	{ _MMIO(0x9888), 0x4f800331 },
+	{ _MMIO(0x9888), 0x43800802 },
+	{ _MMIO(0x9888), 0x51800000 },
+	{ _MMIO(0x9888), 0x45801465 },
+	{ _MMIO(0x9888), 0x53801111 },
+	{ _MMIO(0x9888), 0x478014a5 },
+	{ _MMIO(0x9888), 0x31800000 },
+	{ _MMIO(0x9888), 0x3f800ca5 },
+	{ _MMIO(0x9888), 0x41800003 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic_1_slices_0x02[] = {
+	{ _MMIO(0x9888), 0x143f000f },
+	{ _MMIO(0x9888), 0x14bf000f },
+	{ _MMIO(0x9888), 0x14910014 },
+	{ _MMIO(0x9888), 0x14b10014 },
+	{ _MMIO(0x9888), 0x118a0317 },
+	{ _MMIO(0x9888), 0x13837be0 },
+	{ _MMIO(0x9888), 0x3b800060 },
+	{ _MMIO(0x9888), 0x3d800005 },
+	{ _MMIO(0x9888), 0x0a3f0023 },
+	{ _MMIO(0x9888), 0x103f0000 },
+	{ _MMIO(0x9888), 0x0a5a4000 },
+	{ _MMIO(0x9888), 0x0a1d4000 },
+	{ _MMIO(0x9888), 0x0e1f8000 },
+	{ _MMIO(0x9888), 0x0a391000 },
+	{ _MMIO(0x9888), 0x00dc4000 },
+	{ _MMIO(0x9888), 0x06dc8000 },
+	{ _MMIO(0x9888), 0x08dcc000 },
+	{ _MMIO(0x9888), 0x00bd8000 },
+	{ _MMIO(0x9888), 0x18bd0800 },
+	{ _MMIO(0x9888), 0x0abf1180 },
+	{ _MMIO(0x9888), 0x10bf0000 },
+	{ _MMIO(0x9888), 0x00d84000 },
+	{ _MMIO(0x9888), 0x08d84000 },
+	{ _MMIO(0x9888), 0x0ada8000 },
+	{ _MMIO(0x9888), 0x00db4000 },
+	{ _MMIO(0x9888), 0x0edb8000 },
+	{ _MMIO(0x9888), 0x18db2400 },
+	{ _MMIO(0x9888), 0x0a9d8000 },
+	{ _MMIO(0x9888), 0x0c9f0800 },
+	{ _MMIO(0x9888), 0x0e9f2a00 },
+	{ _MMIO(0x9888), 0x109f0002 },
+	{ _MMIO(0x9888), 0x00b84000 },
+	{ _MMIO(0x9888), 0x0eb84000 },
+	{ _MMIO(0x9888), 0x16b84000 },
+	{ _MMIO(0x9888), 0x18b80001 },
+	{ _MMIO(0x9888), 0x00b92000 },
+	{ _MMIO(0x9888), 0x06b98000 },
+	{ _MMIO(0x9888), 0x08b9a000 },
+	{ _MMIO(0x9888), 0x0ab94000 },
+	{ _MMIO(0x9888), 0x00904000 },
+	{ _MMIO(0x9888), 0x08904000 },
+	{ _MMIO(0x9888), 0x00910030 },
+	{ _MMIO(0x9888), 0x08910031 },
+	{ _MMIO(0x9888), 0x10910000 },
+	{ _MMIO(0x9888), 0x00934000 },
+	{ _MMIO(0x9888), 0x16930020 },
+	{ _MMIO(0x9888), 0x06b08000 },
+	{ _MMIO(0x9888), 0x08b08000 },
+	{ _MMIO(0x9888), 0x06b11800 },
+	{ _MMIO(0x9888), 0x08b11880 },
+	{ _MMIO(0x9888), 0x10b10000 },
+	{ _MMIO(0x9888), 0x0eb34000 },
+	{ _MMIO(0x9888), 0x16b30080 },
+	{ _MMIO(0x9888), 0x01888000 },
+	{ _MMIO(0x9888), 0x0d88b800 },
+	{ _MMIO(0x9888), 0x038a0380 },
+	{ _MMIO(0x9888), 0x058a000e },
+	{ _MMIO(0x9888), 0x1b8a0080 },
+	{ _MMIO(0x9888), 0x078a0000 },
+	{ _MMIO(0x9888), 0x098a0000 },
+	{ _MMIO(0x9888), 0x238b2840 },
+	{ _MMIO(0x9888), 0x258b26a0 },
+	{ _MMIO(0x9888), 0x018c4000 },
+	{ _MMIO(0x9888), 0x0f8c4000 },
+	{ _MMIO(0x9888), 0x178c2000 },
+	{ _MMIO(0x9888), 0x198c1100 },
+	{ _MMIO(0x9888), 0x018d2000 },
+	{ _MMIO(0x9888), 0x078d8000 },
+	{ _MMIO(0x9888), 0x098da000 },
+	{ _MMIO(0x9888), 0x0b8d8000 },
+	{ _MMIO(0x9888), 0x1f85aa80 },
+	{ _MMIO(0x9888), 0x2185aaa0 },
+	{ _MMIO(0x9888), 0x2385002a },
+	{ _MMIO(0x9888), 0x0d831021 },
+	{ _MMIO(0x9888), 0x0f83572f },
+	{ _MMIO(0x9888), 0x01835680 },
+	{ _MMIO(0x9888), 0x0383002c },
+	{ _MMIO(0x9888), 0x11830000 },
+	{ _MMIO(0x9888), 0x19835400 },
+	{ _MMIO(0x9888), 0x1b830001 },
+	{ _MMIO(0x9888), 0x05830000 },
+	{ _MMIO(0x9888), 0x07834000 },
+	{ _MMIO(0x9888), 0x09834000 },
+	{ _MMIO(0x9888), 0x0184c000 },
+	{ _MMIO(0x9888), 0x07848000 },
+	{ _MMIO(0x9888), 0x0984c000 },
+	{ _MMIO(0x9888), 0x0b84c000 },
+	{ _MMIO(0x9888), 0x0d84c000 },
+	{ _MMIO(0x9888), 0x0f84c000 },
+	{ _MMIO(0x9888), 0x0384c000 },
+	{ _MMIO(0x9888), 0x05844000 },
+	{ _MMIO(0x9888), 0x1b80c137 },
+	{ _MMIO(0x9888), 0x1d80c147 },
+	{ _MMIO(0x9888), 0x21800000 },
+	{ _MMIO(0x9888), 0x1180c000 },
+	{ _MMIO(0x9888), 0x17808000 },
+	{ _MMIO(0x9888), 0x1980c000 },
+	{ _MMIO(0x9888), 0x1f80c000 },
+	{ _MMIO(0x9888), 0x1380c000 },
+	{ _MMIO(0x9888), 0x15804000 },
+	{ _MMIO(0x9888), 0x4d801550 },
+	{ _MMIO(0x9888), 0x4f800331 },
+	{ _MMIO(0x9888), 0x43800802 },
+	{ _MMIO(0x9888), 0x51800400 },
+	{ _MMIO(0x9888), 0x458004a1 },
+	{ _MMIO(0x9888), 0x53805555 },
+	{ _MMIO(0x9888), 0x47800421 },
+	{ _MMIO(0x9888), 0x31800000 },
+	{ _MMIO(0x9888), 0x3f801421 },
+	{ _MMIO(0x9888), 0x41800845 },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 2);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 2);
+
+	if (INTEL_INFO(dev_priv)->sseu.slice_mask & 0x01) {
+		regs[n] = mux_config_render_basic_0_slices_0x01;
+		lens[n] = ARRAY_SIZE(mux_config_render_basic_0_slices_0x01);
+		n++;
+	}
+	if (INTEL_INFO(dev_priv)->sseu.slice_mask & 0x02) {
+		regs[n] = mux_config_render_basic_1_slices_0x02;
+		lens[n] = ARRAY_SIZE(mux_config_render_basic_1_slices_0x02);
+		n++;
+	}
+
+	return n;
+}
+
+int i915_oa_select_metric_set_bdw(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "b541bd57-0e0f-4154-b4c0-5858010a2bf7",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_bdw(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_bdw(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_bdw.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_BDW_H__
+#define __I915_OA_BDW_H__
+
+extern int i915_oa_n_builtin_metric_sets_bdw;
+
+extern int i915_oa_select_metric_set_bdw(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_bdw(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_bdw(struct drm_i915_private *dev_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_bxt.c
@@ -0,0 +1,248 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_bxt.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_bxt = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+	{ _MMIO(0x2740), 0x00000000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic_0_sku_gte_0x03[] = {
+	{ _MMIO(0x9888), 0x166c00f0 },
+	{ _MMIO(0x9888), 0x12120280 },
+	{ _MMIO(0x9888), 0x12320280 },
+	{ _MMIO(0x9888), 0x11930317 },
+	{ _MMIO(0x9888), 0x159303df },
+	{ _MMIO(0x9888), 0x3f900c00 },
+	{ _MMIO(0x9888), 0x419000a0 },
+	{ _MMIO(0x9888), 0x002d1000 },
+	{ _MMIO(0x9888), 0x062d4000 },
+	{ _MMIO(0x9888), 0x082d5000 },
+	{ _MMIO(0x9888), 0x0a2d1000 },
+	{ _MMIO(0x9888), 0x0c2e0800 },
+	{ _MMIO(0x9888), 0x0e2e5900 },
+	{ _MMIO(0x9888), 0x0a4c8000 },
+	{ _MMIO(0x9888), 0x0c4c8000 },
+	{ _MMIO(0x9888), 0x0e4c4000 },
+	{ _MMIO(0x9888), 0x064e8000 },
+	{ _MMIO(0x9888), 0x084e8000 },
+	{ _MMIO(0x9888), 0x0a4e2000 },
+	{ _MMIO(0x9888), 0x1c4f0010 },
+	{ _MMIO(0x9888), 0x0a6c0053 },
+	{ _MMIO(0x9888), 0x106c0000 },
+	{ _MMIO(0x9888), 0x1c6c0000 },
+	{ _MMIO(0x9888), 0x1a0fcc00 },
+	{ _MMIO(0x9888), 0x1c0f0002 },
+	{ _MMIO(0x9888), 0x1c2c0040 },
+	{ _MMIO(0x9888), 0x00101000 },
+	{ _MMIO(0x9888), 0x04101000 },
+	{ _MMIO(0x9888), 0x00114000 },
+	{ _MMIO(0x9888), 0x08114000 },
+	{ _MMIO(0x9888), 0x00120020 },
+	{ _MMIO(0x9888), 0x08120021 },
+	{ _MMIO(0x9888), 0x00141000 },
+	{ _MMIO(0x9888), 0x08141000 },
+	{ _MMIO(0x9888), 0x02308000 },
+	{ _MMIO(0x9888), 0x04302000 },
+	{ _MMIO(0x9888), 0x06318000 },
+	{ _MMIO(0x9888), 0x08318000 },
+	{ _MMIO(0x9888), 0x06320800 },
+	{ _MMIO(0x9888), 0x08320840 },
+	{ _MMIO(0x9888), 0x00320000 },
+	{ _MMIO(0x9888), 0x06344000 },
+	{ _MMIO(0x9888), 0x08344000 },
+	{ _MMIO(0x9888), 0x0d931831 },
+	{ _MMIO(0x9888), 0x0f939f3f },
+	{ _MMIO(0x9888), 0x01939e80 },
+	{ _MMIO(0x9888), 0x039303bc },
+	{ _MMIO(0x9888), 0x0593000e },
+	{ _MMIO(0x9888), 0x1993002a },
+	{ _MMIO(0x9888), 0x07930000 },
+	{ _MMIO(0x9888), 0x09930000 },
+	{ _MMIO(0x9888), 0x1d900177 },
+	{ _MMIO(0x9888), 0x1f900187 },
+	{ _MMIO(0x9888), 0x35900000 },
+	{ _MMIO(0x9888), 0x13904000 },
+	{ _MMIO(0x9888), 0x21904000 },
+	{ _MMIO(0x9888), 0x23904000 },
+	{ _MMIO(0x9888), 0x25904000 },
+	{ _MMIO(0x9888), 0x27904000 },
+	{ _MMIO(0x9888), 0x2b904000 },
+	{ _MMIO(0x9888), 0x2d904000 },
+	{ _MMIO(0x9888), 0x2f904000 },
+	{ _MMIO(0x9888), 0x31904000 },
+	{ _MMIO(0x9888), 0x15904000 },
+	{ _MMIO(0x9888), 0x17904000 },
+	{ _MMIO(0x9888), 0x19904000 },
+	{ _MMIO(0x9888), 0x1b904000 },
+	{ _MMIO(0x9888), 0x53901110 },
+	{ _MMIO(0x9888), 0x43900423 },
+	{ _MMIO(0x9888), 0x55900111 },
+	{ _MMIO(0x9888), 0x47900c02 },
+	{ _MMIO(0x9888), 0x57900000 },
+	{ _MMIO(0x9888), 0x49900020 },
+	{ _MMIO(0x9888), 0x59901111 },
+	{ _MMIO(0x9888), 0x4b900421 },
+	{ _MMIO(0x9888), 0x37900000 },
+	{ _MMIO(0x9888), 0x33900000 },
+	{ _MMIO(0x9888), 0x4d900001 },
+	{ _MMIO(0x9888), 0x45900821 },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 1);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 1);
+
+	if (dev_priv->drm.pdev->revision >= 0x03) {
+		regs[n] = mux_config_render_basic_0_sku_gte_0x03;
+		lens[n] = ARRAY_SIZE(mux_config_render_basic_0_sku_gte_0x03);
+		n++;
+	}
+
+	return n;
+}
+
+int i915_oa_select_metric_set_bxt(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "22b9519a-e9ba-4c41-8b54-f4f8ca14fa0a",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_bxt(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_bxt(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_bxt.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_BXT_H__
+#define __I915_OA_BXT_H__
+
+extern int i915_oa_n_builtin_metric_sets_bxt;
+
+extern int i915_oa_select_metric_set_bxt(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_bxt(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_bxt(struct drm_i915_private *dev_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_chv.c
@@ -0,0 +1,238 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_chv.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_chv = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2740), 0x00000000 },
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic[] = {
+	{ _MMIO(0x9888), 0x59800000 },
+	{ _MMIO(0x9888), 0x59800001 },
+	{ _MMIO(0x9888), 0x285a0006 },
+	{ _MMIO(0x9888), 0x2c110014 },
+	{ _MMIO(0x9888), 0x2e110000 },
+	{ _MMIO(0x9888), 0x2c310014 },
+	{ _MMIO(0x9888), 0x2e310000 },
+	{ _MMIO(0x9888), 0x2b8303df },
+	{ _MMIO(0x9888), 0x3580024f },
+	{ _MMIO(0x9888), 0x00580888 },
+	{ _MMIO(0x9888), 0x1e5a0015 },
+	{ _MMIO(0x9888), 0x205a0014 },
+	{ _MMIO(0x9888), 0x045a0000 },
+	{ _MMIO(0x9888), 0x025a0000 },
+	{ _MMIO(0x9888), 0x02180500 },
+	{ _MMIO(0x9888), 0x00190555 },
+	{ _MMIO(0x9888), 0x021d0500 },
+	{ _MMIO(0x9888), 0x021f0a00 },
+	{ _MMIO(0x9888), 0x00380444 },
+	{ _MMIO(0x9888), 0x02390500 },
+	{ _MMIO(0x9888), 0x003a0666 },
+	{ _MMIO(0x9888), 0x00100111 },
+	{ _MMIO(0x9888), 0x06110030 },
+	{ _MMIO(0x9888), 0x0a110031 },
+	{ _MMIO(0x9888), 0x0e110046 },
+	{ _MMIO(0x9888), 0x04110000 },
+	{ _MMIO(0x9888), 0x00110000 },
+	{ _MMIO(0x9888), 0x00130111 },
+	{ _MMIO(0x9888), 0x00300444 },
+	{ _MMIO(0x9888), 0x08310030 },
+	{ _MMIO(0x9888), 0x0c310031 },
+	{ _MMIO(0x9888), 0x10310046 },
+	{ _MMIO(0x9888), 0x04310000 },
+	{ _MMIO(0x9888), 0x00310000 },
+	{ _MMIO(0x9888), 0x00330444 },
+	{ _MMIO(0x9888), 0x038a0a00 },
+	{ _MMIO(0x9888), 0x018b0fff },
+	{ _MMIO(0x9888), 0x038b0a00 },
+	{ _MMIO(0x9888), 0x01855000 },
+	{ _MMIO(0x9888), 0x03850055 },
+	{ _MMIO(0x9888), 0x13830021 },
+	{ _MMIO(0x9888), 0x15830020 },
+	{ _MMIO(0x9888), 0x1783002f },
+	{ _MMIO(0x9888), 0x1983002e },
+	{ _MMIO(0x9888), 0x1b83002d },
+	{ _MMIO(0x9888), 0x1d83002c },
+	{ _MMIO(0x9888), 0x05830000 },
+	{ _MMIO(0x9888), 0x01840555 },
+	{ _MMIO(0x9888), 0x03840500 },
+	{ _MMIO(0x9888), 0x23800074 },
+	{ _MMIO(0x9888), 0x2580007d },
+	{ _MMIO(0x9888), 0x05800000 },
+	{ _MMIO(0x9888), 0x01805000 },
+	{ _MMIO(0x9888), 0x03800055 },
+	{ _MMIO(0x9888), 0x01865000 },
+	{ _MMIO(0x9888), 0x03860055 },
+	{ _MMIO(0x9888), 0x01875000 },
+	{ _MMIO(0x9888), 0x03870055 },
+	{ _MMIO(0x9888), 0x418000aa },
+	{ _MMIO(0x9888), 0x4380000a },
+	{ _MMIO(0x9888), 0x45800000 },
+	{ _MMIO(0x9888), 0x4780000a },
+	{ _MMIO(0x9888), 0x49800000 },
+	{ _MMIO(0x9888), 0x4b800000 },
+	{ _MMIO(0x9888), 0x4d800000 },
+	{ _MMIO(0x9888), 0x4f800000 },
+	{ _MMIO(0x9888), 0x51800000 },
+	{ _MMIO(0x9888), 0x53800000 },
+	{ _MMIO(0x9888), 0x55800000 },
+	{ _MMIO(0x9888), 0x57800000 },
+	{ _MMIO(0x9888), 0x59800000 },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 1);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 1);
+
+	regs[n] = mux_config_render_basic;
+	lens[n] = ARRAY_SIZE(mux_config_render_basic);
+	n++;
+
+	return n;
+}
+
+int i915_oa_select_metric_set_chv(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "9d8a3af5-c02c-4a4a-b947-f1672469e0fb",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_chv(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_chv(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_chv.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_CHV_H__
+#define __I915_OA_CHV_H__
+
+extern int i915_oa_n_builtin_metric_sets_chv;
+
+extern int i915_oa_select_metric_set_chv(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_chv(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_chv(struct drm_i915_private *dev_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt2.c
@@ -0,0 +1,238 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_sklgt2.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_sklgt2 = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+	{ _MMIO(0x2740), 0x00000000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic_1_sku_gte_0x02[] = {
+	{ _MMIO(0x9888), 0x166c01e0 },
+	{ _MMIO(0x9888), 0x12170280 },
+	{ _MMIO(0x9888), 0x12370280 },
+	{ _MMIO(0x9888), 0x11930317 },
+	{ _MMIO(0x9888), 0x159303df },
+	{ _MMIO(0x9888), 0x3f900003 },
+	{ _MMIO(0x9888), 0x1a4e0080 },
+	{ _MMIO(0x9888), 0x0a6c0053 },
+	{ _MMIO(0x9888), 0x106c0000 },
+	{ _MMIO(0x9888), 0x1c6c0000 },
+	{ _MMIO(0x9888), 0x0a1b4000 },
+	{ _MMIO(0x9888), 0x1c1c0001 },
+	{ _MMIO(0x9888), 0x002f1000 },
+	{ _MMIO(0x9888), 0x042f1000 },
+	{ _MMIO(0x9888), 0x004c4000 },
+	{ _MMIO(0x9888), 0x0a4c8400 },
+	{ _MMIO(0x9888), 0x000d2000 },
+	{ _MMIO(0x9888), 0x060d8000 },
+	{ _MMIO(0x9888), 0x080da000 },
+	{ _MMIO(0x9888), 0x0a0d2000 },
+	{ _MMIO(0x9888), 0x0c0f0400 },
+	{ _MMIO(0x9888), 0x0e0f6600 },
+	{ _MMIO(0x9888), 0x002c8000 },
+	{ _MMIO(0x9888), 0x162c2200 },
+	{ _MMIO(0x9888), 0x062d8000 },
+	{ _MMIO(0x9888), 0x082d8000 },
+	{ _MMIO(0x9888), 0x00133000 },
+	{ _MMIO(0x9888), 0x08133000 },
+	{ _MMIO(0x9888), 0x00170020 },
+	{ _MMIO(0x9888), 0x08170021 },
+	{ _MMIO(0x9888), 0x10170000 },
+	{ _MMIO(0x9888), 0x0633c000 },
+	{ _MMIO(0x9888), 0x0833c000 },
+	{ _MMIO(0x9888), 0x06370800 },
+	{ _MMIO(0x9888), 0x08370840 },
+	{ _MMIO(0x9888), 0x10370000 },
+	{ _MMIO(0x9888), 0x0d933031 },
+	{ _MMIO(0x9888), 0x0f933e3f },
+	{ _MMIO(0x9888), 0x01933d00 },
+	{ _MMIO(0x9888), 0x0393073c },
+	{ _MMIO(0x9888), 0x0593000e },
+	{ _MMIO(0x9888), 0x1d930000 },
+	{ _MMIO(0x9888), 0x19930000 },
+	{ _MMIO(0x9888), 0x1b930000 },
+	{ _MMIO(0x9888), 0x1d900157 },
+	{ _MMIO(0x9888), 0x1f900158 },
+	{ _MMIO(0x9888), 0x35900000 },
+	{ _MMIO(0x9888), 0x2b908000 },
+	{ _MMIO(0x9888), 0x2d908000 },
+	{ _MMIO(0x9888), 0x2f908000 },
+	{ _MMIO(0x9888), 0x31908000 },
+	{ _MMIO(0x9888), 0x15908000 },
+	{ _MMIO(0x9888), 0x17908000 },
+	{ _MMIO(0x9888), 0x19908000 },
+	{ _MMIO(0x9888), 0x1b908000 },
+	{ _MMIO(0x9888), 0x1190001f },
+	{ _MMIO(0x9888), 0x51904400 },
+	{ _MMIO(0x9888), 0x41900020 },
+	{ _MMIO(0x9888), 0x55900000 },
+	{ _MMIO(0x9888), 0x45900c21 },
+	{ _MMIO(0x9888), 0x47900061 },
+	{ _MMIO(0x9888), 0x57904440 },
+	{ _MMIO(0x9888), 0x49900000 },
+	{ _MMIO(0x9888), 0x37900000 },
+	{ _MMIO(0x9888), 0x33900000 },
+	{ _MMIO(0x9888), 0x4b900000 },
+	{ _MMIO(0x9888), 0x59900004 },
+	{ _MMIO(0x9888), 0x43900000 },
+	{ _MMIO(0x9888), 0x53904444 },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 1);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 1);
+
+	if (dev_priv->drm.pdev->revision >= 0x02) {
+		regs[n] = mux_config_render_basic_1_sku_gte_0x02;
+		lens[n] = ARRAY_SIZE(mux_config_render_basic_1_sku_gte_0x02);
+		n++;
+	}
+
+	return n;
+}
+
+int i915_oa_select_metric_set_sklgt2(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "f519e481-24d2-4d42-87c9-3fdd12c00202",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_sklgt2(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_sklgt2(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt2.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_SKLGT2_H__
+#define __I915_OA_SKLGT2_H__
+
+extern int i915_oa_n_builtin_metric_sets_sklgt2;
+
+extern int i915_oa_select_metric_set_sklgt2(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_sklgt2(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_sklgt2(struct drm_i915_private *dev_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt3.c
@@ -0,0 +1,249 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_sklgt3.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_sklgt3 = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+	{ _MMIO(0x2740), 0x00000000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic[] = {
+	{ _MMIO(0x9888), 0x166c01e0 },
+	{ _MMIO(0x9888), 0x12170280 },
+	{ _MMIO(0x9888), 0x12370280 },
+	{ _MMIO(0x9888), 0x16ec01e0 },
+	{ _MMIO(0x9888), 0x11930317 },
+	{ _MMIO(0x9888), 0x159303df },
+	{ _MMIO(0x9888), 0x3f900003 },
+	{ _MMIO(0x9888), 0x1a4e0380 },
+	{ _MMIO(0x9888), 0x0a6c0053 },
+	{ _MMIO(0x9888), 0x106c0000 },
+	{ _MMIO(0x9888), 0x1c6c0000 },
+	{ _MMIO(0x9888), 0x0a1b4000 },
+	{ _MMIO(0x9888), 0x1c1c0001 },
+	{ _MMIO(0x9888), 0x002f1000 },
+	{ _MMIO(0x9888), 0x042f1000 },
+	{ _MMIO(0x9888), 0x004c4000 },
+	{ _MMIO(0x9888), 0x0a4c8400 },
+	{ _MMIO(0x9888), 0x0c4c0002 },
+	{ _MMIO(0x9888), 0x000d2000 },
+	{ _MMIO(0x9888), 0x060d8000 },
+	{ _MMIO(0x9888), 0x080da000 },
+	{ _MMIO(0x9888), 0x0a0da000 },
+	{ _MMIO(0x9888), 0x0c0f0400 },
+	{ _MMIO(0x9888), 0x0e0f6600 },
+	{ _MMIO(0x9888), 0x100f0001 },
+	{ _MMIO(0x9888), 0x002c8000 },
+	{ _MMIO(0x9888), 0x162ca200 },
+	{ _MMIO(0x9888), 0x062d8000 },
+	{ _MMIO(0x9888), 0x082d8000 },
+	{ _MMIO(0x9888), 0x00133000 },
+	{ _MMIO(0x9888), 0x08133000 },
+	{ _MMIO(0x9888), 0x00170020 },
+	{ _MMIO(0x9888), 0x08170021 },
+	{ _MMIO(0x9888), 0x10170000 },
+	{ _MMIO(0x9888), 0x0633c000 },
+	{ _MMIO(0x9888), 0x0833c000 },
+	{ _MMIO(0x9888), 0x06370800 },
+	{ _MMIO(0x9888), 0x08370840 },
+	{ _MMIO(0x9888), 0x10370000 },
+	{ _MMIO(0x9888), 0x1ace0200 },
+	{ _MMIO(0x9888), 0x0aec5300 },
+	{ _MMIO(0x9888), 0x10ec0000 },
+	{ _MMIO(0x9888), 0x1cec0000 },
+	{ _MMIO(0x9888), 0x0a9b8000 },
+	{ _MMIO(0x9888), 0x1c9c0002 },
+	{ _MMIO(0x9888), 0x0ccc0002 },
+	{ _MMIO(0x9888), 0x0a8d8000 },
+	{ _MMIO(0x9888), 0x108f0001 },
+	{ _MMIO(0x9888), 0x16ac8000 },
+	{ _MMIO(0x9888), 0x0d933031 },
+	{ _MMIO(0x9888), 0x0f933e3f },
+	{ _MMIO(0x9888), 0x01933d00 },
+	{ _MMIO(0x9888), 0x0393073c },
+	{ _MMIO(0x9888), 0x0593000e },
+	{ _MMIO(0x9888), 0x1d930000 },
+	{ _MMIO(0x9888), 0x19930000 },
+	{ _MMIO(0x9888), 0x1b930000 },
+	{ _MMIO(0x9888), 0x1d900157 },
+	{ _MMIO(0x9888), 0x1f900158 },
+	{ _MMIO(0x9888), 0x35900000 },
+	{ _MMIO(0x9888), 0x2b908000 },
+	{ _MMIO(0x9888), 0x2d908000 },
+	{ _MMIO(0x9888), 0x2f908000 },
+	{ _MMIO(0x9888), 0x31908000 },
+	{ _MMIO(0x9888), 0x15908000 },
+	{ _MMIO(0x9888), 0x17908000 },
+	{ _MMIO(0x9888), 0x19908000 },
+	{ _MMIO(0x9888), 0x1b908000 },
+	{ _MMIO(0x9888), 0x1190003f },
+	{ _MMIO(0x9888), 0x51907710 },
+	{ _MMIO(0x9888), 0x419020a0 },
+	{ _MMIO(0x9888), 0x55901515 },
+	{ _MMIO(0x9888), 0x45900529 },
+	{ _MMIO(0x9888), 0x47901025 },
+	{ _MMIO(0x9888), 0x57907770 },
+	{ _MMIO(0x9888), 0x49902100 },
+	{ _MMIO(0x9888), 0x37900000 },
+	{ _MMIO(0x9888), 0x33900000 },
+	{ _MMIO(0x9888), 0x4b900108 },
+	{ _MMIO(0x9888), 0x59900007 },
+	{ _MMIO(0x9888), 0x43902108 },
+	{ _MMIO(0x9888), 0x53907777 },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 1);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 1);
+
+	regs[n] = mux_config_render_basic;
+	lens[n] = ARRAY_SIZE(mux_config_render_basic);
+	n++;
+
+	return n;
+}
+
+int i915_oa_select_metric_set_sklgt3(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "4616d450-2393-4836-8146-53c5ed84d359",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_sklgt3(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_sklgt3(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt3.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_SKLGT3_H__
+#define __I915_OA_SKLGT3_H__
+
+extern int i915_oa_n_builtin_metric_sets_sklgt3;
+
+extern int i915_oa_select_metric_set_sklgt3(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_sklgt3(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_sklgt3(struct drm_i915_private *dev_priv);
+
+#endif
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt4.c
@@ -0,0 +1,260 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#include <linux/sysfs.h>
+
+#include "i915_drv.h"
+#include "i915_oa_sklgt4.h"
+
+enum metric_set_id {
+	METRIC_SET_ID_RENDER_BASIC = 1,
+};
+
+int i915_oa_n_builtin_metric_sets_sklgt4 = 1;
+
+static const struct i915_oa_reg b_counter_config_render_basic[] = {
+	{ _MMIO(0x2710), 0x00000000 },
+	{ _MMIO(0x2714), 0x00800000 },
+	{ _MMIO(0x2720), 0x00000000 },
+	{ _MMIO(0x2724), 0x00800000 },
+	{ _MMIO(0x2740), 0x00000000 },
+};
+
+static const struct i915_oa_reg flex_eu_config_render_basic[] = {
+	{ _MMIO(0xe458), 0x00005004 },
+	{ _MMIO(0xe558), 0x00010003 },
+	{ _MMIO(0xe658), 0x00012011 },
+	{ _MMIO(0xe758), 0x00015014 },
+	{ _MMIO(0xe45c), 0x00051050 },
+	{ _MMIO(0xe55c), 0x00053052 },
+	{ _MMIO(0xe65c), 0x00055054 },
+};
+
+static const struct i915_oa_reg mux_config_render_basic[] = {
+	{ _MMIO(0x9888), 0x166c01e0 },
+	{ _MMIO(0x9888), 0x12170280 },
+	{ _MMIO(0x9888), 0x12370280 },
+	{ _MMIO(0x9888), 0x16ec01e0 },
+	{ _MMIO(0x9888), 0x176c01e0 },
+	{ _MMIO(0x9888), 0x11930317 },
+	{ _MMIO(0x9888), 0x159303df },
+	{ _MMIO(0x9888), 0x3f900003 },
+	{ _MMIO(0x9888), 0x1a4e03b0 },
+	{ _MMIO(0x9888), 0x0a6c0053 },
+	{ _MMIO(0x9888), 0x106c0000 },
+	{ _MMIO(0x9888), 0x1c6c0000 },
+	{ _MMIO(0x9888), 0x0a1b4000 },
+	{ _MMIO(0x9888), 0x1c1c0001 },
+	{ _MMIO(0x9888), 0x002f1000 },
+	{ _MMIO(0x9888), 0x042f1000 },
+	{ _MMIO(0x9888), 0x004c4000 },
+	{ _MMIO(0x9888), 0x0a4ca400 },
+	{ _MMIO(0x9888), 0x0c4c0002 },
+	{ _MMIO(0x9888), 0x000d2000 },
+	{ _MMIO(0x9888), 0x060d8000 },
+	{ _MMIO(0x9888), 0x080da000 },
+	{ _MMIO(0x9888), 0x0a0da000 },
+	{ _MMIO(0x9888), 0x0c0f0400 },
+	{ _MMIO(0x9888), 0x0e0f5600 },
+	{ _MMIO(0x9888), 0x100f0001 },
+	{ _MMIO(0x9888), 0x002c8000 },
+	{ _MMIO(0x9888), 0x162caa00 },
+	{ _MMIO(0x9888), 0x062d8000 },
+	{ _MMIO(0x9888), 0x00133000 },
+	{ _MMIO(0x9888), 0x08133000 },
+	{ _MMIO(0x9888), 0x00170020 },
+	{ _MMIO(0x9888), 0x08170021 },
+	{ _MMIO(0x9888), 0x10170000 },
+	{ _MMIO(0x9888), 0x0633c000 },
+	{ _MMIO(0x9888), 0x06370800 },
+	{ _MMIO(0x9888), 0x10370000 },
+	{ _MMIO(0x9888), 0x1ace0230 },
+	{ _MMIO(0x9888), 0x0aec5300 },
+	{ _MMIO(0x9888), 0x10ec0000 },
+	{ _MMIO(0x9888), 0x1cec0000 },
+	{ _MMIO(0x9888), 0x0a9b8000 },
+	{ _MMIO(0x9888), 0x1c9c0002 },
+	{ _MMIO(0x9888), 0x0acc2000 },
+	{ _MMIO(0x9888), 0x0ccc0002 },
+	{ _MMIO(0x9888), 0x088d8000 },
+	{ _MMIO(0x9888), 0x0a8d8000 },
+	{ _MMIO(0x9888), 0x0e8f1000 },
+	{ _MMIO(0x9888), 0x108f0001 },
+	{ _MMIO(0x9888), 0x16ac8800 },
+	{ _MMIO(0x9888), 0x1b4e0020 },
+	{ _MMIO(0x9888), 0x096c5300 },
+	{ _MMIO(0x9888), 0x116c0000 },
+	{ _MMIO(0x9888), 0x1d6c0000 },
+	{ _MMIO(0x9888), 0x091b8000 },
+	{ _MMIO(0x9888), 0x1b1c8000 },
+	{ _MMIO(0x9888), 0x0b4c2000 },
+	{ _MMIO(0x9888), 0x090d8000 },
+	{ _MMIO(0x9888), 0x0f0f1000 },
+	{ _MMIO(0x9888), 0x172c0800 },
+	{ _MMIO(0x9888), 0x0d933031 },
+	{ _MMIO(0x9888), 0x0f933e3f },
+	{ _MMIO(0x9888), 0x01933d00 },
+	{ _MMIO(0x9888), 0x0393073c },
+	{ _MMIO(0x9888), 0x0593000e },
+	{ _MMIO(0x9888), 0x1d930000 },
+	{ _MMIO(0x9888), 0x19930000 },
+	{ _MMIO(0x9888), 0x1b930000 },
+	{ _MMIO(0x9888), 0x1d900157 },
+	{ _MMIO(0x9888), 0x1f900158 },
+	{ _MMIO(0x9888), 0x35900000 },
+	{ _MMIO(0x9888), 0x2b908000 },
+	{ _MMIO(0x9888), 0x2d908000 },
+	{ _MMIO(0x9888), 0x2f908000 },
+	{ _MMIO(0x9888), 0x31908000 },
+	{ _MMIO(0x9888), 0x15908000 },
+	{ _MMIO(0x9888), 0x17908000 },
+	{ _MMIO(0x9888), 0x19908000 },
+	{ _MMIO(0x9888), 0x1b908000 },
+	{ _MMIO(0x9888), 0x1190003f },
+	{ _MMIO(0x9888), 0x5190ff30 },
+	{ _MMIO(0x9888), 0x41900060 },
+	{ _MMIO(0x9888), 0x55903033 },
+	{ _MMIO(0x9888), 0x45901421 },
+	{ _MMIO(0x9888), 0x47900803 },
+	{ _MMIO(0x9888), 0x5790fff1 },
+	{ _MMIO(0x9888), 0x49900001 },
+	{ _MMIO(0x9888), 0x37900000 },
+	{ _MMIO(0x9888), 0x33900000 },
+	{ _MMIO(0x9888), 0x4b900000 },
+	{ _MMIO(0x9888), 0x5990000f },
+	{ _MMIO(0x9888), 0x43900000 },
+	{ _MMIO(0x9888), 0x5390ffff },
+};
+
+static int
+get_render_basic_mux_config(struct drm_i915_private *dev_priv,
+			    const struct i915_oa_reg **regs,
+			    int *lens)
+{
+	int n = 0;
+
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs) < 1);
+	BUILD_BUG_ON(ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens) < 1);
+
+	regs[n] = mux_config_render_basic;
+	lens[n] = ARRAY_SIZE(mux_config_render_basic);
+	n++;
+
+	return n;
+}
+
+int i915_oa_select_metric_set_sklgt4(struct drm_i915_private *dev_priv)
+{
+	dev_priv->perf.oa.n_mux_configs = 0;
+	dev_priv->perf.oa.b_counter_regs = NULL;
+	dev_priv->perf.oa.b_counter_regs_len = 0;
+	dev_priv->perf.oa.flex_regs = NULL;
+	dev_priv->perf.oa.flex_regs_len = 0;
+
+	switch (dev_priv->perf.oa.metrics_set) {
+	case METRIC_SET_ID_RENDER_BASIC:
+		dev_priv->perf.oa.n_mux_configs =
+			get_render_basic_mux_config(dev_priv,
+						    dev_priv->perf.oa.mux_regs,
+						    dev_priv->perf.oa.mux_regs_lens);
+		if (dev_priv->perf.oa.n_mux_configs == 0) {
+			DRM_DEBUG_DRIVER("No suitable MUX config for \"RENDER_BASIC\" metric set\n");
+
+			/* EINVAL because *_register_sysfs already checked this
+			 * and so it wouldn't have been advertised to userspace and
+			 * so shouldn't have been requested
+			 */
+			return -EINVAL;
+		}
+
+		dev_priv->perf.oa.b_counter_regs =
+			b_counter_config_render_basic;
+		dev_priv->perf.oa.b_counter_regs_len =
+			ARRAY_SIZE(b_counter_config_render_basic);
+
+		dev_priv->perf.oa.flex_regs =
+			flex_eu_config_render_basic;
+		dev_priv->perf.oa.flex_regs_len =
+			ARRAY_SIZE(flex_eu_config_render_basic);
+
+		return 0;
+	default:
+		return -ENODEV;
+	}
+}
+
+static ssize_t
+show_render_basic_id(struct device *kdev, struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", METRIC_SET_ID_RENDER_BASIC);
+}
+
+static struct device_attribute dev_attr_render_basic_id = {
+	.attr = { .name = "id", .mode = 0444 },
+	.show = show_render_basic_id,
+	.store = NULL,
+};
+
+static struct attribute *attrs_render_basic[] = {
+	&dev_attr_render_basic_id.attr,
+	NULL,
+};
+
+static struct attribute_group group_render_basic = {
+	.name = "bad77c24-cc64-480d-99bf-e7b740713800",
+	.attrs =  attrs_render_basic,
+};
+
+int
+i915_perf_register_sysfs_sklgt4(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+	int ret = 0;
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens)) {
+		ret = sysfs_create_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+		if (ret)
+			goto error_render_basic;
+	}
+
+	return 0;
+
+error_render_basic:
+	return ret;
+}
+
+void
+i915_perf_unregister_sysfs_sklgt4(struct drm_i915_private *dev_priv)
+{
+	const struct i915_oa_reg *mux_regs[ARRAY_SIZE(dev_priv->perf.oa.mux_regs)];
+	int mux_lens[ARRAY_SIZE(dev_priv->perf.oa.mux_regs_lens)];
+
+	if (get_render_basic_mux_config(dev_priv, mux_regs, mux_lens))
+		sysfs_remove_group(dev_priv->perf.metrics_kobj, &group_render_basic);
+}
--- /dev/null
+++ b/drivers/gpu/drm/i915/i915_oa_sklgt4.h
@@ -0,0 +1,40 @@
+/*
+ * Autogenerated file by GPU Top : https://github.com/rib/gputop
+ * DO NOT EDIT manually!
+ *
+ *
+ * Copyright (c) 2015 Intel Corporation
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+ * IN THE SOFTWARE.
+ *
+ */
+
+#ifndef __I915_OA_SKLGT4_H__
+#define __I915_OA_SKLGT4_H__
+
+extern int i915_oa_n_builtin_metric_sets_sklgt4;
+
+extern int i915_oa_select_metric_set_sklgt4(struct drm_i915_private *dev_priv);
+
+extern int i915_perf_register_sysfs_sklgt4(struct drm_i915_private *dev_priv);
+
+extern void i915_perf_unregister_sysfs_sklgt4(struct drm_i915_private *dev_priv);
+
+#endif
