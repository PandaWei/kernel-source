From 61b5c1587dd82a8493d7838bb2f9289fd0903364 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Micha=C5=82=20Winiarski?= <michal.winiarski@intel.com>
Date: Wed, 13 Dec 2017 23:13:48 +0100
Subject: [PATCH] drm/i915/guc: Extract guc_init from guc_init_hw
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 61b5c1587dd82a8493d7838bb2f9289fd0903364
Patch-mainline: v4.16-rc1
References: FATE#322643 bsc#1055900

After GPU reset, GuC HW needs to be reinitialized (with FW reload).
Unfortunately, we're doing some extra work there (mostly allocating stuff),
work that can be moved to guc_init and called once at driver load time.

As a side effect we're no longer hitting an assert in
i915_ggtt_enable_guc on suspend/resume.

V2: Do not duplicate disable_communication / reset_guc_interrupts
V3: Add proper teardown after rebase

References: 04f7b24eccdf ("drm/i915/guc: Assert that we switch between known ggtt->invalidate functions")
Signed-off-by: Micha≈Ç Winiarski <michal.winiarski@intel.com>
Cc: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
Cc: Sagar Arun Kamble <sagar.a.kamble@intel.com>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20171213221352.7173-3-michal.winiarski@intel.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/i915_drv.c |    1 
 drivers/gpu/drm/i915/i915_gem.c |    8 +++-
 drivers/gpu/drm/i915/intel_uc.c |   71 +++++++++++++++++++++++++---------------
 drivers/gpu/drm/i915/intel_uc.h |    2 +
 4 files changed, 56 insertions(+), 26 deletions(-)

--- a/drivers/gpu/drm/i915/i915_drv.c
+++ b/drivers/gpu/drm/i915/i915_drv.c
@@ -616,6 +616,7 @@ static void i915_gem_fini(struct drm_i91
 
 	mutex_lock(&dev_priv->drm.struct_mutex);
 	intel_uc_fini_hw(dev_priv);
+	intel_uc_fini(dev_priv);
 	i915_gem_cleanup_engines(dev_priv);
 	i915_gem_contexts_fini(dev_priv);
 	mutex_unlock(&dev_priv->drm.struct_mutex);
--- a/drivers/gpu/drm/i915/i915_gem.c
+++ b/drivers/gpu/drm/i915/i915_gem.c
@@ -5113,10 +5113,14 @@ int i915_gem_init(struct drm_i915_privat
 
 	intel_init_gt_powersave(dev_priv);
 
-	ret = i915_gem_init_hw(dev_priv);
+	ret = intel_uc_init(dev_priv);
 	if (ret)
 		goto err_pm;
 
+	ret = i915_gem_init_hw(dev_priv);
+	if (ret)
+		goto err_uc_init;
+
 	/*
 	 * Despite its name intel_init_clock_gating applies both display
 	 * clock gating workarounds; GT mmio workarounds and the occasional
@@ -5157,6 +5161,8 @@ err_init_hw:
 	i915_gem_wait_for_idle(dev_priv, I915_WAIT_LOCKED);
 	i915_gem_contexts_lost(dev_priv);
 	intel_uc_fini_hw(dev_priv);
+err_uc_init:
+	intel_uc_fini(dev_priv);
 err_pm:
 	if (ret != -EIO) {
 		intel_cleanup_gt_powersave(dev_priv);
--- a/drivers/gpu/drm/i915/intel_uc.c
+++ b/drivers/gpu/drm/i915/intel_uc.c
@@ -214,26 +214,20 @@ void intel_uc_fini_wq(struct drm_i915_pr
 	intel_guc_fini_wq(&dev_priv->guc);
 }
 
-int intel_uc_init_hw(struct drm_i915_private *dev_priv)
+int intel_uc_init(struct drm_i915_private *dev_priv)
 {
 	struct intel_guc *guc = &dev_priv->guc;
-	struct intel_huc *huc = &dev_priv->huc;
-	int ret, attempts;
+	int ret;
 
 	if (!USES_GUC(dev_priv))
 		return 0;
 
-	if (!HAS_GUC(dev_priv)) {
-		ret = -ENODEV;
-		goto err_out;
-	}
-
-	guc_disable_communication(guc);
-	gen9_reset_guc_interrupts(dev_priv);
+	if (!HAS_GUC(dev_priv))
+		return -ENODEV;
 
 	ret = intel_guc_init(guc);
 	if (ret)
-		goto err_out;
+		return ret;
 
 	if (USES_GUC_SUBMISSION(dev_priv)) {
 		/*
@@ -241,10 +235,44 @@ int intel_uc_init_hw(struct drm_i915_pri
 		 * if we are planning to enable submission later
 		 */
 		ret = intel_guc_submission_init(guc);
-		if (ret)
-			goto err_guc;
+		if (ret) {
+			intel_guc_fini(guc);
+			return ret;
+		}
 	}
 
+	return 0;
+}
+
+void intel_uc_fini(struct drm_i915_private *dev_priv)
+{
+	struct intel_guc *guc = &dev_priv->guc;
+
+	if (!USES_GUC(dev_priv))
+		return;
+
+	GEM_BUG_ON(!HAS_GUC(dev_priv));
+
+	if (USES_GUC_SUBMISSION(dev_priv))
+		intel_guc_submission_fini(guc);
+
+	intel_guc_fini(guc);
+}
+
+int intel_uc_init_hw(struct drm_i915_private *dev_priv)
+{
+	struct intel_guc *guc = &dev_priv->guc;
+	struct intel_huc *huc = &dev_priv->huc;
+	int ret, attempts;
+
+	if (!USES_GUC(dev_priv))
+		return 0;
+
+	GEM_BUG_ON(!HAS_GUC(dev_priv));
+
+	guc_disable_communication(guc);
+	gen9_reset_guc_interrupts(dev_priv);
+
 	/* init WOPCM */
 	I915_WRITE(GUC_WOPCM_SIZE, intel_guc_wopcm_size(dev_priv));
 	I915_WRITE(DMA_GUC_WOPCM_OFFSET,
@@ -264,12 +292,12 @@ int intel_uc_init_hw(struct drm_i915_pri
 		 */
 		ret = __intel_uc_reset_hw(dev_priv);
 		if (ret)
-			goto err_submission;
+			goto err_out;
 
 		if (USES_HUC(dev_priv)) {
 			ret = intel_huc_init_hw(huc);
 			if (ret)
-				goto err_submission;
+				goto err_out;
 		}
 
 		intel_guc_init_params(guc);
@@ -322,11 +350,6 @@ err_communication:
 	guc_disable_communication(guc);
 err_log_capture:
 	guc_capture_load_err_log(guc);
-err_submission:
-	if (USES_GUC_SUBMISSION(dev_priv))
-		intel_guc_submission_fini(guc);
-err_guc:
-	intel_guc_fini(guc);
 err_out:
 	/*
 	 * Note that there is no fallback as either user explicitly asked for
@@ -348,15 +371,13 @@ void intel_uc_fini_hw(struct drm_i915_pr
 	if (!USES_GUC(dev_priv))
 		return;
 
+	GEM_BUG_ON(!HAS_GUC(dev_priv));
+
 	if (USES_GUC_SUBMISSION(dev_priv))
 		intel_guc_submission_disable(guc);
 
 	guc_disable_communication(guc);
 
-	if (USES_GUC_SUBMISSION(dev_priv)) {
+	if (USES_GUC_SUBMISSION(dev_priv))
 		gen9_disable_guc_interrupts(dev_priv);
-		intel_guc_submission_fini(guc);
-	}
-
-	intel_guc_fini(guc);
 }
--- a/drivers/gpu/drm/i915/intel_uc.h
+++ b/drivers/gpu/drm/i915/intel_uc.h
@@ -37,6 +37,8 @@ int intel_uc_init_wq(struct drm_i915_pri
 void intel_uc_fini_wq(struct drm_i915_private *dev_priv);
 int intel_uc_init_hw(struct drm_i915_private *dev_priv);
 void intel_uc_fini_hw(struct drm_i915_private *dev_priv);
+int intel_uc_init(struct drm_i915_private *dev_priv);
+void intel_uc_fini(struct drm_i915_private *dev_priv);
 
 static inline bool intel_uc_is_using_guc(void)
 {
