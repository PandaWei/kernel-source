From 19df9a5782f51c900a730dae11e4abf85a0e5ebc Mon Sep 17 00:00:00 2001
From: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Date: Fri, 22 Sep 2017 15:43:04 +0300
Subject: [PATCH] drm/i915: Move execlist initialization into intel_engine_cs.c
Git-commit: 19df9a5782f51c900a730dae11e4abf85a0e5ebc
Patch-mainline: v4.15-rc1
References: FATE#322643 bsc#1055900

Move execlist init into a common engine setup. As it is
common to both guc and hw execlists.

V2: rebase with csb changes
V3: rebase

Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Link: https://patchwork.freedesktop.org/patch/msgid/20170922124307.10914-2-mika.kuoppala@intel.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_engine_cs.c |   30 ++++++++++++++++++++++++++++--
 drivers/gpu/drm/i915/intel_lrc.c       |   19 -------------------
 2 files changed, 28 insertions(+), 21 deletions(-)

--- a/drivers/gpu/drm/i915/intel_engine_cs.c
+++ b/drivers/gpu/drm/i915/intel_engine_cs.c
@@ -385,6 +385,33 @@ static void intel_engine_init_timeline(s
 	engine->timeline = &engine->i915->gt.global_timeline.engine[engine->id];
 }
 
+static bool csb_force_mmio(struct drm_i915_private *i915)
+{
+	/* GVT emulation depends upon intercepting CSB mmio */
+	if (intel_vgpu_active(i915))
+		return true;
+
+	/*
+	 * IOMMU adds unpredictable latency causing the CSB write (from the
+	 * GPU into the HWSP) to only be visible some time after the interrupt
+	 * (missed breadcrumb syndrome).
+	 */
+	if (intel_vtd_active())
+		return true;
+
+	return false;
+}
+
+static void intel_engine_init_execlist(struct intel_engine_cs *engine)
+{
+	struct intel_engine_execlists * const execlists = &engine->execlists;
+
+	execlists->csb_use_mmio = csb_force_mmio(engine->i915);
+
+	execlists->queue = RB_ROOT;
+	execlists->first = NULL;
+}
+
 /**
  * intel_engines_setup_common - setup engine state not requiring hw access
  * @engine: Engine to setup.
@@ -396,8 +423,7 @@ static void intel_engine_init_timeline(s
  */
 void intel_engine_setup_common(struct intel_engine_cs *engine)
 {
-	engine->execlists.queue = RB_ROOT;
-	engine->execlists.first = NULL;
+	intel_engine_init_execlist(engine);
 
 	intel_engine_init_timeline(engine);
 	intel_engine_init_hangcheck(engine);
--- a/drivers/gpu/drm/i915/intel_lrc.c
+++ b/drivers/gpu/drm/i915/intel_lrc.c
@@ -1784,23 +1784,6 @@ logical_ring_default_irqs(struct intel_e
 	engine->irq_keep_mask = GT_CONTEXT_SWITCH_INTERRUPT << shift;
 }
 
-static bool irq_handler_force_mmio(struct drm_i915_private *i915)
-{
-	/* GVT emulation depends upon intercepting CSB mmio */
-	if (intel_vgpu_active(i915))
-		return true;
-
-	/*
-	 * IOMMU adds unpredictable latency causing the CSB write (from the
-	 * GPU into the HWSP) to only be visible some time after the interrupt
-	 * (missed breadcrumb syndrome).
-	 */
-	if (intel_vtd_active())
-		return true;
-
-	return false;
-}
-
 static void
 logical_ring_setup(struct intel_engine_cs *engine)
 {
@@ -1812,8 +1795,6 @@ logical_ring_setup(struct intel_engine_c
 	/* Intentionally left blank. */
 	engine->buffer = NULL;
 
-	engine->execlists.csb_use_mmio = irq_handler_force_mmio(dev_priv);
-
 	fw_domains = intel_uncore_forcewake_for_reg(dev_priv,
 						    RING_ELSP(engine),
 						    FW_REG_WRITE);
