From ff26ffa8ee267dcbd27a5d81cb21d1c41bfdb44a Mon Sep 17 00:00:00 2001
From: Daniel Vetter <daniel.vetter@ffwll.ch>
Date: Wed, 10 May 2017 17:19:32 +0200
Subject: [PATCH] drm/i915: Fix __intel_wait_for_register_fw to not sleep in atomic
Git-commit: ff26ffa8ee267dcbd27a5d81cb21d1c41bfdb44a
Patch-mainline: v4.13-rc1
References: FATE#322643 bsc#1055900

The unconditionally fallback to the blocking wait_for resulted in
impressive fireworks at boot-up on my snb here. Make sure if we set
the slow timeout to 0 that we never ever sleep. The tail of the
callchain was

intel_wait_for_register
-> __intel_wait_for_register_fw
  -> usleep_range
     -> BOOM

It blew up in intel_crt_detect load detection code on the
ADPA_CRT_HOTPLUG_FORCE_TRIGGER in the ADPA register.

V2: Shut up gcc.

V3: Use uninitialized_var() (Chris).

Fixes: 0564654340e2 ("drm/i915: Acquire uncore.lock over intel_uncore_wait_for_register()")
Cc: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Cc: Daniel Vetter <daniel.vetter@intel.com>
Cc: Jani Nikula <jani.nikula@linux.intel.com>
Reviewed-by: Chris Wilson <chris@chris-wilson.co.uk>
Signed-off-by: Daniel Vetter <daniel.vetter@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1494429572-15118-1-git-send-email-daniel.vetter@ffwll.ch
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_uncore.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

--- a/drivers/gpu/drm/i915/intel_uncore.c
+++ b/drivers/gpu/drm/i915/intel_uncore.c
@@ -1610,7 +1610,7 @@ int __intel_wait_for_register_fw(struct
 				 unsigned int slow_timeout_ms,
 				 u32 *out_value)
 {
-	u32 reg_value;
+	u32 uninitialized_var(reg_value);
 #define done (((reg_value = I915_READ_FW(reg)) & mask) == value)
 	int ret;
 
@@ -1621,7 +1621,7 @@ int __intel_wait_for_register_fw(struct
 	ret = -ETIMEDOUT;
 	if (fast_timeout_us && fast_timeout_us <= 20000)
 		ret = _wait_for_atomic(done, fast_timeout_us, 0);
-	if (ret)
+	if (ret && slow_timeout_ms)
 		ret = wait_for(done, slow_timeout_ms);
 
 	if (out_value)
