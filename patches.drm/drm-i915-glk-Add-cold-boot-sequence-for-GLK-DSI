From 8a1deb329ffbdb049f6a475cf535644a81e80b55 Mon Sep 17 00:00:00 2001
From: Madhav Chauhan <madhav.chauhan@intel.com>
Date: Tue, 13 Jun 2017 13:18:15 +0530
Subject: [PATCH] drm/i915/glk: Add cold boot sequence for GLK DSI
Git-commit: 8a1deb329ffbdb049f6a475cf535644a81e80b55
Patch-mainline: v4.13-rc1
References: FATE#322643 bsc#1055900

As per BSEPC, if device ready bit is '0' in enable IO sequence
then its a cold boot/reset scenario eg: S3/S4 resume. If cold boot
scenario detected in enable IO, then prepare port immediately.
In normal boot scenario, prepare port after glk_dsi_device_ready().
Without cold boot sequence enabled, features like S3/S4 doesn't work.

Signed-off-by: Madhav Chauhan <madhav.chauhan@intel.com>
Signed-off-by: Jani Nikula <jani.nikula@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/1497340095-5877-2-git-send-email-madhav.chauhan@intel.com
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_dsi.c |   79 +++++++++++++++++++++++++--------------
 1 file changed, 51 insertions(+), 28 deletions(-)

--- a/drivers/gpu/drm/i915/intel_dsi.c
+++ b/drivers/gpu/drm/i915/intel_dsi.c
@@ -346,12 +346,13 @@ static bool intel_dsi_compute_config(str
 	return true;
 }
 
-static void glk_dsi_enable_io(struct intel_encoder *encoder)
+static bool glk_dsi_enable_io(struct intel_encoder *encoder)
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 	struct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);
 	enum port port;
 	u32 tmp;
+	bool cold_boot = false;
 
 	/* Set the MIPI mode
 	 * If MIPI_Mode is off, then writing to LP_Wake bit is not reflecting.
@@ -370,7 +371,10 @@ static void glk_dsi_enable_io(struct int
 	/* Program LP Wake */
 	for_each_dsi_port(port, intel_dsi->ports) {
 		tmp = I915_READ(MIPI_CTRL(port));
-		tmp |= GLK_LP_WAKE;
+		if (!(I915_READ(MIPI_DEVICE_READY(port)) & DEVICE_READY))
+			tmp &= ~GLK_LP_WAKE;
+		else
+			tmp |= GLK_LP_WAKE;
 		I915_WRITE(MIPI_CTRL(port), tmp);
 	}
 
@@ -381,6 +385,14 @@ static void glk_dsi_enable_io(struct int
 				GLK_MIPIIO_PORT_POWERED, 20))
 			DRM_ERROR("MIPIO port is powergated\n");
 	}
+
+	/* Check for cold boot scenario */
+	for_each_dsi_port(port, intel_dsi->ports) {
+		cold_boot |= !(I915_READ(MIPI_DEVICE_READY(port)) &
+							DEVICE_READY);
+	}
+
+	return cold_boot;
 }
 
 static void glk_dsi_device_ready(struct intel_encoder *encoder)
@@ -410,34 +422,34 @@ static void glk_dsi_device_ready(struct
 			val |= DEVICE_READY;
 			I915_WRITE(MIPI_DEVICE_READY(port), val);
 			usleep_range(10, 15);
-		}
-
-		/* Enter ULPS */
-		val = I915_READ(MIPI_DEVICE_READY(port));
-		val &= ~ULPS_STATE_MASK;
-		val |= (ULPS_STATE_ENTER | DEVICE_READY);
-		I915_WRITE(MIPI_DEVICE_READY(port), val);
+		} else {
+			/* Enter ULPS */
+			val = I915_READ(MIPI_DEVICE_READY(port));
+			val &= ~ULPS_STATE_MASK;
+			val |= (ULPS_STATE_ENTER | DEVICE_READY);
+			I915_WRITE(MIPI_DEVICE_READY(port), val);
 
-		/* Wait for ULPS active */
-		if (intel_wait_for_register(dev_priv,
+			/* Wait for ULPS active */
+			if (intel_wait_for_register(dev_priv,
 				MIPI_CTRL(port), GLK_ULPS_NOT_ACTIVE, 0, 20))
-			DRM_ERROR("ULPS not active\n");
+				DRM_ERROR("ULPS not active\n");
 
-		/* Exit ULPS */
-		val = I915_READ(MIPI_DEVICE_READY(port));
-		val &= ~ULPS_STATE_MASK;
-		val |= (ULPS_STATE_EXIT | DEVICE_READY);
-		I915_WRITE(MIPI_DEVICE_READY(port), val);
+			/* Exit ULPS */
+			val = I915_READ(MIPI_DEVICE_READY(port));
+			val &= ~ULPS_STATE_MASK;
+			val |= (ULPS_STATE_EXIT | DEVICE_READY);
+			I915_WRITE(MIPI_DEVICE_READY(port), val);
 
-		/* Enter Normal Mode */
-		val = I915_READ(MIPI_DEVICE_READY(port));
-		val &= ~ULPS_STATE_MASK;
-		val |= (ULPS_STATE_NORMAL_OPERATION | DEVICE_READY);
-		I915_WRITE(MIPI_DEVICE_READY(port), val);
+			/* Enter Normal Mode */
+			val = I915_READ(MIPI_DEVICE_READY(port));
+			val &= ~ULPS_STATE_MASK;
+			val |= (ULPS_STATE_NORMAL_OPERATION | DEVICE_READY);
+			I915_WRITE(MIPI_DEVICE_READY(port), val);
 
-		val = I915_READ(MIPI_CTRL(port));
-		val &= ~GLK_LP_WAKE;
-		I915_WRITE(MIPI_CTRL(port), val);
+			val = I915_READ(MIPI_CTRL(port));
+			val &= ~GLK_LP_WAKE;
+			I915_WRITE(MIPI_CTRL(port), val);
+		}
 	}
 
 	/* Wait for Stop state */
@@ -778,6 +790,7 @@ static void intel_dsi_pre_enable(struct
 	struct intel_dsi *intel_dsi = enc_to_intel_dsi(&encoder->base);
 	enum port port;
 	u32 val;
+	bool glk_cold_boot = false;
 
 	DRM_DEBUG_KMS("\n");
 
@@ -808,7 +821,8 @@ static void intel_dsi_pre_enable(struct
 		I915_WRITE(DSPCLK_GATE_D, val);
 	}
 
-	intel_dsi_prepare(encoder, pipe_config);
+	if (!IS_GEMINILAKE(dev_priv))
+		intel_dsi_prepare(encoder, pipe_config);
 
 	/* Power on, try both CRC pmic gpio and VBT */
 	if (intel_dsi->gpio_panel)
@@ -819,12 +833,21 @@ static void intel_dsi_pre_enable(struct
 	/* Deassert reset */
 	intel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_DEASSERT_RESET);
 
-	if (IS_GEMINILAKE(dev_priv))
-		glk_dsi_enable_io(encoder);
+	if (IS_GEMINILAKE(dev_priv)) {
+		glk_cold_boot = glk_dsi_enable_io(encoder);
+
+		/* Prepare port in cold boot(s3/s4) scenario */
+		if (glk_cold_boot)
+			intel_dsi_prepare(encoder, pipe_config);
+	}
 
 	/* Put device in ready state (LP-11) */
 	intel_dsi_device_ready(encoder);
 
+	/* Prepare port in normal boot scenario */
+	if (IS_GEMINILAKE(dev_priv) && !glk_cold_boot)
+		intel_dsi_prepare(encoder, pipe_config);
+
 	/* Send initialization commands in LP mode */
 	intel_dsi_vbt_exec_sequence(intel_dsi, MIPI_SEQ_INIT_OTP);
 
