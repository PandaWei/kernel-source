From 624a0ac32d88418a9206d78bddaba26755e213fe Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ville=20Syrj=C3=A4l=C3=A4?= <ville.syrjala@linux.intel.com>
Date: Fri, 21 Apr 2017 21:14:25 +0300
Subject: [PATCH] drm/i915: Fix the g4x watermark TLB miss workaround
Mime-version: 1.0
Content-type: text/plain; charset=UTF-8
Content-transfer-encoding: 8bit
Git-commit: 624a0ac32d88418a9206d78bddaba26755e213fe
Patch-mainline: v4.13-rc1
References: FATE#322643 bsc#1055900

The g4x watermark TLB miss workaround requires that we bump up the
watermark by the difference between 8 full lines and the FIFO size.
Unfortunately the way we compute it at the moment ignores the size
of the pixels. The code also used the primary plane width as the
cursor width when computing the TLB miss w/a for the cursor.
Let's fix both problems.

Signed-off-by: Ville Syrjälä <ville.syrjala@linux.intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20170421181432.15216-9-ville.syrjala@linux.intel.com
Reviewed-by: Maarten Lankhorst <maarten.lankhorst@linux.intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_pm.c |   11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

--- a/drivers/gpu/drm/i915/intel_pm.c
+++ b/drivers/gpu/drm/i915/intel_pm.c
@@ -811,7 +811,7 @@ static bool g4x_compute_wm0(struct drm_i
 	struct intel_crtc *crtc;
 	const struct drm_display_mode *adjusted_mode;
 	const struct drm_framebuffer *fb;
-	int htotal, hdisplay, clock, cpp;
+	int htotal, plane_width, cursor_width, clock, cpp;
 	int line_time_us, line_count;
 	int entries, tlb_miss;
 
@@ -826,12 +826,13 @@ static bool g4x_compute_wm0(struct drm_i
 	fb = crtc->base.primary->state->fb;
 	clock = adjusted_mode->crtc_clock;
 	htotal = adjusted_mode->crtc_htotal;
-	hdisplay = crtc->config->pipe_src_w;
+	plane_width = crtc->config->pipe_src_w;
+	cursor_width = crtc->base.cursor->state->crtc_w;
 	cpp = fb->format->cpp[0];
 
 	/* Use the small buffer method to calculate plane watermark */
 	entries = ((clock * cpp / 1000) * display_latency_ns) / 1000;
-	tlb_miss = display->fifo_size*display->cacheline_size - hdisplay * 8;
+	tlb_miss = display->fifo_size*display->cacheline_size - plane_width * cpp * 8;
 	if (tlb_miss > 0)
 		entries += tlb_miss;
 	entries = DIV_ROUND_UP(entries, display->cacheline_size);
@@ -842,8 +843,8 @@ static bool g4x_compute_wm0(struct drm_i
 	/* Use the large buffer method to calculate cursor watermark */
 	line_time_us = max(htotal * 1000 / clock, 1);
 	line_count = (cursor_latency_ns / line_time_us + 1000) / 1000;
-	entries = line_count * crtc->base.cursor->state->crtc_w * 4;
-	tlb_miss = cursor->fifo_size*cursor->cacheline_size - hdisplay * 8;
+	entries = line_count * cursor_width * 4;
+	tlb_miss = cursor->fifo_size*cursor->cacheline_size - cursor_width * 4 * 8;
 	if (tlb_miss > 0)
 		entries += tlb_miss;
 	entries = DIV_ROUND_UP(entries, cursor->cacheline_size);
