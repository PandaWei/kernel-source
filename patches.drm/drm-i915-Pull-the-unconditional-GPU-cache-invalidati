From 2113184c6f6749f6e4e86a42894f67a50ead6775 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Mon, 20 Nov 2017 10:20:01 +0000
Subject: [PATCH] drm/i915: Pull the unconditional GPU cache invalidation into request construction
Git-commit: 2113184c6f6749f6e4e86a42894f67a50ead6775
Patch-mainline: v4.16-rc1
References: FATE#322643 bsc#1055900

As the request will, in the following patch, implicitly invoke a
context-switch on construction, we should precede that with a GPU TLB
invalidation. Also, even before using GGTT, we always want to invalidate
the TLBs for any updates (as well as the ppgtt invalidates that are
unconditionally applied by execbuf). Since we almost always require the
TLB invalidate, do it unconditionally on request allocation and so we can
remove it from all other paths.

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Link: https://patchwork.freedesktop.org/patch/msgid/20171120102002.22254-1-chris@chris-wilson.co.uk
Reviewed-by: Mika Kuoppala <mika.kuoppala@linux.intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/i915_gem_execbuffer.c        |    7 ------
 drivers/gpu/drm/i915/i915_gem_render_state.c      |    4 ---
 drivers/gpu/drm/i915/i915_gem_request.c           |   24 +++++++++++++++++-----
 drivers/gpu/drm/i915/selftests/i915_gem_context.c |    4 ---
 drivers/gpu/drm/i915/selftests/i915_gem_request.c |   10 ---------
 drivers/gpu/drm/i915/selftests/intel_hangcheck.c  |    4 ---
 6 files changed, 20 insertions(+), 33 deletions(-)

--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c
+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c
@@ -1111,10 +1111,6 @@ static int __reloc_gpu_alloc(struct i915
 	if (err)
 		goto err_request;
 
-	err = eb->engine->emit_flush(rq, EMIT_INVALIDATE);
-	if (err)
-		goto err_request;
-
 	err = i915_switch_context(rq);
 	if (err)
 		goto err_request;
@@ -1818,8 +1814,7 @@ static int eb_move_to_gpu(struct i915_ex
 	/* Unconditionally flush any chipset caches (for streaming writes). */
 	i915_gem_chipset_flush(eb->i915);
 
-	/* Unconditionally invalidate GPU caches and TLBs. */
-	return eb->engine->emit_flush(eb->request, EMIT_INVALIDATE);
+	return 0;
 }
 
 static bool i915_gem_check_execbuffer(struct drm_i915_gem_execbuffer2 *exec)
--- a/drivers/gpu/drm/i915/i915_gem_render_state.c
+++ b/drivers/gpu/drm/i915/i915_gem_render_state.c
@@ -208,10 +208,6 @@ int i915_gem_render_state_emit(struct dr
 	if (err)
 		goto err_unpin;
 
-	err = engine->emit_flush(rq, EMIT_INVALIDATE);
-	if (err)
-		goto err_unpin;
-
 	err = engine->emit_bb_start(rq,
 				    so.batch_offset, so.batch_size,
 				    I915_DISPATCH_SECURE);
--- a/drivers/gpu/drm/i915/i915_gem_request.c
+++ b/drivers/gpu/drm/i915/i915_gem_request.c
@@ -695,17 +695,31 @@ i915_gem_request_alloc(struct intel_engi
 	req->reserved_space = MIN_SPACE_FOR_ADD_REQUEST;
 	GEM_BUG_ON(req->reserved_space < engine->emit_breadcrumb_sz);
 
-	ret = engine->request_alloc(req);
-	if (ret)
-		goto err_ctx;
-
-	/* Record the position of the start of the request so that
+	/*
+	 * Record the position of the start of the request so that
 	 * should we detect the updated seqno part-way through the
 	 * GPU processing the request, we never over-estimate the
 	 * position of the head.
 	 */
 	req->head = req->ring->emit;
 
+	/* Unconditionally invalidate GPU caches and TLBs. */
+	ret = engine->emit_flush(req, EMIT_INVALIDATE);
+	if (ret)
+		goto err_ctx;
+
+	ret = engine->request_alloc(req);
+	if (ret) {
+		/*
+		 * Past the point-of-no-return. Since we may have updated
+		 * global state after partially completing the request alloc,
+		 * we need to commit any commands so far emitted in the
+		 * request to the HW.
+		 */
+		__i915_add_request(req, false);
+		return ERR_PTR(ret);
+	}
+
 	/* Check that we didn't interrupt ourselves with a new request */
 	GEM_BUG_ON(req->timeline->seqno != req->fence.seqno);
 	return req;
--- a/drivers/gpu/drm/i915/selftests/i915_gem_context.c
+++ b/drivers/gpu/drm/i915/selftests/i915_gem_context.c
@@ -158,10 +158,6 @@ static int gpu_fill(struct drm_i915_gem_
 		goto err_batch;
 	}
 
-	err = engine->emit_flush(rq, EMIT_INVALIDATE);
-	if (err)
-		goto err_request;
-
 	err = i915_switch_context(rq);
 	if (err)
 		goto err_request;
--- a/drivers/gpu/drm/i915/selftests/i915_gem_request.c
+++ b/drivers/gpu/drm/i915/selftests/i915_gem_request.c
@@ -459,10 +459,6 @@ empty_request(struct intel_engine_cs *en
 	if (IS_ERR(request))
 		return request;
 
-	err = engine->emit_flush(request, EMIT_INVALIDATE);
-	if (err)
-		goto out_request;
-
 	err = i915_switch_context(request);
 	if (err)
 		goto out_request;
@@ -675,9 +671,6 @@ static int live_all_engines(void *arg)
 			goto out_request;
 		}
 
-		err = engine->emit_flush(request[id], EMIT_INVALIDATE);
-		GEM_BUG_ON(err);
-
 		err = i915_switch_context(request[id]);
 		GEM_BUG_ON(err);
 
@@ -797,9 +790,6 @@ static int live_sequential_engines(void
 			}
 		}
 
-		err = engine->emit_flush(request[id], EMIT_INVALIDATE);
-		GEM_BUG_ON(err);
-
 		err = i915_switch_context(request[id]);
 		GEM_BUG_ON(err);
 
--- a/drivers/gpu/drm/i915/selftests/intel_hangcheck.c
+++ b/drivers/gpu/drm/i915/selftests/intel_hangcheck.c
@@ -114,10 +114,6 @@ static int emit_recurse_batch(struct han
 	if (err)
 		goto unpin_vma;
 
-	err = rq->engine->emit_flush(rq, EMIT_INVALIDATE);
-	if (err)
-		goto unpin_hws;
-
 	err = i915_switch_context(rq);
 	if (err)
 		goto unpin_hws;
