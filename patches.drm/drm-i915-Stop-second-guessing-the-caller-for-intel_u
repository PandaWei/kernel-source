From 84d84cb7e20d3d2c6413c5f75634e88eb68a3f97 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Tue, 11 Apr 2017 12:27:05 +0100
Subject: [PATCH] drm/i915: Stop second guessing the caller for intel_uncore_wait_for_register()
Git-commit: 84d84cb7e20d3d2c6413c5f75634e88eb68a3f97
Patch-mainline: v4.13-rc1
References: FATE#322643 bsc#1055900

Allow the caller to use the fast_timeout_us to specify how long to wait
within the atomic section, rather than transparently switching to a
sleeping loop for larger values. This is required as some callsites may
need a long wait and are in an atomic section.

V2: Reinforce kerneldoc fast_timeout_us limit with a GEM_BUG_ON

Signed-off-by: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Michal Wajdeczko <michal.wajdeczko@intel.com>
Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>
Cc: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Link: http://patchwork.freedesktop.org/patch/msgid/20170411112705.12656-1-chris@chris-wilson.co.uk
Reviewed-by: Tvrtko Ursulin <tvrtko.ursulin@intel.com>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/gpu/drm/i915/intel_uncore.c |   12 +++++++-----
 1 file changed, 7 insertions(+), 5 deletions(-)

--- a/drivers/gpu/drm/i915/intel_uncore.c
+++ b/drivers/gpu/drm/i915/intel_uncore.c
@@ -1601,7 +1601,7 @@ static int gen6_reset_engines(struct drm
  *
  * Otherwise, the wait will timeout after @slow_timeout_ms milliseconds.
  * For atomic context @slow_timeout_ms must be zero and @fast_timeout_us
- * must be not larger than 10 microseconds.
+ * must be not larger than 20,0000 microseconds.
  *
  * Note that this routine assumes the caller holds forcewake asserted, it is
  * not suitable for very long waits. See intel_wait_for_register() if you
@@ -1623,16 +1623,18 @@ int __intel_wait_for_register_fw(struct
 	int ret;
 
 	/* Catch any overuse of this function */
-	might_sleep_if(fast_timeout_us > 10 || slow_timeout_ms);
+	might_sleep_if(slow_timeout_ms);
+	GEM_BUG_ON(fast_timeout_us > 20000);
 
-	if (fast_timeout_us > 10)
-		ret = _wait_for(done, fast_timeout_us, 10);
-	else
+	ret = -ETIMEDOUT;
+	if (fast_timeout_us && fast_timeout_us <= 20000)
 		ret = _wait_for_atomic(done, fast_timeout_us, 0);
 	if (ret)
 		ret = wait_for(done, slow_timeout_ms);
+
 	if (out_value)
 		*out_value = reg_value;
+
 	return ret;
 #undef done
 }
