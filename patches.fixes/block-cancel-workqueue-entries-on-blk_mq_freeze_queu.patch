From: Hannes Reinecke <hare@suse.de>
Date: Thu, 24 May 2018 10:23:46 +0200
Subject: [PATCH] block: cancel workqueue entries on blk_mq_freeze_queue()
References: bsc#1090435
Patch-Mainline: never, SLE12-SP3 specific

blk_mq_freeze_queue() is supposed to stop all ongoing I/O on the
requests. Unfortunately it calls blk_mq_run_hw_queues(), which in
turn might be punted to a workqueue.
As a result we might be having workqueue elements running (and trying
to submit I/O) by the time we're returning from blk_mq_freeze_queue().
This causes all sort of issues later on.

So with this patch we're cancelling any outstanding workqueue items
before returning from blk_mq_freeze_queue(), and restart the queues
once blk_mq_unfreeze_queue() is called.

Signed-off-by: Hannes Reinecke <hare@suse.com>
---
 block/blk-mq.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/block/blk-mq.c b/block/blk-mq.c
index d2d78e1ae688..f6652011964e 100644
--- a/block/blk-mq.c
+++ b/block/blk-mq.c
@@ -75,6 +75,14 @@ EXPORT_SYMBOL_GPL(blk_mq_freeze_queue_start);
 
 void blk_mq_freeze_queue_wait(struct request_queue *q)
 {
+	struct blk_mq_hw_ctx *hctx;
+	unsigned int i;
+
+	queue_for_each_hw_ctx(q, hctx, i) {
+		cancel_work_sync(&hctx->run_work);
+		cancel_delayed_work_sync(&hctx->delay_work);
+		cancel_delayed_work_sync(&hctx->delayed_run_work);
+	}
 	wait_event(q->mq_freeze_wq, percpu_ref_is_zero(&q->q_usage_counter));
 }
 EXPORT_SYMBOL_GPL(blk_mq_freeze_queue_wait);
@@ -124,6 +132,7 @@ void blk_mq_unfreeze_queue(struct request_queue *q)
 	if (!freeze_depth) {
 		percpu_ref_reinit(&q->q_usage_counter);
 		wake_up_all(&q->mq_freeze_wq);
+		blk_mq_run_hw_queues(q, true);
 	}
 }
 EXPORT_SYMBOL_GPL(blk_mq_unfreeze_queue);
-- 
2.12.3

