From 91c76a44a7d1aecf7552438f9eef51c6da1b9837 Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Sat, 26 Aug 2017 07:53:58 +0200
Subject: [PATCH] mm, memory_hotplug: do not back off draining pcp free pages
 from kworker context
Git-commit: 4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435
Patch-mainline: v4.15-rc2
References: bnc#1049591

drain_all_pages backs off when called from a kworker context since
0ccce3b924212 ("mm, page_alloc: drain per-cpu pages from workqueue
context") because the original IPI based pcp draining has been replaced
by a WQ based one and the checked wanted to prevent from recursion and
inter workers dependencies. This has made some sense at the time
because the system WQ has been used and one worker holding the lock
could be blocked while waiting for new workers to emerge which can be a
problem under OOM conditions.

Since then ce612879ddc7 ("mm: move pcp and lru-pcp draining into single
wq") has moved draining to a dedicated (mm_percpu_wq) WQ with a rescuer
so we shouldn't depend on any other WQ activity to make a forward
progress so calling drain_all_pages from a worker context is safe as
long as this doesn't happen from mm_percpu_wq itself which is not the
case because all workers are required to _not_ depend on any MM locks.

Why is this a problem in the first place? ACPI driven memory hot-remove
(acpi_device_hotplug) is executed from the worker context. We end up
calling __offline_pages call to free all the pages and that requires
both lru_add_drain_all_cpuslocked and drain_all_pages to do their job
otherwise we can have dangling pages on pcp lists and fail the offline
operation.

Fix the issue by removing the worker check in drain_all_pages.
lru_add_drain_all_cpuslocked doesn't have this restriction so it works
as expected.

Signed-off-by: Michal Hocko <mhocko@suse.com>

---
 mm/page_alloc.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/mm/page_alloc.c b/mm/page_alloc.c
index af3fc1168156..2135b6ef30ee 100644
--- a/mm/page_alloc.c
+++ b/mm/page_alloc.c
@@ -2477,10 +2477,6 @@ void drain_all_pages(struct zone *zone)
 	if (WARN_ON_ONCE(!mm_percpu_wq))
 		return;
 
-	/* Workqueues cannot recurse */
-	if (current->flags & PF_WQ_WORKER)
-		return;
-
 	/*
 	 * Do not drain if one is already in progress unless it's specific to
 	 * a zone. Such callers are primarily CMA and memory hotplug and need
-- 
2.13.2

