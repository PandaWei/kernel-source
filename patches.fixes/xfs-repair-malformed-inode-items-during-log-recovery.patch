From: Jeff Mahoney <jeffm@suse.com>
Subject: xfs: repair malformed inode items during log recovery
References: bsc#1105396
Patch-mainline: Never, SUSE-specific bugfix

The fix for bsc#1024788 introduced a regression in the form of
malformed inode items.  These items are handled fine by kernels
that have the patch for that issue applied, but once we fix it,
we'll need to handle the malformed items instead of complaining
about inode items being too large.

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/xfs/libxfs/xfs_log_format.h |   55 ++++++++++++++++++++++++++++++++++
 fs/xfs/xfs_log_priv.h          |    3 +
 fs/xfs/xfs_log_recover.c       |   66 ++++++++++++++++++++++++++++++++++-------
 3 files changed, 113 insertions(+), 11 deletions(-)

--- a/fs/xfs/libxfs/xfs_log_format.h
+++ b/fs/xfs/libxfs/xfs_log_format.h
@@ -416,6 +416,61 @@ static inline uint xfs_icdinode_size(int
 	return offsetof(struct xfs_icdinode, di_next_unlinked);
 }
 
+/* This is to compensate for a regression introduced in 3.12.74-60.64.40 */
+struct xfs_icdinode_malformed {
+	__uint16_t	di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
+	__uint16_t	di_mode;	/* mode and type of file */
+	__int8_t	di_version;	/* inode version */
+	__int8_t	di_format;	/* format of di_c data */
+	__uint16_t	di_onlink;	/* old number of links to file */
+	__uint32_t	di_uid;		/* owner's user id */
+	__uint32_t	di_gid;		/* owner's group id */
+	__uint32_t	di_nlink;	/* number of links to file */
+	__uint16_t	di_projid_lo;	/* lower part of owner's project id */
+	__uint16_t	di_projid_hi;	/* higher part of owner's project id */
+	__uint8_t	di_pad[6];	/* unused, zeroed space */
+	__uint16_t	di_flushiter;	/* incremented on flush */
+	xfs_ictimestamp_t di_atime;	/* time last accessed */
+	xfs_ictimestamp_t di_mtime;	/* time last modified */
+	xfs_ictimestamp_t di_ctime;	/* time created/inode modified */
+	xfs_fsize_t	di_size;	/* number of bytes in file */
+	xfs_rfsblock_t	di_nblocks;	/* # of direct & btree blocks used */
+	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */
+	xfs_extnum_t	di_nextents;	/* number of extents in data fork */
+	xfs_aextnum_t	di_anextents;	/* number of extents in attribute fork*/
+	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
+	__int8_t	di_aformat;	/* format of attr fork's data */
+	__uint32_t	di_dmevmask;	/* DMIG event mask */
+	atomic_t	di_dmstate;	/* DMIG state info */
+	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
+	__uint32_t	di_gen;		/* generation number */
+
+	/* di_next_unlinked is the only non-core field in the old dinode */
+	xfs_agino_t	di_next_unlinked;/* agi unlinked list ptr */
+
+	/* start of the extended dinode, writable fields */
+	__uint32_t	di_crc;		/* CRC of the inode */
+	__uint64_t	di_changecount;	/* number of attribute changes */
+	xfs_lsn_t	di_lsn;		/* flush sequence */
+	__uint64_t	di_flags2;	/* more random flags */
+	__uint8_t	di_pad2[16];	/* more padding for future expansion */
+
+	/* fields only written to during inode creation */
+	xfs_ictimestamp_t di_crtime;	/* time created */
+	xfs_ino_t	di_ino;		/* inode number */
+	uuid_t		di_uuid;	/* UUID of the filesystem */
+
+	/* structure must be padded to 64 bit alignment */
+};
+
+static inline uint xfs_icdinode_size_malformed(int version)
+{
+	if (version == 3)
+		return sizeof(struct xfs_icdinode_malformed);
+	return offsetof(struct xfs_icdinode_malformed, di_next_unlinked);
+}
+
+
 /*
  * Buffer Log Format defintions
  *
--- a/fs/xfs/xfs_log_priv.h
+++ b/fs/xfs/xfs_log_priv.h
@@ -416,6 +416,9 @@ struct xlog {
 #endif
 	/* log recovery lsn tracking (for buffer submission */
 	xfs_lsn_t		l_recovery_lsn;
+#ifndef __GENKSYMS__
+	int			l_malformed_inode_warning;
+#endif
 };
 
 #define XLOG_BUF_CANCEL_BUCKET(log, blkno) \
--- a/fs/xfs/xfs_log_recover.c
+++ b/fs/xfs/xfs_log_recover.c
@@ -2945,6 +2945,46 @@ out_free_ip:
 	return error;
 }
 
+/*
+ * SUSE kernels 3.12.74-60.64.40 through 3.12.74-60.64.99 had a regression
+ * where we would write out malformed inode items that would in turn
+ * corrupt inodes.  Handle them gracefully here rather than forcing the
+ * user to zero out their log.
+ */
+STATIC void
+repair_malformed_inode_item(struct xlog *log, xfs_log_iovec_t *vec)
+{
+	struct xfs_icdinode_malformed *mal = vec->i_addr;
+	xfs_icdinode_t *dicp = vec->i_addr;
+	xfs_icdinode_t fixed;
+
+	if (!log->l_malformed_inode_warning) {
+		xfs_info(log->l_mp,
+			 "detected malformed inodes in log, repairing");
+		log->l_malformed_inode_warning = 1;
+	}
+
+	fixed.di_dmstate	= atomic_read(&mal->di_dmstate);
+	fixed.di_flags		= mal->di_flags;
+	fixed.di_gen		= mal->di_gen;
+	fixed.di_next_unlinked	= mal->di_next_unlinked;
+
+	if (dicp->di_version >= 3) {
+		fixed.di_crc		= mal->di_crc;
+		fixed.di_changecount	= mal->di_changecount;
+		fixed.di_lsn		= mal->di_lsn;
+		fixed.di_flags2		= mal->di_flags2;
+		fixed.di_crtime.t_sec	= mal->di_crtime.t_sec;
+		fixed.di_crtime.t_nsec	= mal->di_crtime.t_nsec;
+		fixed.di_ino		= mal->di_ino;
+		memcpy(&fixed.di_pad2, mal->di_pad2, sizeof(fixed.di_pad2));
+		uuid_copy(&fixed.di_uuid, &mal->di_uuid);
+	}
+
+	memcpy(&dicp->di_dmstate, &fixed.di_dmstate,
+	       vec->i_len - offsetof(xfs_icdinode_t, di_dmstate));
+}
+
 STATIC int
 xlog_recover_inode_pass2(
 	struct xlog			*log,
@@ -2963,7 +3003,7 @@ xlog_recover_inode_pass2(
 	int			attr_index;
 	uint			fields;
 	xfs_icdinode_t		*dicp;
-	uint			isize;
+	uint			isize, malformed_isize;
 	int			need_free = 0;
 
 	if (item->ri_buf[0].i_len == sizeof(xfs_inode_log_format_t)) {
@@ -3026,6 +3066,20 @@ xlog_recover_inode_pass2(
 		goto out_release;
 	}
 
+	isize = xfs_icdinode_size(dicp->di_version);
+	malformed_isize = xfs_icdinode_size_malformed(dicp->di_version);
+	if (unlikely(item->ri_buf[1].i_len == malformed_isize)) {
+		repair_malformed_inode_item(log, &item->ri_buf[1]);
+	} else if (unlikely(item->ri_buf[1].i_len > isize)) {
+		XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(7)",
+				     XFS_ERRLEVEL_LOW, mp, dicp);
+		xfs_alert(mp,
+			"%s: Bad inode log record length %d, rec ptr 0x%p",
+			__func__, item->ri_buf[1].i_len, item);
+		error = -EFSCORRUPTED;
+		goto out_release;
+	}
+
 	/*
 	 * If the inode has an LSN in it, recover the inode only if it's less
 	 * than the lsn of the transaction we are replaying. Note: we still
@@ -3118,16 +3172,6 @@ xlog_recover_inode_pass2(
 		error = -EFSCORRUPTED;
 		goto out_release;
 	}
-	isize = xfs_icdinode_size(dicp->di_version);
-	if (unlikely(item->ri_buf[1].i_len > isize)) {
-		XFS_CORRUPTION_ERROR("xlog_recover_inode_pass2(7)",
-				     XFS_ERRLEVEL_LOW, mp, dicp);
-		xfs_alert(mp,
-			"%s: Bad inode log record length %d, rec ptr 0x%p",
-			__func__, item->ri_buf[1].i_len, item);
-		error = -EFSCORRUPTED;
-		goto out_release;
-	}
 
 	/* The core is in in-core format */
 	xfs_dinode_to_disk(dip, dicp);
