From 128227e7fe4087b60f1bd31f762e61237eb23790 Mon Sep 17 00:00:00 2001
From: Matthew Wilcox <mawilcox@microsoft.com>
Date: Thu, 7 Jun 2018 17:05:13 -0700
Subject: [PATCH] slab: __GFP_ZERO is incompatible with a constructor
Git-commit: 128227e7fe4087b60f1bd31f762e61237eb23790
Patch-mainline: 4.18-rc1
References: bnc#1107060

__GFP_ZERO requests that the object be initialised to all-zeroes, while
the purpose of a constructor is to initialise an object to a particular
pattern.  We cannot do both.  Add a warning to catch any users who
mistakenly pass a __GFP_ZERO flag when allocating a slab with a
constructor.

Link: http://lkml.kernel.org/r/20180412191322.GA21205@bombadil.infradead.org
Fixes: d07dbea46405 ("Slab allocators: support __GFP_ZERO in all allocators")
Signed-off-by: Matthew Wilcox <mawilcox@microsoft.com>
Acked-by: Johannes Weiner <hannes@cmpxchg.org>
Acked-by: Vlastimil Babka <vbabka@suse.cz>
Acked-by: Michal Hocko <mhocko@suse.com>
Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

---
 mm/slab.c |    2 ++
 mm/slob.c |    4 +++-
 mm/slub.c |    2 ++
 3 files changed, 7 insertions(+), 1 deletion(-)

--- a/mm/slab.c
+++ b/mm/slab.c
@@ -2597,6 +2597,7 @@ static int cache_grow(struct kmem_cache
 		pr_emerg("gfp: %u\n", flags & GFP_SLAB_BUG_MASK);
 		BUG();
 	}
+	WARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));
 	local_flags = flags & (GFP_CONSTRAINT_MASK|GFP_RECLAIM_MASK);
 
 	/* Take the node list lock to change the colour_next on this node */
@@ -2861,6 +2862,7 @@ static void *cache_alloc_debugcheck_afte
 {
 	struct page *page;
 
+	WARN_ON_ONCE(cachep->ctor && (flags & __GFP_ZERO));
 	if (!objp)
 		return objp;
 	if (cachep->flags & SLAB_POISON) {
--- a/mm/slob.c
+++ b/mm/slob.c
@@ -552,8 +552,10 @@ static void *slob_alloc_node(struct kmem
 					    flags, node);
 	}
 
-	if (b && c->ctor)
+	if (b && c->ctor) {
+		WARN_ON_ONCE(flags & __GFP_ZERO);
 		c->ctor(b);
+	}
 
 	kmemleak_alloc_recursive(b, c->size, 1, c->flags, flags);
 	return b;
--- a/mm/slub.c
+++ b/mm/slub.c
@@ -2260,6 +2260,8 @@ static inline void *new_slab_objects(str
 	struct kmem_cache_cpu *c = *pc;
 	struct page *page;
 
+	WARN_ON_ONCE(s->ctor && (flags & __GFP_ZERO));
+
 	freelist = get_partial(s, flags, node, c);
 
 	if (freelist)
