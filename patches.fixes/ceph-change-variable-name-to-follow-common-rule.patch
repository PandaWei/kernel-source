From: Chengguang Xu <cgxu519@icloud.com>
Date: Wed, 28 Feb 2018 19:43:47 +0800
Subject: ceph: change variable name to follow common rule
Git-commit: 73737682e0598ae73bd4c481e478a0d75884aa8a
Patch-mainline: v4.17-rc1
References: bsc#1089115

Variable name ci is mostly used for ceph_inode_info.
Variable name fi is mostly used for ceph_file_info.
Variable name cf is mostly used for ceph_cap_flush.

Change variable name to follow above common rules
in case of confusing.

Signed-off-by: Chengguang Xu <cgxu519@icloud.com>
Reviewed-by: "Yan, Zheng" <zyan@redhat.com>
Signed-off-by: Ilya Dryomov <idryomov@gmail.com>
Acked-by: Luis Henriques <lhenriques@suse.com>
---
 fs/ceph/addr.c |    4 ++--
 fs/ceph/dir.c  |   18 +++++++++---------
 fs/ceph/file.c |   38 +++++++++++++++++++-------------------
 3 files changed, 30 insertions(+), 30 deletions(-)

--- a/fs/ceph/addr.c
+++ b/fs/ceph/addr.c
@@ -437,7 +437,7 @@ static int ceph_readpages(struct file *f
 {
 	struct inode *inode = file_inode(file);
 	struct ceph_fs_client *fsc = ceph_inode_to_client(inode);
-	struct ceph_file_info *ci = file->private_data;
+	struct ceph_file_info *fi = file->private_data;
 	struct ceph_rw_context *rw_ctx;
 	int rc = 0;
 	int max = 0;
@@ -451,7 +451,7 @@ static int ceph_readpages(struct file *f
 	if (rc == 0)
 		goto out;
 
-	rw_ctx = ceph_find_rw_context(ci);
+	rw_ctx = ceph_find_rw_context(fi);
 	max = fsc->mount_options->rsize >> PAGE_SHIFT;
 	dout("readpages %p file %p ctx %p nr_pages %d max %d\n",
 	     inode, file, rw_ctx, nr_pages, max);
--- a/fs/ceph/dir.c
+++ b/fs/ceph/dir.c
@@ -1351,7 +1351,7 @@ static void ceph_d_prune(struct dentry *
 static ssize_t ceph_read_dir(struct file *file, char __user *buf, size_t size,
 			     loff_t *ppos)
 {
-	struct ceph_file_info *cf = file->private_data;
+	struct ceph_file_info *fi = file->private_data;
 	struct inode *inode = file_inode(file);
 	struct ceph_inode_info *ci = ceph_inode(inode);
 	int left;
@@ -1360,12 +1360,12 @@ static ssize_t ceph_read_dir(struct file
 	if (!ceph_test_mount_opt(ceph_sb_to_client(inode->i_sb), DIRSTAT))
 		return -EISDIR;
 
-	if (!cf->dir_info) {
-		cf->dir_info = kmalloc(bufsize, GFP_KERNEL);
-		if (!cf->dir_info)
+	if (!fi->dir_info) {
+		fi->dir_info = kmalloc(bufsize, GFP_KERNEL);
+		if (!fi->dir_info)
 			return -ENOMEM;
-		cf->dir_info_len =
-			snprintf(cf->dir_info, bufsize,
+		fi->dir_info_len =
+			snprintf(fi->dir_info, bufsize,
 				"entries:   %20lld\n"
 				" files:    %20lld\n"
 				" subdirs:  %20lld\n"
@@ -1385,10 +1385,10 @@ static ssize_t ceph_read_dir(struct file
 				(long)ci->i_rctime.tv_nsec);
 	}
 
-	if (*ppos >= cf->dir_info_len)
+	if (*ppos >= fi->dir_info_len)
 		return 0;
-	size = min_t(unsigned, size, cf->dir_info_len-*ppos);
-	left = copy_to_user(buf, cf->dir_info + *ppos, size);
+	size = min_t(unsigned, size, fi->dir_info_len-*ppos);
+	left = copy_to_user(buf, fi->dir_info + *ppos, size);
 	if (left == size)
 		return -EFAULT;
 	*ppos += (size - left);
--- a/fs/ceph/file.c
+++ b/fs/ceph/file.c
@@ -164,7 +164,7 @@ out:
  */
 static int ceph_init_file(struct inode *inode, struct file *file, int fmode)
 {
-	struct ceph_file_info *cf;
+	struct ceph_file_info *fi;
 	int ret = 0;
 
 	switch (inode->i_mode & S_IFMT) {
@@ -174,19 +174,19 @@ static int ceph_init_file(struct inode *
 	case S_IFDIR:
 		dout("init_file %p %p 0%o (regular)\n", inode, file,
 		     inode->i_mode);
-		cf = kmem_cache_zalloc(ceph_file_cachep, GFP_KERNEL);
-		if (!cf) {
+		fi = kmem_cache_zalloc(ceph_file_cachep, GFP_KERNEL);
+		if (!fi) {
 			ceph_put_fmode(ceph_inode(inode), fmode); /* clean up */
 			return -ENOMEM;
 		}
-		cf->fmode = fmode;
+		fi->fmode = fmode;
 
-		spin_lock_init(&cf->rw_contexts_lock);
-		INIT_LIST_HEAD(&cf->rw_contexts);
+		spin_lock_init(&fi->rw_contexts_lock);
+		INIT_LIST_HEAD(&fi->rw_contexts);
 
-		cf->next_offset = 2;
-		cf->readdir_cache_idx = -1;
-		file->private_data = cf;
+		fi->next_offset = 2;
+		fi->readdir_cache_idx = -1;
+		file->private_data = fi;
 		BUG_ON(inode->i_fop->release != ceph_release);
 		break;
 
@@ -277,11 +277,11 @@ int ceph_open(struct inode *inode, struc
 	struct ceph_fs_client *fsc = ceph_sb_to_client(inode->i_sb);
 	struct ceph_mds_client *mdsc = fsc->mdsc;
 	struct ceph_mds_request *req;
-	struct ceph_file_info *cf = file->private_data;
+	struct ceph_file_info *fi = file->private_data;
 	int err;
 	int flags, fmode, wanted;
 
-	if (cf) {
+	if (fi) {
 		dout("open file %p is already opened\n", file);
 		return 0;
 	}
@@ -459,16 +459,16 @@ out_acl:
 int ceph_release(struct inode *inode, struct file *file)
 {
 	struct ceph_inode_info *ci = ceph_inode(inode);
-	struct ceph_file_info *cf = file->private_data;
+	struct ceph_file_info *fi = file->private_data;
 
 	dout("release inode %p file %p\n", inode, file);
-	ceph_put_fmode(ci, cf->fmode);
-	if (cf->last_readdir)
-		ceph_mdsc_put_request(cf->last_readdir);
-	kfree(cf->last_name);
-	kfree(cf->dir_info);
-	WARN_ON(!list_empty(&cf->rw_contexts));
-	kmem_cache_free(ceph_file_cachep, cf);
+	ceph_put_fmode(ci, fi->fmode);
+	if (fi->last_readdir)
+		ceph_mdsc_put_request(fi->last_readdir);
+	kfree(fi->last_name);
+	kfree(fi->dir_info);
+	WARN_ON(!list_empty(&fi->rw_contexts));
+	kmem_cache_free(ceph_file_cachep, fi);
 
 	/* wake up anyone waiting for caps on this inode */
 	wake_up_all(&ci->i_cap_wq);
