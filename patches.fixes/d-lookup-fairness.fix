From: NeilBrown <neilb@suse.com>
Subject: Improve fairness when locking the per-superblock s_anon list
Patch-mainline: Not yet, will submit soon
References: bsc#957525, bsc#941363

bit-spin-locks, as used for dcache hash chains, are not fair.
This is not a problem for the dcache hash table as different CPUs are
likely to access different entries in the hash table so high contention
is no expected.
However anonymous dentryies (created by NFSD) all live on a single hash
chain "s_anon" and the bitlock on this can be highly contended, resulting
in soft-lockup warnings.

So introduce a global (fair) spinlock and take it before grabing the
bitlock on s_anon.  This provides fairness and makes the warnings go away.

Having a per-superblock spinlock would be preferred, but there aren't any.

Signed-off-by: NeilBrown <neilb@suse.com>

---
 fs/dcache.c |    8 ++++++++
 1 file changed, 8 insertions(+)

--- a/fs/dcache.c
+++ b/fs/dcache.c
@@ -112,6 +112,8 @@ static inline struct hlist_bl_head *d_ha
 #define IN_LOOKUP_SHIFT 10
 static struct hlist_bl_head in_lookup_hashtable[1 << IN_LOOKUP_SHIFT];
 
+static DEFINE_SPINLOCK(s_anon_lock);
+
 static inline struct hlist_bl_head *in_lookup_hash(const struct dentry *parent,
 					unsigned int hash)
 {
@@ -479,9 +481,13 @@ static void ___d_drop(struct dentry *den
 		else
 			b = d_hash(dentry->d_name.hash);
 
+		if (b == &dentry->d_sb->s_anon)
+			spin_lock(&s_anon_lock);
 		hlist_bl_lock(b);
 		__hlist_bl_del(&dentry->d_hash);
 		hlist_bl_unlock(b);
+		if (b == &dentry->d_sb->s_anon)
+			spin_unlock(&s_anon_lock);
 		/* After this call, in-progress rcu-walk path lookup will fail. */
 		write_seqcount_invalidate(&dentry->d_seq);
 	}
@@ -2000,9 +2006,11 @@ static struct dentry *__d_obtain_alias(s
 	spin_lock(&tmp->d_lock);
 	__d_set_inode_and_type(tmp, inode, add_flags);
 	hlist_add_head(&tmp->d_u.d_alias, &inode->i_dentry);
+	spin_lock(&s_anon_lock);
 	hlist_bl_lock(&tmp->d_sb->s_anon);
 	hlist_bl_add_head(&tmp->d_hash, &tmp->d_sb->s_anon);
 	hlist_bl_unlock(&tmp->d_sb->s_anon);
+	spin_unlock(&s_anon_lock);
 	spin_unlock(&tmp->d_lock);
 	spin_unlock(&inode->i_lock);
 
