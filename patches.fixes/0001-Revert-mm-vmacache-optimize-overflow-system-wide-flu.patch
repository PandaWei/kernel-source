From 423b12e3fa7445a093625e46a845bae1c6704fb1 Mon Sep 17 00:00:00 2001
From: Davidlohr Bueso <dave@stgolabs.net>
Date: Wed, 26 Sep 2018 13:59:11 -0700
Subject: [PATCH] Revert "mm,vmacache: optimize overflow system-wide flushing"
Patch-mainline: Never, SLE specific
References: bsc#1108399 CVE-2018-17182

This reverts:

   6b4ebc3a9078 (mm,vmacache: optimize overflow system-wide flushing)

Due to kabi constraints, this fix is a SLE-specific change,
which is equivalent to upstream's approach:

   7a9cdebdcc17 (mm: get rid of vmacache_flush_all() entirely)

By deleting/disabling the "fastpath" (which isn't even fast as this is
rarely run code paths) we deal with the security flaw. The sequence
counter remains 32bits.

Signed-off-by: Davidlohr Bueso <dbueso@suse.de>

---
 mm/vmacache.c | 10 ----------
 1 file changed, 10 deletions(-)

diff --git a/mm/vmacache.c b/mm/vmacache.c
index fd09dc9c6812..42476fe60df5 100644
--- a/mm/vmacache.c
+++ b/mm/vmacache.c
@@ -19,16 +19,6 @@ void vmacache_flush_all(struct mm_struct *mm)
 
 	count_vm_vmacache_event(VMACACHE_FULL_FLUSHES);
 
-	/*
-	 * Single threaded tasks need not iterate the entire
-	 * list of process. We can avoid the flushing as well
-	 * since the mm's seqnum was increased and don't have
-	 * to worry about other threads' seqnum. Current's
-	 * flush will occur upon the next lookup.
-	 */
-	if (atomic_read(&mm->mm_users) == 1)
-		return;
-
 	rcu_read_lock();
 	for_each_process_thread(g, p) {
 		/*
-- 
2.16.4

