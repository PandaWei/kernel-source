From 22076557b07c12086eeb16b8ce2b0b735f7a27e7 Mon Sep 17 00:00:00 2001
From: "Shuah Khan (Samsung OSG)" <shuah@kernel.org>
Date: Mon, 14 May 2018 20:49:58 -0600
Subject: [PATCH] usbip: usbip_host: fix NULL-ptr deref and use-after-free
 errors
Git-commit: 22076557b07c12086eeb16b8ce2b0b735f7a27e7
Patch-mainline: v4.17
References: bsc#1096480

usbip_host updates device status without holding lock from stub probe,
disconnect and rebind code paths. When multiple requests to import a
device are received, these unprotected code paths step all over each
other and drive fails with NULL-ptr deref and use-after-free errors.

The driver uses a table lock to protect the busid array for adding and
deleting busids to the table. However, the probe, disconnect and rebind
paths get the busid table entry and update the status without holding
the busid table lock. Add a new finer grain lock to protect the busid
entry. This new lock will be held to search and update the busid entry
fields from get_busid_idx(), add_match_busid() and del_match_busid().

match_busid_show() does the same to access the busid entry fields.

get_busid_priv() changed to return the pointer to the busid entry holding
the busid lock. stub_probe(), stub_disconnect() and stub_device_rebind()
call put_busid_priv() to release the busid lock before returning. This
changes fixes the unprotected code paths eliminating the race conditions
in updating the busid entries.

Reported-by: Jakub Jirasek
Signed-off-by: Shuah Khan (Samsung OSG) <shuah@kernel.org>
Cc: stable <stable@kernel.org>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Signed-off-by: Oliver Neukum <oneukum@suse.com>
---
 drivers/staging/usbip/stub.h      |    2 +
 drivers/staging/usbip/stub_dev.c  |   36 +++++++++++++++++++---------
 drivers/staging/usbip/stub_main.c |   48 ++++++++++++++++++++++++++++----------
 3 files changed, 63 insertions(+), 23 deletions(-)

--- a/drivers/staging/usbip/stub.h
+++ b/drivers/staging/usbip/stub.h
@@ -83,6 +83,7 @@ struct bus_id_priv {
 	int interf_count;
 	struct stub_device *sdev;
 	char shutdown_busid;
+	spinlock_t busid_lock;
 };
 
 /* stub_priv is allocated from stub_priv_cache */
@@ -93,6 +94,7 @@ extern struct usb_driver stub_driver;
 
 /* stub_main.c */
 struct bus_id_priv *get_busid_priv(const char *busid);
+void put_busid_priv(struct bus_id_priv *bid);
 int del_match_busid(char *busid);
 void stub_device_cleanup_urbs(struct stub_device *sdev);
 
--- a/drivers/staging/usbip/stub_dev.c
+++ b/drivers/staging/usbip/stub_dev.c
@@ -374,6 +374,7 @@ static int stub_probe(struct usb_interfa
 	const char *udev_busid = dev_name(interface->dev.parent);
 	int err = 0;
 	struct bus_id_priv *busid_priv;
+	int rc = 0;
 
 	dev_dbg(&interface->dev, "Enter\n");
 
@@ -389,25 +390,30 @@ static int stub_probe(struct usb_interfa
 		 * other matched drivers by the driver core.
 		 * See driver_probe_device() in driver/base/dd.c
 		 */
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	if (udev->descriptor.bDeviceClass == USB_CLASS_HUB) {
 		dev_dbg(&udev->dev, "%s is a usb hub device... skip!\n",
 			 udev_busid);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	if (!strcmp(udev->bus->bus_name, "vhci_hcd")) {
 		dev_dbg(&udev->dev, "%s is attached on vhci_hcd... skip!\n",
 			 udev_busid);
-		return -ENODEV;
+		rc = -ENODEV;
+		goto call_put_busid_priv;
 	}
 
 	if (busid_priv->status == STUB_BUSID_ALLOC) {
 		sdev = busid_priv->sdev;
-		if (!sdev)
-			return -ENODEV;
+		if (!sdev) {
+			rc = -ENODEV;
+			goto call_put_busid_priv;
+		}
 
 		busid_priv->interf_count++;
 		dev_info(&interface->dev, "usbip-host: register new interface "
@@ -425,17 +431,21 @@ static int stub_probe(struct usb_interfa
 			usb_set_intfdata(interface, NULL);
 			busid_priv->interf_count--;
 
-			return err;
+			rc = err;
+			goto call_put_busid_priv;
 		}
 
 		usb_get_intf(interface);
-		return 0;
+		rc = 0;
+		goto call_put_busid_priv;
 	}
 
 	/* ok. this is my device. */
 	sdev = stub_device_alloc(udev, interface);
-	if (!sdev)
-		return -ENOMEM;
+	if (!sdev) {
+		rc = -ENOMEM;
+		goto call_put_busid_priv;
+	}
 
 	dev_info(&interface->dev, "usbip-host: register new device "
 		 "(bus %u dev %u ifn %u)\n", udev->bus->busnum, udev->devnum,
@@ -460,11 +470,15 @@ static int stub_probe(struct usb_interfa
 
 		busid_priv->sdev = NULL;
 		stub_device_free(sdev);
-		return err;
+		rc =  err;
+		goto call_put_busid_priv;
 	}
 	busid_priv->status = STUB_BUSID_ALLOC;
 
-	return 0;
+	rc = 0;
+
+call_put_busid_priv:
+	put_busid_priv(busid_priv);
 }
 
 static void shutdown_busid(struct bus_id_priv *busid_priv)
--- a/drivers/staging/usbip/stub_main.c
+++ b/drivers/staging/usbip/stub_main.c
@@ -46,12 +46,16 @@ static int get_busid_idx(const char *bus
 	int i;
 	int idx = -1;
 
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (busid_table[i].name[0])
 			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
 				idx = i;
+				spin_unlock(&busid_table[i].busid_lock);
 				break;
 			}
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 
 	return idx;
 }
@@ -63,8 +67,11 @@ struct bus_id_priv *get_busid_priv(const
 
 	spin_lock(&busid_table_lock);
 	idx = get_busid_idx(busid);
-	if (idx >= 0)
+	if (idx >= 0) {
 		bid = &(busid_table[idx]);
+		/* get busid_lock before returning */
+		spin_lock(&bid->busid_lock);
+	}
 	spin_unlock(&busid_table_lock);
 
 	return bid;
@@ -77,10 +84,12 @@ static ssize_t show_match_busid(struct d
 
 	spin_lock(&busid_table_lock);
 
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (busid_table[i].name[0])
 			out += sprintf(out, "%s ", busid_table[i].name);
-
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 	spin_unlock(&busid_table_lock);
 	out += sprintf(out, "\n");
 
@@ -88,6 +97,11 @@ static ssize_t show_match_busid(struct d
 	return out - buf;
 }
 
+void put_busid_priv(struct bus_id_priv *bid)
+{
+	spin_unlock(&bid->busid_lock);
+}
+
 static int add_match_busid(char *busid)
 {
 	int i;
@@ -100,15 +114,19 @@ static int add_match_busid(char *busid)
 		goto out;
 	}
 
-	for (i = 0; i < MAX_BUSID; i++)
+	for (i = 0; i < MAX_BUSID; i++) {
+		spin_lock(&busid_table[i].busid_lock);
 		if (!busid_table[i].name[0]) {
 			strncpy(busid_table[i].name, busid, BUSID_SIZE);
 			if ((busid_table[i].status != STUB_BUSID_ALLOC) &&
 			    (busid_table[i].status != STUB_BUSID_REMOV))
 				busid_table[i].status = STUB_BUSID_ADDED;
 			ret = 0;
+			spin_unlock(&busid_table[i].busid_lock);
 			break;
 		}
+		spin_unlock(&busid_table[i].busid_lock);
+	}
 
 out:
 	spin_unlock(&busid_table_lock);
@@ -118,7 +136,7 @@ out:
 
 int del_match_busid(char *busid)
 {
-	int i;
+	int idx;
 	int ret = -1;
 
 	spin_lock(&busid_table_lock);
@@ -129,19 +147,22 @@ int del_match_busid(char *busid)
 	/* found */
 	ret = 0;
 
+	spin_lock(&busid_table[idx].busid_lock);
+
 	if (busid_table[idx].status == STUB_BUSID_OTHER)
 		memset(busid_table[idx].name, 0, BUSID_SIZE);
 
 	if ((busid_table[idx].status != STUB_BUSID_OTHER) &&
 	    (busid_table[idx].status != STUB_BUSID_ADDED))
 		busid_table[idx].status = STUB_BUSID_REMOV;
+	spin_unlock(&busid_table[idx].busid_lock);
 out:
 	spin_unlock(&busid_table_lock);
 
 	return -1;
 }
 
-static void init_busid_table(void)
+void init_busid_table(void)
 {
 	int i;
 
@@ -154,9 +175,12 @@ static void init_busid_table(void)
 	}
 
 	spin_lock_init(&busid_table_lock);
+
+	for (i = 0; i < MAX_BUSID; i++)
+		spin_lock_init(&busid_table[i].busid_lock);
 }
 
-static ssize_t store_match_busid(struct device_driver *dev, const char *buf,
+ssize_t store_match_busid(struct device_driver *dev, const char *buf,
 				 size_t count)
 {
 	int len;
@@ -195,7 +219,7 @@ static ssize_t store_match_busid(struct
 static DRIVER_ATTR(match_busid, S_IRUSR | S_IWUSR, show_match_busid,
 		   store_match_busid);
 
-static struct stub_priv *stub_priv_pop_from_listhead(struct list_head *listhead)
+struct stub_priv *stub_priv_pop_from_listhead(struct list_head *listhead)
 {
 	struct stub_priv *priv, *tmp;
 
@@ -207,7 +231,7 @@ static struct stub_priv *stub_priv_pop_f
 	return NULL;
 }
 
-static struct stub_priv *stub_priv_pop(struct stub_device *sdev)
+struct stub_priv *stub_priv_pop(struct stub_device *sdev)
 {
 	unsigned long flags;
 	struct stub_priv *priv;
@@ -250,7 +274,7 @@ void stub_device_cleanup_urbs(struct stu
 	}
 }
 
-static int __init usb_stub_init(void)
+static int usb_stub_init(void)
 {
 	int ret;
 
@@ -286,7 +310,7 @@ err_usb_register:
 	return ret;
 }
 
-static void __exit usb_stub_exit(void)
+static void usb_stub_exit(void)
 {
 	driver_remove_file(&stub_driver.drvwrap.driver,
 			   &driver_attr_match_busid);
