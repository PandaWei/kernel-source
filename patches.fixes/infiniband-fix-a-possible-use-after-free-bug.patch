From: Cong Wang <xiyou.wangcong@gmail.com>
Date: Fri, 1 Jun 2018 11:31:44 -0700
Subject: infiniband: fix a possible use-after-free bug
Patch-mainline: v4.18-rc1
Git-commit: cb2595c1393b4a5211534e6f0a0fbad369e21ad8
References: bsc#1103119 CVE-2018-14734

ucma_process_join() will free the new allocated "mc" struct,
if there is any error after that, especially the copy_to_user().

But in parallel, ucma_leave_multicast() could find this "mc"
through idr_find() before ucma_process_join() frees it, since it
is already published.

So "mc" could be used in ucma_leave_multicast() after it is been
allocated and freed in ucma_process_join(), since we don't refcnt
it.

Fix this by separating "publish" from ID allocation, so that we
can get an ID first and publish it later after copy_to_user().

Fixes: c8f6a362bf3e ("RDMA/cma: Add multicast communication support")
Reported-by: Noam Rathaus <noamr@beyondsecurity.com>
Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
Signed-off-by: Jason Gunthorpe <jgg@mellanox.com>
Acked-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
---
 drivers/infiniband/core/ucma.c |    6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

--- a/drivers/infiniband/core/ucma.c
+++ b/drivers/infiniband/core/ucma.c
@@ -198,7 +198,7 @@ static struct ucma_multicast* ucma_alloc
 			goto error;
 
 		mutex_lock(&mut);
-		ret = idr_get_new(&multicast_idr, mc, &mc->id);
+		ret = idr_get_new(&multicast_idr, NULL, &mc->id);
 		mutex_unlock(&mut);
 	} while (ret == -EAGAIN);
 
@@ -1076,6 +1076,10 @@ static ssize_t ucma_join_multicast(struc
 		goto err3;
 	}
 
+	mutex_lock(&mut);
+	idr_replace(&multicast_idr, mc, mc->id);
+	mutex_unlock(&mut);
+
 	mutex_unlock(&file->mut);
 	ucma_put_ctx(ctx);
 	return 0;
