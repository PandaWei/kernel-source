From 0c793cd39635ee0f475823df20729f6f84dd4fdc Mon Sep 17 00:00:00 2001
From: Christoph Hellwig <hch@lst.de>
Date: Thu, 19 Oct 2017 11:07:10 -0700
Subject: [PATCH 51/90] xfs: remove XFS_BMAP_MAX_SHIFT_EXTENTS
Git-commit: 6b18af0dfd1695c1d53a2eeead838a90c27b7cb4                            
Patch-mainline: v4.15-rc1                                                       
References: bsc#1095344

The define was always set to 1, which means looping until we reach is
was dead code from the start.

Also remove an initialization of next_fsb for the done case that doesn't
fit the new code flow - it was never checked by the caller in the done
case to start with.

Signed-off-by: Christoph Hellwig <hch@lst.de>
Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
Signed-off-by: Darrick J. Wong <darrick.wong@oracle.com>
Acked-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/xfs/libxfs/xfs_bmap.c | 47 ++++++++++++++++++++---------------------------
 fs/xfs/libxfs/xfs_bmap.h | 18 ++++++++++--------
 fs/xfs/xfs_bmap_util.c   | 12 ++----------
 3 files changed, 32 insertions(+), 45 deletions(-)

diff --git a/fs/xfs/libxfs/xfs_bmap.c b/fs/xfs/libxfs/xfs_bmap.c
index 765c4082cd68..5477daa939b9 100644
--- a/fs/xfs/libxfs/xfs_bmap.c
+++ b/fs/xfs/libxfs/xfs_bmap.c
@@ -5547,8 +5547,7 @@ xfs_bmse_shift_one(
 /*
  * Shift extent records to the left/right to cover/create a hole.
  *
- * The maximum number of extents to be shifted in a single operation is
- * @num_exts. @stop_fsb specifies the file offset at which to stop shift and the
+ * @stop_fsb specifies the file offset at which to stop shift and the
  * file offset where we've left off is returned in @next_fsb. @offset_shift_fsb
  * is the length by which each extent is shifted. If there is no hole to shift
  * the extents into, this will be considered invalid operation and we abort
@@ -5564,14 +5563,12 @@ xfs_bmap_shift_extents(
 	xfs_fileoff_t		stop_fsb,
 	xfs_fsblock_t		*firstblock,
 	struct xfs_bmap_free	*flist,
-	enum shift_direction	direction,
-	int			num_exts)
+	enum shift_direction	direction)
 {
 	struct xfs_btree_cur		*cur = NULL;
 	struct xfs_bmbt_irec            got;
 	struct xfs_mount		*mp = ip->i_mount;
 	struct xfs_ifork		*ifp;
-	xfs_extnum_t			nexts = 0;
 	xfs_extnum_t			current_ext;
 	xfs_extnum_t			total_extents;
 	xfs_extnum_t			stop_extent;
@@ -5669,31 +5666,27 @@ xfs_bmap_shift_extents(
 		}
 	}
 
-	while (nexts++ < num_exts) {
-		error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
-					   &current_ext, &got, cur, &logflags,
-					   direction);
-		if (error)
-			goto del_cursor;
-		/*
-		 * If there was an extent merge during the shift, the extent
-		 * count can change. Update the total and grade the next record.
-		 */
-		if (direction == SHIFT_LEFT) {
-			total_extents = xfs_iext_count(ifp);
-			stop_extent = total_extents;
-		}
+	error = xfs_bmse_shift_one(ip, whichfork, offset_shift_fsb,
+				   &current_ext, &got, cur, &logflags,
+				   direction);
+	if (error)
+		goto del_cursor;
+	/*
+	 * If there was an extent merge during the shift, the extent
+	 * count can change. Update the total and grade the next record.
+	 */
+	if (direction == SHIFT_LEFT) {
+		total_extents = xfs_iext_count(ifp);
+		stop_extent = total_extents;
+	}
 
-		if (current_ext == stop_extent) {
-			*done = 1;
-			*next_fsb = NULLFSBLOCK;
-			break;
-		}
-		xfs_iext_get_extent(ifp, current_ext, &got);
+	if (current_ext == stop_extent) {
+		*done = 1;
+		goto del_cursor;
 	}
+	xfs_iext_get_extent(ifp, current_ext, &got);
 
-	if (!*done)
-		*next_fsb = got.br_startoff;
+	*next_fsb = got.br_startoff;
 
 del_cursor:
 	if (cur)
diff --git a/fs/xfs/libxfs/xfs_bmap.h b/fs/xfs/libxfs/xfs_bmap.h
index 546526a34adc..c5982f2dcdf3 100644
--- a/fs/xfs/libxfs/xfs_bmap.h
+++ b/fs/xfs/libxfs/xfs_bmap.h
@@ -167,13 +167,16 @@ static inline void xfs_bmap_init(xfs_bmap_free_t *flp, xfs_fsblock_t *fbp)
 
 
 /*
- * This macro is used to determine how many extents will be shifted
- * in one write transaction. We could require two splits,
- * an extent move on the first and an extent merge on the second,
- * So it is proper that one extent is shifted inside write transaction
- * at a time.
+ * Return true if the extent is a real, allocated extent, or false if it is  a
+ * delayed allocation, and unwritten extent or a hole.
  */
-#define XFS_BMAP_MAX_SHIFT_EXTENTS	1
+static inline bool xfs_bmap_is_real_extent(struct xfs_bmbt_irec *irec)
+{
+	return irec->br_state != XFS_EXT_UNWRITTEN &&
+		irec->br_startblock != HOLESTARTBLOCK &&
+		irec->br_startblock != DELAYSTARTBLOCK &&
+		!isnullstartblock(irec->br_startblock);
+}
 
 enum shift_direction {
 	SHIFT_LEFT = 0,
@@ -223,8 +226,7 @@ uint	xfs_default_attroffset(struct xfs_inode *ip);
 int	xfs_bmap_shift_extents(struct xfs_trans *tp, struct xfs_inode *ip,
 		xfs_fileoff_t *next_fsb, xfs_fileoff_t offset_shift_fsb,
 		int *done, xfs_fileoff_t stop_fsb, xfs_fsblock_t *firstblock,
-		struct xfs_bmap_free *flist, enum shift_direction direction,
-		int num_exts);
+		struct xfs_bmap_free *flist, enum shift_direction direction);
 int	xfs_bmap_split_extent(struct xfs_inode *ip, xfs_fileoff_t split_offset);
 
 static inline int xfs_bmap_fork_to_state(int whichfork)
diff --git a/fs/xfs/xfs_bmap_util.c b/fs/xfs/xfs_bmap_util.c
index 76413922219c..01075454fbf0 100644
--- a/fs/xfs/xfs_bmap_util.c
+++ b/fs/xfs/xfs_bmap_util.c
@@ -1525,13 +1525,9 @@ xfs_collapse_file_space(
 
 		xfs_bmap_init(&free_list, &first_block);
 
-		/*
-		 * We are using the write transaction in which max 2 bmbt
-		 * updates are allowed
-		 */
 		error = xfs_bmap_shift_extents(tp, ip, &next_fsb, shift_fsb,
 				&done, stop_fsb, &first_block, &free_list,
-				SHIFT_LEFT, XFS_BMAP_MAX_SHIFT_EXTENTS);
+				SHIFT_LEFT);
 		if (error)
 			goto out_bmap_cancel;
 
@@ -1607,13 +1603,9 @@ xfs_insert_file_space(
 		xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);
 		xfs_bmap_init(&free_list, &first_block);
 
-		/*
-		 * We are using the write transaction in which max 2 bmbt
-		 * updates are allowed
-		 */
 		error = xfs_bmap_shift_extents(tp, ip, &next_fsb, shift_fsb,
 				&done, stop_fsb, &first_block, &free_list,
-				SHIFT_RIGHT, XFS_BMAP_MAX_SHIFT_EXTENTS);
+				SHIFT_RIGHT);
 		if (error)
 			goto out_bmap_cancel;
 
-- 
2.7.4

