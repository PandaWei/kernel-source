From ae6da1f503abb5a5081f9f6c4a6881de97830f3e Mon Sep 17 00:00:00 2001
From: Eric Dumazet <edumazet@google.com>
Date: Sat, 31 Mar 2018 12:58:48 -0700
Subject: [PATCH] rhashtable: add schedule points
Git-commit: ae6da1f503abb5a5081f9f6c4a6881de97830f3e
Patch-mainline: v4.17-rc1
References: bsc#1051510

Rehashing and destroying large hash table takes a lot of time,
and happens in process context. It is safe to add cond_resched()
in rhashtable_rehash_table() and rhashtable_free_and_destroy()

Signed-off-by: Eric Dumazet <edumazet@google.com>
Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
Signed-off-by: David S. Miller <davem@davemloft.net>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 lib/rhashtable.c |    2 ++
 1 file changed, 2 insertions(+)

--- a/lib/rhashtable.c
+++ b/lib/rhashtable.c
@@ -365,6 +365,7 @@ static int rhashtable_rehash_table(struc
 		err = rhashtable_rehash_chain(ht, old_hash);
 		if (err)
 			return err;
+		cond_resched();
 	}
 
 	/* Publish the new table pointer. */
@@ -1073,6 +1074,7 @@ void rhashtable_free_and_destroy(struct
 		for (i = 0; i < tbl->size; i++) {
 			struct rhash_head *pos, *next;
 
+			cond_resched();
 			for (pos = rht_dereference(*rht_bucket(tbl, i), ht),
 			     next = !rht_is_a_nulls(pos) ?
 					rht_dereference(pos->next, ht) : NULL;
