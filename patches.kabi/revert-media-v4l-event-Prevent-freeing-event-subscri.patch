From: Jiri Slaby <jslaby@suse.cz>
Date: Mon, 15 Oct 2018 09:48:38 +0200
Subject: Revert "media: v4l: event: Prevent freeing event subscriptions while
 accessed"
Patch-mainline: never, kabi
References: kabi

This reverts commit bbbc4dabca5d51c608b0fd608eb3cd8659266653, upstream
commit ad608fbcf166fec809e402d548761768f602702c. It adds a mutex to
struct v4l2_fh. This struct is embedded in many other external
structures, so we cannot add anything in there (to avoid kABI breakage).

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 drivers/media/v4l2-core/v4l2-event.c |   37 +++++++++++++++++------------------
 drivers/media/v4l2-core/v4l2-fh.c    |    2 -
 include/media/v4l2-fh.h              |    1 
 3 files changed, 18 insertions(+), 22 deletions(-)

--- a/drivers/media/v4l2-core/v4l2-event.c
+++ b/drivers/media/v4l2-core/v4l2-event.c
@@ -119,6 +119,14 @@ static void __v4l2_event_queue_fh(struct
 	if (sev == NULL)
 		return;
 
+	/*
+	 * If the event has been added to the fh->subscribed list, but its
+	 * add op has not completed yet elems will be 0, treat this as
+	 * not being subscribed.
+	 */
+	if (!sev->elems)
+		return;
+
 	/* Increase event sequence number on fh. */
 	fh->sequence++;
 
@@ -204,7 +212,6 @@ int v4l2_event_subscribe(struct v4l2_fh
 	struct v4l2_subscribed_event *sev, *found_ev;
 	unsigned long flags;
 	unsigned i;
-	int ret = 0;
 
 	if (sub->type == V4L2_EVENT_ALL)
 		return -EINVAL;
@@ -222,36 +229,31 @@ int v4l2_event_subscribe(struct v4l2_fh
 	sev->flags = sub->flags;
 	sev->fh = fh;
 	sev->ops = ops;
-	sev->elems = elems;
-
-	mutex_lock(&fh->subscribe_lock);
 
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 	found_ev = v4l2_event_subscribed(fh, sub->type, sub->id);
+	if (!found_ev)
+		list_add(&sev->list, &fh->subscribed);
 	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
 
 	if (found_ev) {
-		/* Already listening */
 		kfree(sev);
-		goto out_unlock;
+		return 0; /* Already listening */
 	}
 
 	if (sev->ops && sev->ops->add) {
-		ret = sev->ops->add(sev, elems);
+		int ret = sev->ops->add(sev, elems);
 		if (ret) {
-			kfree(sev);
-			goto out_unlock;
+			sev->ops = NULL;
+			v4l2_event_unsubscribe(fh, sub);
+			return ret;
 		}
 	}
 
-	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
-	list_add(&sev->list, &fh->subscribed);
-	spin_unlock_irqrestore(&fh->vdev->fh_lock, flags);
-
-out_unlock:
-	mutex_unlock(&fh->subscribe_lock);
+	/* Mark as ready for use */
+	sev->elems = elems;
 
-	return ret;
+	return 0;
 }
 EXPORT_SYMBOL_GPL(v4l2_event_subscribe);
 
@@ -290,8 +292,6 @@ int v4l2_event_unsubscribe(struct v4l2_f
 		return 0;
 	}
 
-	mutex_lock(&fh->subscribe_lock);
-
 	spin_lock_irqsave(&fh->vdev->fh_lock, flags);
 
 	sev = v4l2_event_subscribed(fh, sub->type, sub->id);
@@ -310,7 +310,6 @@ int v4l2_event_unsubscribe(struct v4l2_f
 		sev->ops->del(sev);
 
 	kfree(sev);
-	mutex_unlock(&fh->subscribe_lock);
 
 	return 0;
 }
--- a/drivers/media/v4l2-core/v4l2-fh.c
+++ b/drivers/media/v4l2-core/v4l2-fh.c
@@ -49,7 +49,6 @@ void v4l2_fh_init(struct v4l2_fh *fh, st
 	INIT_LIST_HEAD(&fh->available);
 	INIT_LIST_HEAD(&fh->subscribed);
 	fh->sequence = -1;
-	mutex_init(&fh->subscribe_lock);
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_init);
 
@@ -94,7 +93,6 @@ void v4l2_fh_exit(struct v4l2_fh *fh)
 	if (fh->vdev == NULL)
 		return;
 	v4l2_event_unsubscribe_all(fh);
-	mutex_destroy(&fh->subscribe_lock);
 	fh->vdev = NULL;
 }
 EXPORT_SYMBOL_GPL(v4l2_fh_exit);
--- a/include/media/v4l2-fh.h
+++ b/include/media/v4l2-fh.h
@@ -43,7 +43,6 @@ struct v4l2_fh {
 	wait_queue_head_t	wait;
 	struct list_head	subscribed; /* Subscribed events */
 	struct list_head	available; /* Dequeueable event */
-	struct mutex		subscribe_lock;
 	unsigned int		navailable;
 	u32			sequence;
 
