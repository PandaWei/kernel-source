From: Jiri Slaby <jslaby@suse.cz>
Date: Mon, 15 Oct 2018 18:40:25 +0200
Subject: Revert "tcp: free batches of packets in tcp_prune_ofo_queue()"
Patch-mainline: never, kabi
References: kabi

This reverts commit 352b66932a23fb11f0a7c316361220648bca3c79, upstream
commit 72cd43ba64fc172a443410ce01645895850844c8. It fixes/depends on
commit 4666b6e2b27d91e05a5b8459e40e4a05dbc1c7b0, upstream commit
9f5afeae51526b3ad7b7cb21ee8b145ce6ea7a7a and that is being reverted due
to kABI breakage.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 net/ipv4/tcp_input.c | 16 +++++-----------
 1 file changed, 5 insertions(+), 11 deletions(-)

diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c
index 4739a93425ed..4cc0a53652ea 100644
--- a/net/ipv4/tcp_input.c
+++ b/net/ipv4/tcp_input.c
@@ -4899,33 +4899,27 @@ new_range:
 
 /*
  * Purge the out-of-order queue.
- * Drop at least 12.5 % of sk_rcvbuf to avoid malicious attacks.
  * Return true if queue was pruned.
  */
 static bool tcp_prune_ofo_queue(struct sock *sk)
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct rb_node *node, *prev;
-	int goal;
 
 	if (RB_EMPTY_ROOT(&tp->out_of_order_queue))
 		return false;
 
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_OFOPRUNED);
-	goal = sk->sk_rcvbuf >> 3;
+
 	node = &tp->ooo_last_skb->rbnode;
 	do {
 		prev = rb_prev(node);
 		rb_erase(node, &tp->out_of_order_queue);
-		goal -= rb_to_skb(node)->truesize;
 		__kfree_skb(rb_to_skb(node));
-		if (!prev || goal <= 0) {
-			sk_mem_reclaim(sk);
-			if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&
-			    !tcp_under_memory_pressure(sk))
-				break;
-			goal = sk->sk_rcvbuf >> 3;
-		}
+		sk_mem_reclaim(sk);
+		if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf &&
+		    !tcp_under_memory_pressure(sk))
+			break;
 
 		node = prev;
 	} while (node);
-- 
2.19.1

