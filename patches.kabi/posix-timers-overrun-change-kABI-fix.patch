From: Takashi Iwai <tiwai@suse.de>
Subject: kABI workaround for posix-timers it_overrun 64bit changes
Patch-mainline: Never, kABI fix
References: CVE-2018-12896,bsc#1099922

This is a very messy workaround for kABI breakage due to the change to
64bit values of it_overrun and it_overrun_last in struct k_itimer.
We just keep the shadow copy of 32bit values in the original place,
updating them along with 64bit values.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 include/linux/posix-timers.h |   16 ++++++++++++++--
 kernel/posix-cpu-timers.c    |    7 +++++++
 kernel/posix-timers.c        |    9 ++++++++-
 kernel/time/alarmtimer.c     |    4 +++-
 4 files changed, 32 insertions(+), 4 deletions(-)

--- a/include/linux/posix-timers.h
+++ b/include/linux/posix-timers.h
@@ -58,8 +58,13 @@ struct k_itimer {
 	spinlock_t it_lock;
 	clockid_t it_clock;		/* which timer type */
 	timer_t it_id;			/* timer id */
-	s64 it_overrun;			/* overrun on pending signal  */
-	s64 it_overrun_last;		/* overrun on last delivered signal */
+#ifdef __GENKSYMS__
+	int it_overrun;			/* overrun on pending signal  */
+	int it_overrun_last;		/* overrun on last delivered signal */
+#else
+	int __it_overrun;		/* shadow copy of 32bit it_overrun */
+	int __it_overrun_last;		/* shadow copy of 32bit it_overrun_last */
+#endif
 	int it_requeue_pending;		/* waiting to requeue this timer */
 #define REQUEUE_PENDING 1
 	int it_sigev_notify;		/* notify word of sigevent struct */
@@ -84,6 +89,13 @@ struct k_itimer {
 		struct alarm alarmtimer;
 		struct rcu_head rcu;
 	} it;
+#ifndef __GENKSYMS__
+	/* real values of it_overrun and it_overrun_last are kept here for
+	 * kABI compatibility
+	 */
+	s64 it_overrun;			/* overrun on pending signal  */
+	s64 it_overrun_last;		/* overrun on last delivered signal */
+#endif
 };
 
 struct k_clock {
--- a/kernel/posix-timers.c
+++ b/kernel/posix-timers.c
@@ -311,6 +311,8 @@ static void schedule_next_timer(struct k
 
 	timr->it_overrun_last = timr->it_overrun;
 	timr->it_overrun = -1LL;
+	timr->__it_overrun_last = (unsigned int)timr->it_overrun_last;
+	timr->__it_overrun = -1;
 	++timr->it_requeue_pending;
 	hrtimer_restart(timer);
 }
@@ -436,6 +438,7 @@ static enum hrtimer_restart posix_timer_
 #endif
 			timr->it_overrun += hrtimer_forward(timer, now,
 							    timr->it.real.interval);
+			timr->__it_overrun = (unsigned int)timr->it_overrun;
 			ret = HRTIMER_RESTART;
 			++timr->it_requeue_pending;
 		}
@@ -584,6 +587,7 @@ SYSCALL_DEFINE3(timer_create, const cloc
 	new_timer->it_id = (timer_t) new_timer_id;
 	new_timer->it_clock = which_clock;
 	new_timer->it_overrun = -1LL;
+	new_timer->__it_overrun = -1;
 
 	if (timer_event_spec) {
 		if (copy_from_user(&event, timer_event_spec, sizeof (event))) {
@@ -711,8 +715,10 @@ common_timer_get(struct k_itimer *timr,
 	 * expiry is > now.
 	 */
 	if (iv.tv64 && (timr->it_requeue_pending & REQUEUE_PENDING ||
-	    (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE))
+	    (timr->it_sigev_notify & ~SIGEV_THREAD_ID) == SIGEV_NONE)) {
 		timr->it_overrun += hrtimer_forward(timer, now, iv);
+		timr->__it_overrun = (unsigned int)timr->it_overrun;
+	}
 
 	remaining = ktime_sub(hrtimer_get_expires(timer), now);
 	/* Return 0 only, when the timer is expired and not pending */
@@ -804,6 +810,7 @@ common_timer_set(struct k_itimer *timr,
 	timr->it_requeue_pending = (timr->it_requeue_pending + 2) & 
 		~REQUEUE_PENDING;
 	timr->it_overrun_last = 0;
+	timr->__it_overrun_last = 0;
 
 	/* switch off the timer when it_value is zero */
 	if (!new_setting->it_value.tv_sec && !new_setting->it_value.tv_nsec)
--- a/kernel/time/alarmtimer.c
+++ b/kernel/time/alarmtimer.c
@@ -369,8 +369,10 @@ static void alarm_handle_timer(struct al
 {
 	struct k_itimer *ptr = container_of(alarm, struct k_itimer,
 						it.alarmtimer);
-	if (posix_timer_event(ptr, 0) != 0)
+	if (posix_timer_event(ptr, 0) != 0) {
 		ptr->it_overrun++;
+		ptr->__it_overrun++;
+	}
 }
 
 /**
--- a/kernel/posix-cpu-timers.c
+++ b/kernel/posix-cpu-timers.c
@@ -143,6 +143,7 @@ static void bump_cpu_timer(struct k_itim
 				continue;
 			timer->it.cpu.expires.sched += incr;
 			timer->it_overrun += 1LL << i;
+			timer->__it_overrun = (unsigned int)timer->it_overrun;
 			delta -= incr;
 		}
 	} else {
@@ -162,6 +163,7 @@ static void bump_cpu_timer(struct k_itim
 			timer->it.cpu.expires.cpu =
 				cputime_add(timer->it.cpu.expires.cpu, incr);
 			timer->it_overrun += 1LL << i;
+			timer->__it_overrun = (unsigned int)timer->it_overrun;
 			delta = cputime_sub(delta, incr);
 		}
 	}
@@ -804,6 +806,8 @@ static int posix_cpu_timer_set(struct k_
 		~REQUEUE_PENDING;
 	timer->it_overrun_last = 0;
 	timer->it_overrun = -1LL;
+	timer->__it_overrun_last = 0;
+	timer->__it_overrun = -1;
 
 	if (new_expires.sched != 0 &&
 	    !cpu_time_before(timer->it_clock, val, new_expires)) {
@@ -1233,6 +1237,8 @@ out_unlock:
 out:
 	timer->it_overrun_last = timer->it_overrun;
 	timer->it_overrun = -1LL;
+	timer->__it_overrun_last = (unsigned int)timer->it_overrun_last;
+	timer->__it_overrun = -1;
 	++timer->it_requeue_pending;
 }
 
@@ -1432,6 +1438,7 @@ static int do_cpu_nanosleep(const clocki
 	spin_lock_init(&timer.it_lock);
 	timer.it_clock = which_clock;
 	timer.it_overrun = -1LL;
+	timer.__it_overrun = -1;
 	error = posix_cpu_timer_create(&timer);
 	timer.it_process = current;
 	if (!error) {
