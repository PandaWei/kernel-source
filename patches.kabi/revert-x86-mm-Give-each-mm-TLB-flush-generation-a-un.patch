From: Jiri Slaby <jslaby@suse.cz>
Date: Wed, 8 Aug 2018 17:14:52 +0200
Subject: Revert "x86/mm: Give each mm TLB flush generation a unique ID"
Patch-mainline: never, kabi
References: kabi

This reverts commit 937dad078f557ddd6151e62f7f0028c136ffba4a, upstream
commit f39681ed0f48498b80455095376f11535feea332. It adds u64 to struct
mm_context and this indeed breaks kABI -- the structure is inlined in
mm_struct which is used virtually everywhere. So we have to revert it
for now.

Signed-off-by: Jiri Slaby <jslaby@suse.cz>
---
 arch/x86/include/asm/mmu.h         | 15 ++-------------
 arch/x86/include/asm/mmu_context.h |  4 ----
 arch/x86/mm/tlb.c                  |  2 --
 3 files changed, 2 insertions(+), 19 deletions(-)

diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h
index 3359dfedc7ee..7680b76adafc 100644
--- a/arch/x86/include/asm/mmu.h
+++ b/arch/x86/include/asm/mmu.h
@@ -3,18 +3,12 @@
 
 #include <linux/spinlock.h>
 #include <linux/mutex.h>
-#include <linux/atomic.h>
 
 /*
- * x86 has arch-specific MMU state beyond what lives in mm_struct.
+ * The x86 doesn't have a mmu context, but
+ * we put the segment information here.
  */
 typedef struct {
-	/*
-	 * ctx_id uniquely identifies this mm_struct.  A ctx_id will never
-	 * be reused, and zero is not a valid ctx_id.
-	 */
-	u64 ctx_id;
-
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	struct ldt_struct *ldt;
 #endif
@@ -30,11 +24,6 @@ typedef struct {
 	atomic_t perf_rdpmc_allowed;	/* nonzero if rdpmc is allowed */
 } mm_context_t;
 
-#define INIT_MM_CONTEXT(mm)						\
-	.context = {							\
-		.ctx_id = 1,						\
-	}
-
 void leave_mm(int cpu);
 
 #endif /* _ASM_X86_MMU_H */
diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h
index effc12767cbf..1c4794f861d7 100644
--- a/arch/x86/include/asm/mmu_context.h
+++ b/arch/x86/include/asm/mmu_context.h
@@ -11,9 +11,6 @@
 #include <asm/tlbflush.h>
 #include <asm/paravirt.h>
 #include <asm/mpx.h>
-
-extern atomic64_t last_mm_ctx_id;
-
 #ifndef CONFIG_PARAVIRT
 static inline void paravirt_activate_mm(struct mm_struct *prev,
 					struct mm_struct *next)
@@ -108,7 +105,6 @@ static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
-	mm->context.ctx_id = atomic64_inc_return(&last_mm_ctx_id);
 	init_new_context_ldt(tsk, mm);
 	return 0;
 }
diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c
index efec198d271a..7cad01af6dcd 100644
--- a/arch/x86/mm/tlb.c
+++ b/arch/x86/mm/tlb.c
@@ -29,8 +29,6 @@
  *	Implement flush IPI by CALL_FUNCTION_VECTOR, Alex Shi
  */
 
-atomic64_t last_mm_ctx_id = ATOMIC64_INIT(1);
-
 struct flush_tlb_info {
 	struct mm_struct *flush_mm;
 	unsigned long flush_start;
-- 
2.18.0

