From: Jeff Mahoney <jeffm@suse.com>
Subject: Restore dentry_operations->d_manage
References: bsc#1086716
Patch-mainline: Never, SUSE-specific

Restore dentry_operations->d_manage

Signed-off-by: Jeff Mahoney <jeffm@suse.com>
Acked-by: Tiago Herrmann <therrmann@suse.com>
--- a/Documentation/filesystems/Locking
+++ b/Documentation/filesystems/Locking
@@ -19,7 +19,8 @@ prototypes:
 	void (*d_iput)(struct dentry *, struct inode *);
 	char *(*d_dname)((struct dentry *dentry, char *buffer, int buflen);
 	struct vfsmount *(*d_automount)(struct path *path);
-	int (*d_manage)(const struct path *, bool);
+	int (*d_manage)(struct dentry *, bool);
+	int (*d_manage_path)(const struct path *, bool);
 
 locking rules:
 		rename_lock	->d_lock	may block	rcu-walk
@@ -34,6 +35,7 @@ d_iput:		no		no		yes		no
 d_dname:	no		no		no		no
 d_automount:	no		no		yes		no
 d_manage:	no		no		yes (ref-walk)	maybe
+d_manage_path:	no		no		yes (ref-walk)	maybe
 
 --------------------------- inode_operations --------------------------- 
 prototypes:
--- a/fs/autofs4/init.c
+++ b/fs/autofs4/init.c
@@ -25,6 +25,7 @@ static struct file_system_type autofs_fs
 	.name		= "autofs",
 	.mount		= autofs_mount,
 	.kill_sb	= autofs4_kill_sb,
+	.fs_flags	= FS_D_MANAGE_PATH,
 };
 MODULE_ALIAS_FS("autofs");
 
--- a/fs/autofs4/root.c
+++ b/fs/autofs4/root.c
@@ -67,7 +67,7 @@ const struct inode_operations autofs4_di
 
 const struct dentry_operations autofs4_dentry_operations = {
 	.d_automount	= autofs4_d_automount,
-	.d_manage	= autofs4_d_manage,
+	.d_manage_path	= autofs4_d_manage,
 	.d_release	= autofs4_dentry_release,
 };
 
--- a/fs/namei.c
+++ b/fs/namei.c
@@ -1154,6 +1154,21 @@ static int follow_automount(struct path
 
 }
 
+static int path_d_manage(const struct path *path, bool rcu_walk)
+{
+	struct super_block *sb = path->dentry->d_sb;
+
+	BUG_ON(!path->dentry->d_op);
+
+	if (sb->s_type->fs_flags & FS_D_MANAGE_PATH) {
+		BUG_ON(!path->dentry->d_op->d_manage_path);
+		return path->dentry->d_op->d_manage_path(path, rcu_walk);
+	}
+
+	BUG_ON(!path->dentry->d_op->d_manage);
+	return path->dentry->d_op->d_manage(path->dentry, rcu_walk);
+}
+
 /*
  * Handle a dentry that is managed in some way.
  * - Flagged for transit management (autofs)
@@ -1179,9 +1195,7 @@ static int follow_managed(struct path *p
 		/* Allow the filesystem to manage the transit without i_mutex
 		 * being held. */
 		if (managed & DCACHE_MANAGE_TRANSIT) {
-			BUG_ON(!path->dentry->d_op);
-			BUG_ON(!path->dentry->d_op->d_manage);
-			ret = path->dentry->d_op->d_manage(path, false);
+			ret = path_d_manage(path, false);
 			if (ret < 0)
 				break;
 		}
@@ -1247,7 +1261,7 @@ EXPORT_SYMBOL(follow_down_one);
 static inline int managed_dentry_rcu(const struct path *path)
 {
 	return (path->dentry->d_flags & DCACHE_MANAGE_TRANSIT) ?
-		path->dentry->d_op->d_manage(path, true) : 0;
+		path_d_manage(path, true) : 0;
 }
 
 /*
@@ -1373,9 +1387,7 @@ int follow_down(struct path *path)
 		 * The filesystem may sleep at this point.
 		 */
 		if (managed & DCACHE_MANAGE_TRANSIT) {
-			BUG_ON(!path->dentry->d_op);
-			BUG_ON(!path->dentry->d_op->d_manage);
-			ret = path->dentry->d_op->d_manage(path, false);
+			ret = path_d_manage(path, false);
 			if (ret < 0)
 				return ret == -EISDIR ? 0 : ret;
 		}
--- a/include/linux/dcache.h
+++ b/include/linux/dcache.h
@@ -159,9 +159,12 @@ struct dentry_operations {
 	void (*d_iput)(struct dentry *, struct inode *);
 	char *(*d_dname)(struct dentry *, char *, int);
 	struct vfsmount *(*d_automount)(struct path *);
-	int (*d_manage)(const struct path *, bool);
+	int (*d_manage)(struct dentry *, bool);
 	struct inode *(*d_select_inode)(struct dentry *, unsigned);
 	struct dentry *(*d_real)(struct dentry *, struct inode *);
+#ifndef __GENKSYMS__
+	int (*d_manage_path)(const struct path *, bool);
+#endif
 } ____cacheline_aligned;
 
 /*
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1971,6 +1971,7 @@ struct file_system_type {
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
 #define FS_USERNS_VISIBLE	32	/* FS must already be visible */
+#define FS_D_MANAGE_PATH	16384   /* dentry_operations has d_manage_path */
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);

