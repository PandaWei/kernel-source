From: Steffen Maier <maier@linux.ibm.com>
Subject: scsi: zfcp: fix missing REC trigger trace on terminate_rport_io early return
Patch-mainline: v4.18-rc1
Git-commit: 96d9270499471545048ed8a6d7f425a49762283d
References: bnc#1102087, LTC#168765

Description:  zfcp: fix tracing regressions, part 3
Symptom:      Cannot determine result of eh_host_reset_handler.

              Cannot see if and when zfcp retries abort or task management
              functions (LUN/target reset) while synchronizing scsi_eh and
              zfcp-internal recovery.

              Confusing zfcp ERP trace record if a SCSI device is deleted
              during scsi_eh host reset.

              Cannot determine that our terminate_rport_io callback was
              invoked if it returned early.

              Cannot determine that our terminate_rport_io callback was
              invoked if a long fast_io_fail_tmo was configured (typically
              longer than 12 seconds, e.g. 27 seconds).

              Cannot determine if something wanted to enqueue zfcp recovery
              for an object (adapter/port regular/unit) in ERP_FAILED state.

              Cannot determine if something wanted to enqueue zfcp recovery
              but no zfcp ERP thread was running.
Problem:      v2.6.35 commit a1dbfddd02d2 ("[SCSI] zfcp: Pass return code
              from fc_block_scsi_eh to scsi eh") introduced the first
              return with something other than the previously hardcoded
              single SUCCESS return path.

              Due to zfcp_erp_wait() and fc_block_scsi_eh() time can pass
              between the start of our eh callback and an actual send/recv
              of an abort / TMF request.

              If a SCSI device is deleted during scsi_eh host reset, we
              cannot get a reference to the SCSI device anymore since
              scsi_device_get returns !=0 by design. Assuming the recovery
              of adapter and port(s) was successful,
              zfcp_erp_strategy_followup_success() attempts to trigger a
              LUN reset for the half-gone SCSI device. However,
              zfcp_erp_setup_act() returns NULL as it cannot get the
              reference. Hence, zfcp_erp_action_enqueue() takes an early
              goto out and _NO_ recovery actually happens, but it writes a
              confusing trace record which states that zfcp will do a LUN
              recovery as "ERP need" is ZFCP_ERP_ACTION_REOPEN_LUN == 1 and
              equals "ERP want".
              Before v2.6.38 commit ae0904f60fab ("[SCSI] zfcp: Redesign of
              the debug tracing for recovery actions.") we could detect
              this case because the "erp_action" field in the trace was
              NULL. The rework removed erp_action as argument and field
              from the trace.

              If we get an fc_rport in terminate_rport_io() for which we
              cannot find a match within zfcp_get_port_by_wwpn(), the
              latter can return NULL. v2.6.30 commit 70932935b61e ("[SCSI]
              zfcp: Fix oops when port disappears") introduced an early
              return without adding a trace record for this case.

              After target cable pull: The ADISC for "link" test times out
              after typically 4 seconds. The open port recovery times out
              after typically 8 seconds, causing zfcp_port.status to
              contain ERP_FAILED. zfcp_scsi_terminate_rport_io() tries to
              enqueue forced port recovery, but due to ERP_FAILED this
              resulted in a silent early return.

              Trying to enqueue recovery for adapter / port regular / LUN
              resulted in silent early returns.

              Trying to enqueue recovery if no ERP thread was running
              resulted in silent early returns.
Solution:     Write trace record in zfcp area SCSI and re-use SCSI result
              field to contain the return value of eh_host_reset_handler.

              Add a trace before calling the two blocking functions
              zfcp_erp_wait() and fc_block_scsi_eh().

              Introduce an eyecatcher "flag" to mark the "ERP need" as 'not
              needed' but still keep the information which erp_action type,
              that zfcp_erp_required_act() had decided upon, is needed.
              0xc_ is chosen to be visibly different from 0x0_ in "ERP
              want".

              Write trace record in zfcp area REC with "ERP need" none.

              Write trace record in zfcp area REC with "ERP need" 0xe0.

              zfcp_erp_action_enqueue() already had two early outs which
              re-used the one zfcp_dbf_rec_trig() call. All ERP trigger
              functions finally run through zfcp_erp_action_enqueue(). So
              move the special handling for ZFCP_STATUS_COMMON_ERP_FAILED
              into zfcp_erp_action_enqueue() and add another early out with
              new trace marker for pseudo ERP need in this case. This
              removes all early returns from all ERP trigger functions so
              we always end up at zfcp_dbf_rec_trig().

              Write trace record in zfcp area REC with "ERP need" 0xc0.
Reproduction: If NPIV is not enabled with subchannel, ensure that your
              subchannel is the only one active on the entire channel.
              Set eh_deadline to a short enough time interval, e.g. 5
              seconds (before FCP device online: scsi_mod.eh_deadline=5).
              Enable RSCN suppression on the SAN switch port beyond the
              first link, i.e. towards the storage target. Disable that
              switch port. Send one SCSI command to the single path SCSI
              disk of that port in the background (because it will block
              for a while) e.g. via "dd if=/dev/sd... of=/dev/null
              iflag=direct count=1 &". After <SCSI command timeout>
              seconds, the command runs into the timeout. Due to the short
              eh_deadline, the SCSI midlayer immediately performs SCSI host
              reset. After the corresponding adapter recovery, the new
              trace record "schrh_r" appears.

              Difficult to reproduce as we need to have a SCSI command time
              out once (abort) or twice (scsi_eh), and timely have to
              prevent sending of the abort or TMF. Examples to prevent
              sending is severe memory pressure, or zfcp-internal recovery
              of the zfcp unit (e.g. write 0 to failed sysfs attribute) or
              of the target port (depending on potentially escalated
              scsi_eh scope) so the zfcp object is blocked.

              Difficult to reproduce as we need to get into scsi_eh, fully
              escalate to host reset, and something has to timely delete a
              SCSI device of this Scsi_Host.

              Disable auto port REscan with zfcp.no_auto_port_rescan=1. Let
              always enabled zfcp auto port scan attach a target remote
              port without attaching LUNs to it (zfcp.allow_lun_scan=0 and
              no explicit zfcp unit_add). Use zfcp port_remove to remove
              such target port again. After fast_io_fail_tmo or
              dev_loss_tmo, the new trace record "sctrpin" can appear.

              If NPIV is not enabled with subchannel, ensure that your
              subchannel is the only one active on the entire channel.
              Configure a large enough fast_io_fail_tmo, e.g. 27 seconds.
              Pull cable at target side. Wait until fast_io_fail_tmo runs
              out and with the fix a zfcp trace "sctrpi1" with "ERP need"
              0xe0 must appear in the REC area. (for shared non-NPIV
              subchannels, only the first subchannel, that happens to
              complete the corresponding code path, ends up in this
              particular case)

              Difficult to reproduce as we need a "soft" recovery trigger
              that does not clear ERP_FAILED (as opposed to e.g. failed
              sysfs attribute).

              No known reproduction.

Upstream-Description:

              scsi: zfcp: fix missing REC trigger trace on terminate_rport_io early return

              get_device() and its internally used kobject_get() only return NULL if they
              get passed NULL as argument. zfcp_get_port_by_wwpn() loops over
              adapter->port_list so the iteration variable port is always non-NULL.
              Struct device is embedded in struct zfcp_port so &port->dev is always
              non-NULL. This is the argument to get_device().  However, if we get an
              fc_rport in terminate_rport_io() for which we cannot find a match within
              zfcp_get_port_by_wwpn(), the latter can return NULL.  v2.6.30 commit
              70932935b61e ("[SCSI] zfcp: Fix oops when port disappears") introduced an
              early return without adding a trace record for this case.  Even if we don't
              need recovery in this case, for debugging we should still see that our
              callback was invoked originally by scsi_transport_fc.

              Example trace record formatted with zfcpdbf from s390-tools:

              Timestamp      : ...
              Area           : REC
              Subarea        : 00
              Level          : 1
              Exception      : -
              CPU ID         : ..
              Caller         : 0x...
              Record ID      : 1
              Tag            : sctrpin        SCSI terminate rport I/O, no zfcp port
              LUN            : 0xffffffffffffffff                     none (invalid)
              WWPN           : 0x<wwpn>               WWPN
              D_ID           : 0x<n_port_id>          N_Port-ID
              Adapter status : 0x...
              Port status    : 0xffffffff             unknown (-1)
              LUN status     : 0x00000000                             none (invalid)
              Ready count    : 0x...
              Running count  : 0x...
              ERP want       : 0x03                   ZFCP_ERP_ACTION_REOPEN_PORT_FORCED
              ERP need       : 0xc0                   ZFCP_ERP_ACTION_NONE

              Signed-off-by: Steffen Maier <maier@linux.ibm.com>
              Fixes: 70932935b61e ("[SCSI] zfcp: Fix oops when port disappears")
              Cc: <stable@vger.kernel.org> #2.6.38+
              Reviewed-by: Benjamin Block <bblock@linux.ibm.com>
              Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>


Signed-off-by: Steffen Maier <maier@linux.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/s390/scsi/zfcp_erp.c  |   20 ++++++++++++++++++++
 drivers/s390/scsi/zfcp_ext.h  |    3 +++
 drivers/s390/scsi/zfcp_scsi.c |    5 +++++
 3 files changed, 28 insertions(+)

--- a/drivers/s390/scsi/zfcp_erp.c
+++ b/drivers/s390/scsi/zfcp_erp.c
@@ -282,6 +282,26 @@ static int zfcp_erp_action_enqueue(int w
 	return retval;
 }
 
+void zfcp_erp_port_forced_no_port_dbf(char *id, struct zfcp_adapter *adapter,
+				      u64 port_name, u32 port_id)
+{
+	unsigned long flags;
+	static /* don't waste stack */ struct zfcp_port tmpport;
+
+	write_lock_irqsave(&adapter->erp_lock, flags);
+	/* Stand-in zfcp port with fields just good enough for
+	 * zfcp_dbf_rec_trig() and zfcp_dbf_set_common().
+	 * Under lock because tmpport is static.
+	 */
+	atomic_set(&tmpport.status, -1); /* unknown */
+	tmpport.wwpn = port_name;
+	tmpport.d_id = port_id;
+	zfcp_dbf_rec_trig(id, adapter, &tmpport, NULL,
+			  ZFCP_ERP_ACTION_REOPEN_PORT_FORCED,
+			  ZFCP_ERP_ACTION_NONE);
+	write_unlock_irqrestore(&adapter->erp_lock, flags);
+}
+
 static int _zfcp_erp_adapter_reopen(struct zfcp_adapter *adapter,
 				    int clear_mask, char *id)
 {
--- a/drivers/s390/scsi/zfcp_ext.h
+++ b/drivers/s390/scsi/zfcp_ext.h
@@ -72,6 +72,9 @@ extern void zfcp_dbf_scsi_eh(char *tag,
 /* zfcp_erp.c */
 extern void zfcp_erp_set_adapter_status(struct zfcp_adapter *, u32);
 extern void zfcp_erp_clear_adapter_status(struct zfcp_adapter *, u32);
+extern void zfcp_erp_port_forced_no_port_dbf(char *id,
+					     struct zfcp_adapter *adapter,
+					     u64 port_name, u32 port_id);
 extern void zfcp_erp_adapter_reopen(struct zfcp_adapter *, int, char *);
 extern void zfcp_erp_adapter_shutdown(struct zfcp_adapter *, int, char *);
 extern void zfcp_erp_set_port_status(struct zfcp_port *, u32);
--- a/drivers/s390/scsi/zfcp_scsi.c
+++ b/drivers/s390/scsi/zfcp_scsi.c
@@ -622,6 +622,11 @@ static void zfcp_scsi_terminate_rport_io
 	if (port) {
 		zfcp_erp_port_forced_reopen(port, 0, "sctrpi1");
 		put_device(&port->dev);
+	} else {
+		zfcp_erp_port_forced_no_port_dbf(
+			"sctrpin", adapter,
+			rport->port_name /* zfcp_scsi_rport_register */,
+			rport->port_id /* zfcp_scsi_rport_register */);
 	}
 }
 
