From: Joerg Roedel <jroedel@suse.de>
Date: Fri, 13 Jul 2018 09:07:03 +0200
Subject: x86/ssbd: Re-evaluate SSBD features after ucode update
Patch-mainline: No, SUSE specific code
References: bsc#1087082 bsc#1100394 CVE-2018-3639

Make sure we initialize SSDB support late when new microcode
is loaded into the CPU.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/include/asm/spec_ctrl.h |  2 ++
 arch/x86/kernel/cpu/bugs.c       | 18 ++++++++++++++----
 arch/x86/kernel/cpu/spec_ctrl.c  | 25 ++++++++++++++++++++++++-
 arch/x86/kernel/microcode_core.c |  1 +
 4 files changed, 41 insertions(+), 5 deletions(-)

--- a/arch/x86/include/asm/spec_ctrl.h
+++ b/arch/x86/include/asm/spec_ctrl.h
@@ -90,8 +90,10 @@ void x86_disable_ibrs(void);
 unsigned int x86_ibrs_enabled(void);
 unsigned int x86_ibpb_enabled(void);
 void x86_spec_check(void);
+void x86_spec_set_on_each_cpu(void);
 int nospec(char *str);
 void stuff_RSB(void);
+void ssb_select_mitigation(void);
 
 static inline void x86_ibp_barrier(void)
 {
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -29,6 +29,8 @@
 #include <asm/nospec-branch.h>
 #include <asm/spec-ctrl.h>
 
+static void ssb_init_cmd_line(void);
+
 #ifdef CONFIG_X86_32
 static int __init no_halt(char *s)
 {
@@ -171,7 +173,7 @@ static void __init check_config(void)
 #endif /* CONFIG_X86_32 */
 
 static void __init spectre_v2_select_mitigation(void);
-static void __init ssb_select_mitigation(void);
+void ssb_select_mitigation(void);
 static void x86_amd_ssbd_disable(void);
 
 /*
@@ -225,6 +227,7 @@ void __init check_bugs(void)
 	 * Select proper mitigation for any exposure to the Speculative Store
 	 * Bypass vulnerability.
 	 */
+	ssb_init_cmd_line();
 	ssb_select_mitigation();
 
 #ifdef CONFIG_X86_32
@@ -510,6 +513,8 @@ enum ssb_mitigation_cmd {
 	SPEC_STORE_BYPASS_CMD_SECCOMP,
 };
 
+static enum ssb_mitigation_cmd ssb_cmd;
+
 static const char *ssb_strings[] = {
 	[SPEC_STORE_BYPASS_NONE]        = "Vulnerable",
 	[SPEC_STORE_BYPASS_DISABLE]     = "Mitigation: Speculative Store Bypass disabled",
@@ -559,7 +564,12 @@ static enum ssb_mitigation_cmd __init ss
 	return cmd;
 }
 
-static enum ssb_mitigation_cmd __init __ssb_select_mitigation(void)
+static void ssb_init_cmd_line(void)
+{
+	ssb_cmd = ssb_parse_cmdline();
+}
+
+static enum ssb_mitigation_cmd __ssb_select_mitigation(void)
 {
 	enum ssb_mitigation mode = SPEC_STORE_BYPASS_NONE;
 	enum ssb_mitigation_cmd cmd;
@@ -567,7 +577,7 @@ static enum ssb_mitigation_cmd __init __
 	if (!boot_cpu_has(X86_FEATURE_SSBD))
 		return mode;
 
-	cmd = ssb_parse_cmdline();
+	cmd = ssb_cmd;
 	if (!x86_bug_spec_store_bypass &&
 			(cmd == SPEC_STORE_BYPASS_CMD_NONE ||
 			 cmd == SPEC_STORE_BYPASS_CMD_AUTO))
@@ -623,7 +633,7 @@ static enum ssb_mitigation_cmd __init __
 	return mode;
 }
 
-static void ssb_select_mitigation()
+void ssb_select_mitigation(void)
 {
 	ssb_mode = __ssb_select_mitigation();
 
--- a/arch/x86/kernel/cpu/spec_ctrl.c
+++ b/arch/x86/kernel/cpu/spec_ctrl.c
@@ -7,6 +7,7 @@
 #include <asm/msr.h>
 #include <asm/processor.h>
 #include <asm/spec_ctrl.h>
+#include <asm/cpu.h>
 
 /*
  * Keep it open for more flags in case needed.
@@ -63,13 +64,16 @@ EXPORT_SYMBOL_GPL(stuff_RSB);
  */
 void x86_spec_check(void)
 {
+	unsigned int edx;
 
 	if (ibpb_state == 0) {
 		printk_once(KERN_INFO "IBRS/IBPB: disabled\n");
 		return;
 	}
 
-	if (cpuid_edx(7) & BIT(26)) {
+	edx = cpuid_edx(7);
+
+	if (edx & BIT(26)) {
 		if (ibrs_state == -1) {
 			/* noone force-disabled IBRS */
 			ibrs_state = 1;
@@ -80,6 +84,13 @@ void x86_spec_check(void)
 
 		setup_force_cpu_cap(X86_FEATURE_SPEC_CTRL);
 		setup_force_cpu_cap(X86_FEATURE_IBRS);
+
+		if (!boot_cpu_has(X86_FEATURE_SSBD) &&
+		    (edx & BIT(31))) {
+			/* We gained SSBD support - initialize the mitigation */
+			setup_force_cpu_cap(X86_FEATURE_SSBD);
+			ssb_select_mitigation();
+		}
 	}
 
 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
@@ -93,6 +104,18 @@ void x86_spec_check(void)
 }
 EXPORT_SYMBOL_GPL(x86_spec_check);
 
+static void __x86_spec_set(void *data)
+{
+	x86_spec_ctrl_setup_ap();
+}
+
+void x86_spec_set_on_each_cpu(void)
+{
+	if (boot_cpu_has(X86_FEATURE_SSBD))
+		on_each_cpu(__x86_spec_set, NULL, 1);
+}
+EXPORT_SYMBOL_GPL(x86_spec_set_on_each_cpu);
+
 int __init nospec(char *str)
 {
 	/*
--- a/arch/x86/kernel/microcode_core.c
+++ b/arch/x86/kernel/microcode_core.c
@@ -298,6 +298,7 @@ static void microcode_check(void)
 {
 	perf_check_microcode();
 	x86_spec_check();
+	x86_spec_set_on_each_cpu();
 	cpu_caps_sync_late();
 }
 
