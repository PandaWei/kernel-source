From: Paolo Bonzini <pbonzini@redhat.com>
Date: Wed, 20 Jun 2018 13:05:59 -0600
Subject: [PATCH 2/2] kvm: x86: add support for L1D flush MSR
Patch-mainline: not yet (under discussion)
References: bnc#1089343, CVE-2018-3646

Intel's new microcode adds a new feature bit in CPUID[7,0].EDX[28].
If it is active, the displacement flush is unnecessary.  Tested on
a Coffee Lake machine.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[BR: Convert feature handling to use scattered]
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/cpufeature.h | 2 +-
 arch/x86/include/asm/msr-index.h  | 3 +++
 arch/x86/kernel/cpu/scattered.c   | 1 +
 arch/x86/kvm/x86.c                | 9 ++++++++-
 4 files changed, 13 insertions(+), 2 deletions(-)

diff --git a/arch/x86/include/asm/cpufeature.h b/arch/x86/include/asm/cpufeature.h
index 953b219024af..2307633a5b7c 100644
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@ -100,7 +100,7 @@
 #define X86_FEATURE_REP_GOOD	( 3*32+16) /* rep microcode works well */
 #define X86_FEATURE_MFENCE_RDTSC ( 3*32+17) /* "" Mfence synchronizes RDTSC */
 #define X86_FEATURE_LFENCE_RDTSC ( 3*32+18) /* "" Lfence synchronizes RDTSC */
-/* free, was #define X86_FEATURE_11AP	( 3*32+19) * "" Bad local APIC aka 11AP */
+#define X86_FEATURE_FLUSH_L1D	(3*32+19) /* IA32_FLUSH_L1D MSR */
 #define X86_FEATURE_NOPL	( 3*32+20) /* The NOPL (0F 1F) instructions */
 #define X86_FEATURE_ALWAYS	( 3*32+21) /* "" Always-present feature */
 #define X86_FEATURE_XTOPOLOGY	( 3*32+22) /* cpu topology enum extensions */
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 3b20b32c3545..5d8583f2780f 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -56,6 +56,9 @@
 
 #define MSR_MTRRcap			0x000000fe
 
+#define MSR_IA32_FLUSH_L1D             0x10b
+#define MSR_IA32_FLUSH_L1D_VALUE       0x00000001
+
 #define MSR_IA32_ARCH_CAPABILITIES	0x0000010a
 #define ARCH_CAP_RDCL_NO		(1 << 0)   /* Not susceptible to Meltdown */
 #define ARCH_CAP_IBRS_ALL		(1 << 1)   /* Enhanced IBRS support */
diff --git a/arch/x86/kernel/cpu/scattered.c b/arch/x86/kernel/cpu/scattered.c
index f9d9635fa72a..5cc6e10ffb56 100644
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@ -36,6 +36,7 @@ static const struct cpuid_bit cpuid_bits[] = {
 	{ X86_FEATURE_AVX512_4FMAPS,	CPUID_EDX, 3, 0x00000007, 0 },
 	{ X86_FEATURE_SPEC_CTRL,	CPUID_EDX,26, 0x00000007, 0 },
 	{ X86_FEATURE_INTEL_STIBP,	CPUID_EDX,27, 0x00000007, 0 },
+	{ X86_FEATURE_FLUSH_L1D,	CPUID_EDX,28, 0x00000007, 0 },
 	{ X86_FEATURE_ARCH_CAPABILITIES, CPUID_EDX,29, 0x00000007, 0 },
 	{ X86_FEATURE_SPEC_CTRL_SSBD,	CPUID_EDX,31, 0x00000007, 0 },
 	{ X86_FEATURE_HW_PSTATE,	CPUID_EDX, 7, 0x80000007, 0 },
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 15c6903a36fa..1be2798a386a 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5915,8 +5915,15 @@ static void *__read_mostly empty_zero_pages;
 
 void kvm_l1d_flush(void)
 {
+	int size;
+
+	if (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+		wrmsrl(MSR_IA32_FLUSH_L1D, MSR_IA32_FLUSH_L1D_VALUE);
+		return;
+	}
+
 	/* FIXME: could this be boot_cpu_data.x86_cache_size * 2?  */
-	int size = PAGE_SIZE << L1D_CACHE_ORDER;
+	size = PAGE_SIZE << L1D_CACHE_ORDER;
 	asm volatile(
 		/* First ensure the pages are in the TLB */
 		"xorl %%eax, %%eax\n\t"
-- 
2.17.1

