From: Paolo Bonzini <pbonzini@redhat.com>
Date: Wed, 20 Jun 2018 13:05:59 -0600
Subject: [PATCH 2/2] kvm: x86: add support for L1D flush MSR
Patch-mainline: not yet (under discussion)
References: bnc#1089343, CVE-2018-3646

Intel's new microcode adds a new feature bit in CPUID[7,0].EDX[28].
If it is active, the displacement flush is unnecessary.  Tested on
a Coffee Lake machine.

Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>
[BR: Convert feature handling to use scattered]
Acked-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/cpufeature.h | 1 +
 arch/x86/include/asm/msr-index.h  | 4 ++++
 arch/x86/kernel/cpu/scattered.c   | 1 +
 arch/x86/kvm/x86.c                | 9 ++++++++-
 4 files changed, 14 insertions(+), 1 deletion(-)

diff --git a/arch/x86/include/asm/cpufeature.h b/arch/x86/include/asm/cpufeature.h
index 6dd83ac45195..870654b33663 100644
--- a/arch/x86/include/asm/cpufeature.h
+++ b/arch/x86/include/asm/cpufeature.h
@@ -187,6 +187,7 @@
 #define X86_FEATURE_IBRS	( 7*32+21) /* "" Indirect Branch Restricted Speculation */
 #define X86_FEATURE_SSBD         ( 7*32+22) /* Speculative Store Bypass Disable */
 #define X86_FEATURE_SPEC_CTRL_MSR	( 7*32+23) /* "" Speculation Control MSR */
+#define X86_FEATURE_FLUSH_L1D	(7*32+24) /* IA32_FLUSH_L1D MSR */
 
 #define X86_FEATURE_AMD_SSBD     ( 7*32+27)  /* "" AMD SSBD implementation */
 #define X86_FEATURE_SPEC_STORE_BYPASS_DISABLE  ( 7*32+28) /* "" Disable Speculative Store Bypass. */
diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h
index 28fd95d6890c..ade128d890c8 100644
--- a/arch/x86/include/asm/msr-index.h
+++ b/arch/x86/include/asm/msr-index.h
@@ -50,6 +50,10 @@
 #define ATM_LNC_C6_AUTO_DEMOTE		(1UL << 25)
 
 #define MSR_MTRRcap			0x000000fe
+
+#define MSR_IA32_FLUSH_L1D		0x10b
+#define MSR_IA32_FLUSH_L1D_VALUE	0x00000001
+
 #define MSR_IA32_BBL_CR_CTL		0x00000119
 #define MSR_IA32_BBL_CR_CTL3		0x0000011e
 
diff --git a/arch/x86/kernel/cpu/scattered.c b/arch/x86/kernel/cpu/scattered.c
index 7f1e02b682ac..52eb721a5cbf 100644
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@ -40,6 +40,7 @@ void __cpuinit init_scattered_cpuid_features(struct cpuinfo_x86 *c)
 		{ X86_FEATURE_EPB,		CR_ECX, 3, 0x00000006, 0 },
 		{ X86_FEATURE_SPEC_CTRL,        CR_EDX,26, 0x00000007, 0 },
 		{ X86_FEATURE_SPEC_CTRL_MSR,    CR_EDX,26, 0x00000007, 0 },
+		{ X86_FEATURE_FLUSH_L1D,	CR_EDX,28, 0x00000007, 0 },
 		{ X86_FEATURE_SSBD,		CR_EDX,31, 0x00000007, 0 },
 		{ X86_FEATURE_XSAVEOPT,		CR_EAX,	0, 0x0000000d, 1 },
 		{ X86_FEATURE_CPB,		CR_EDX, 9, 0x80000007, 0 },
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 19fcba72f5fd..ad41d05ce12e 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5171,8 +5171,15 @@ static void *__read_mostly empty_zero_pages;
 
 void kvm_l1d_flush(void)
 {
+	int size;
+
+	if (static_cpu_has(X86_FEATURE_FLUSH_L1D)) {
+		wrmsrl(MSR_IA32_FLUSH_L1D, MSR_IA32_FLUSH_L1D_VALUE);
+		return;
+	}
+
 	/* FIXME: could this be boot_cpu_data.x86_cache_size * 2?  */
-	int size = PAGE_SIZE << L1D_CACHE_ORDER;
+	size = PAGE_SIZE << L1D_CACHE_ORDER;
 	asm volatile(
 		/* First ensure the pages are in the TLB */
 		"xorl %%eax, %%eax\n\t"
-- 
2.17.1

