From: Julian Wiedmann <jwi@linux.ibm.com>
Subject: s390/qeth: fix SETIP command handling
Patch-mainline: v4.16-rc1
Git-commit: 1c5b2216fbb973a9410e0b06389740b5c1289171
References: bnc#1099709, LTC#169004

Description:  qeth: fix IPA command submission race 
Symptom:      Sporadic recovery.
Problem:      If multiple IPA commands are build & sent out
              concurrently, fill_ipacmd_header() may assign a seqno
              value to a command that's different from what
              send_control_data() later assigns to this command's reply.
              This is due to other commands passing through
              send_control_data(), and incrementing card->seqno.ipa along
              the way.
              So one IPA command has no reply that's waiting for its
              seqno, while some other IPA command has multiple reply
              objects waiting for it.
              Only one of those waiting replies wins, and the other(s)
              times out and triggers a recovery via send_ipa_cmd().
Solution:     Fix this by making sure that the same seqno value is
              assigned to a command and its reply object.
              Do so immediately before submitting the command & while
              holding the irq_pending "lock", to produce nicely ascending
              seqnos.
Reproduction: -

Upstream-Description:

              s390/qeth: fix SETIP command handling

              send_control_data() applies some special handling to SETIP v4 IPA
              commands. But current code parses *all* command types for the SETIP
              command code. Limit the command code check to IPA commands.

              Fixes: 5b54e16f1a54 ("qeth: do not spin for SETIP ip assist command")
              Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
              Signed-off-by: David S. Miller <davem@davemloft.net>


Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/s390/net/qeth_core.h      |    5 +++++
 drivers/s390/net/qeth_core_main.c |   14 ++++++++------
 2 files changed, 13 insertions(+), 6 deletions(-)

--- a/drivers/s390/net/qeth_core.h
+++ b/drivers/s390/net/qeth_core.h
@@ -578,6 +578,11 @@ struct qeth_cmd_buffer {
 	void (*callback) (struct qeth_channel *, struct qeth_cmd_buffer *);
 };
 
+static inline struct qeth_ipa_cmd *__ipa_cmd(struct qeth_cmd_buffer *iob)
+{
+	return (struct qeth_ipa_cmd *)(iob->data + IPA_PDU_HEADER_SIZE);
+}
+
 /**
  * definition of a qeth channel, used for read and write
  */
--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -2022,7 +2022,7 @@ int qeth_send_control_data(struct qeth_c
 	unsigned long flags;
 	struct qeth_reply *reply = NULL;
 	unsigned long timeout, event_timeout;
-	struct qeth_ipa_cmd *cmd;
+	struct qeth_ipa_cmd *cmd = NULL;
 
 	QETH_CARD_TEXT(card, 2, "sendctl");
 
@@ -2049,10 +2049,13 @@ int qeth_send_control_data(struct qeth_c
 	while (atomic_cmpxchg(&card->write.irq_pending, 0, 1)) ;
 	qeth_prepare_control_data(card, len, iob);
 
-	if (IS_IPA(iob->data))
+	if (IS_IPA(iob->data)) {
+		cmd = __ipa_cmd(iob);
 		event_timeout = QETH_IPA_TIMEOUT;
-	else
+	} else {
 		event_timeout = QETH_TIMEOUT;
+	}
+
 	timeout = jiffies + event_timeout;
 
 	QETH_CARD_TEXT(card, 6, "noirqpnd");
@@ -2077,9 +2080,8 @@ int qeth_send_control_data(struct qeth_c
 
 	/* we have only one long running ipassist, since we can ensure
 	   process context of this command we can sleep */
-	cmd = (struct qeth_ipa_cmd *)(iob->data+IPA_PDU_HEADER_SIZE);
-	if ((cmd->hdr.command == IPA_CMD_SETIP) &&
-	    (cmd->hdr.prot_version == QETH_PROT_IPV4)) {
+	if (cmd && cmd->hdr.command == IPA_CMD_SETIP &&
+	    cmd->hdr.prot_version == QETH_PROT_IPV4) {
 		if (!wait_event_timeout(reply->wait_q,
 		    atomic_read(&reply->received), event_timeout))
 			goto time_err;
