From: Thomas Gleixner <tglx@linutronix.de>
Date: Tue, 7 Aug 2018 08:19:57 +0200
Subject: cpu/hotplug: Fix SMT supported evaluation
Git-commit: bc2d8d262cba5736332cbc866acb11b1c5748aa9
Patch-mainline: v4.19-rc1
References: bsc#1089343

Josh reported that the late SMT evaluation in cpu_smt_state_init() sets
cpu_smt_control to CPU_SMT_NOT_SUPPORTED in case that 'nosmt' was supplied
on the kernel command line as it cannot differentiate between SMT disabled
by BIOS and SMT soft disable via 'nosmt'. That wreckages the state and
makes the sysfs interface unusable.

Rework this so that during bringup of the non boot CPUs the availability of
SMT is determined in cpu_smt_allowed(). If a newly booted CPU is not a
'primary' thread then set the local cpu_smt_available marker and evaluate
this explicitely right after the initial SMP bringup has finished.

SMT evaulation on x86 is a trainwreck as the firmware has all the
information _before_ booting the kernel, but there is no interface to query
it.


Additional notes for 4.4
=========================

At the time cpu_smt_check_topology() runs, we haven't set cpu_smt_available
even if SMT *is* available because we can't set it due to this here:

bool cpu_smt_allowed(unsigned int cpu):

	...

        if (per_cpu(cpuhp_state, cpu).booted_once)
                cpu_smt_available = true;

because we haven't set ->booted_once yet - we are booting once now.

By the time we run smp_smt_post_init(), cpu_smt_allowed() there is too late
because there we have:

[   17.601853] smp_smt_post_init: CPU12
[   17.613980] cpu_smt_allowed: CPU12
[   17.625679] cpu_smt_allowed: CPU12 cpu_smt_available: 0
[   17.641459] cpu_smt_allowed: cpu_smt_control: 3
[   17.655643] cpu_smt_allowed: CPU12 returning: 0:

where cpu_smt_control has already been set to CPU_SMT_NOT_SUPPORTED in
cpu_smt_check_topology() due to the wrong detection.

tl;dr version is: we need to call cpu_smt_allowed() directly after
cpu_set_booted() so that cpu_smt_available gets set:

        if (per_cpu(cpuhp_state, cpu).booted_once)
                cpu_smt_available = true;

and so that cpu_smt_check_topology() doesn't do this:

        cpu_smt_control = CPU_SMT_NOT_SUPPORTED;

The idea is to keep the non-upstream changes at a minimum and therefore we are
"dancing" around the scheme so that it works.

Boris.
======

Fixes: 73d5e2b47264 ("cpu/hotplug: detect SMT disabled by BIOS")
Reported-by: Josh Poimboeuf <jpoimboe@redhat.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Acked-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/kernel/cpu/bugs.c |    2 +-
 arch/x86/kernel/smpboot.c  |    9 +++++++++
 include/linux/cpu.h        |    2 ++
 kernel/cpu.c               |   41 ++++++++++++++++++++++++++++-------------
 kernel/smp.c               |    2 ++
 5 files changed, 42 insertions(+), 14 deletions(-)

--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -62,7 +62,7 @@ void __init check_bugs(void)
 	 * identify_boot_cpu() initialized SMT support information, let the
 	 * core code know.
 	 */
-	cpu_smt_check_topology();
+	cpu_smt_check_topology_early();
 
 	if (!IS_ENABLED(CONFIG_SMP)) {
 		pr_info("CPU: ");
--- a/arch/x86/kernel/smpboot.c
+++ b/arch/x86/kernel/smpboot.c
@@ -1026,6 +1026,15 @@ int native_cpu_up(unsigned int cpu, stru
 
 	cpu_set_booted(cpu);
 
+	/*
+	 * bp: Run the function below again so that cpu_smt_available gets set for
+	 * cpu_smt_check_topology()'s check to succeed. The whole CPU hotplug
+	 * order in this kernel is significantly different from upstream so we
+	 * have to do monkey business in order to fit the upstream scheme without
+	 * changing too much.
+	*/
+	cpu_smt_allowed(cpu);
+
 	return 0;
 }
 
--- a/include/linux/cpu.h
+++ b/include/linux/cpu.h
@@ -305,10 +305,12 @@ enum cpuhp_smt_control {
 #if defined(CONFIG_SMP) && defined(CONFIG_HOTPLUG_SMT)
 extern enum cpuhp_smt_control cpu_smt_control;
 extern void cpu_smt_disable(bool force);
+extern void cpu_smt_check_topology_early(void);
 extern void cpu_smt_check_topology(void);
 #else
 # define cpu_smt_control		(CPU_SMT_ENABLED)
 static inline void cpu_smt_disable(bool force) { }
+static inline void cpu_smt_check_topology_early(void) { }
 static inline void cpu_smt_check_topology(void) { }
 #endif
 
--- a/kernel/cpu.c
+++ b/kernel/cpu.c
@@ -471,6 +471,8 @@ EXPORT_SYMBOL(cpu_down);
 enum cpuhp_smt_control cpu_smt_control __read_mostly = CPU_SMT_ENABLED;
 EXPORT_SYMBOL_GPL(cpu_smt_control);
 
+static bool cpu_smt_available __read_mostly;
+
 void __init cpu_smt_disable(bool force)
 {
 	if (cpu_smt_control == CPU_SMT_FORCE_DISABLED ||
@@ -487,14 +489,28 @@ void __init cpu_smt_disable(bool force)
 
 /*
  * The decision whether SMT is supported can only be done after the full
- * CPU identification. Called from architecture code.
+ * CPU identification. Called from architecture code before non boot CPUs
+ * are brought up.
  */
-void __init cpu_smt_check_topology(void)
+void __init cpu_smt_check_topology_early(void)
 {
 	if (!topology_smt_supported())
 		cpu_smt_control = CPU_SMT_NOT_SUPPORTED;
 }
 
+/*
+ * If SMT was disabled by BIOS, detect it here, after the CPUs have been
+ * brought online. This ensures the smt/l1tf sysfs entries are consistent
+ * with reality. cpu_smt_available is set to true during the bringup of non
+ * boot CPUs when a SMT sibling is detected. Note, this may overwrite
+ * cpu_smt_control's previous setting.
+ */
+void __init cpu_smt_check_topology(void)
+{
+	if (!cpu_smt_available)
+		cpu_smt_control = CPU_SMT_NOT_SUPPORTED;
+}
+
 static int __init smt_cmdline_disable(char *str)
 {
 	cpu_smt_disable(str && !strcmp(str, "force"));
@@ -504,10 +520,18 @@ early_param("nosmt", smt_cmdline_disable
 
 bool cpu_smt_allowed(unsigned int cpu)
 {
-	if (cpu_smt_control == CPU_SMT_ENABLED)
+	if (topology_is_primary_thread(cpu))
 		return true;
 
-	if (topology_is_primary_thread(cpu))
+	/*
+	 * If the CPU is not a 'primary' thread and the booted_once bit is
+	 * set then the processor has SMT support. Store this information
+	 * for the late check of SMT support in cpu_smt_check_topology().
+	 */
+	if (per_cpu(cpuhp_state, cpu).booted_once)
+		cpu_smt_available = true;
+
+	if (cpu_smt_control == CPU_SMT_ENABLED)
 		return true;
 
 	/*
@@ -1043,15 +1067,6 @@ static const struct attribute_group cpuh
 
 static int __init cpu_smt_state_init(void)
 {
-	/*
-	 * If SMT was disabled by BIOS, detect it here, after the CPUs have
-	 * been brought online.  This ensures the smt/l1tf sysfs entries are
-	 * consistent with reality.  Note this may overwrite cpu_smt_control's
-	 * previous setting.
-	 */
-	if (topology_max_smt_threads() == 1)
-		cpu_smt_control = CPU_SMT_NOT_SUPPORTED;
-
 	return sysfs_create_group(&cpu_subsys.dev_root->kobj,
 				  &cpuhp_smt_attr_group);
 }
--- a/kernel/smp.c
+++ b/kernel/smp.c
@@ -578,6 +578,8 @@ void __init smp_init(void)
 			cpu_up(cpu);
 	}
 
+	/* Final decision about SMT support */
+	cpu_smt_check_topology();
 	/* Any cleanup work */
 	smp_announce();
 	smp_cpus_done(setup_max_cpus);
