From: QingFeng Hao <haoqf@linux.vnet.ibm.com>
Subject: s390/sthyi: add s390_sthyi system call
Patch-mainline: v4.15-rc1
Git-commit: 3d8757b87d7fc15a87928bc970f060bc9c6dc618
References: FATE#324258, LTC#160415, bsc#1068273

Heiko Carstens <heiko.carstens@de.ibm.com>
Summary:     kernel: STHYI for LPAR
Description: This feature makes STHYI(Store Hypervisor Information) available
             in LPAR using the syscall of NO. 380, and re-using the
             implementation for KVM by Janosch Frank - commit 95ca2cb57985
             ("KVM: s390: Add sthyi emulation").
             STHYI is an emulated z/VM instruction that provides a guest with
             basic information about the layers it is running on.
             This includes information about the cpu configuration of both the
             machine and the lpar, as well as their names, machine model and
             machine type. This information enables an application to determine
             the maximum capacity of CPs and IFLs available to software.
             More detailes are in link:
             http://www.ibm.com/support/knowledgecenter/SSB27U_6.3.0
             /com.ibm.zvm.v630.hcpb4/hcpb4sth.htm
             It is important to check the validity flags in the sections before
             using data from any structure member. It is not guaranteed that
             all members will be valid on all machines/machine configurations.

Upstream-Description:

             s390/sthyi: add s390_sthyi system call

             Add a syscall of s390_sthyi to implement STHYI instruction in LPAR
             which reuses the implementation for KVM by Janosch Frank -
             commit 95ca2cb57985 ("KVM: s390: Add sthyi emulation").

             STHYI(Store Hypervisor Information) is an emulated z/VM instruction that
             provides a guest with basic information about the layers it is running
             on. This includes information about the cpu configuration of both the
             machine and the lpar, as well as their names, machine model and
             machine type. This information enables an application to determine the
             maximum capacity of CPs and IFLs available to software.

             For the arguments of s390_sthyi, code shall be 0 and flags is reserved for
             future use, info is the output argument to store the required hypervisor
             info.

             Signed-off-by: QingFeng Hao <haoqf@linux.vnet.ibm.com>
             Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
             Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: QingFeng Hao <haoqf@linux.vnet.ibm.com>
Acked-by: Hannes Reinecke <hare@suse.com>
---
 arch/s390/include/uapi/asm/sthyi.h  |    6 ++++++
 arch/s390/include/uapi/asm/unistd.h |    3 ++-
 arch/s390/kernel/compat_wrapper.c   |    1 +
 arch/s390/kernel/entry.h            |    1 +
 arch/s390/kernel/sthyi.c            |   33 ++++++++++++++++++++++++++++++++-
 arch/s390/kernel/syscalls.S         |    1 +
 6 files changed, 43 insertions(+), 2 deletions(-)

--- /dev/null
+++ b/arch/s390/include/uapi/asm/sthyi.h
@@ -0,0 +1,6 @@
+#ifndef _UAPI_ASM_STHYI_H
+#define _UAPI_ASM_STHYI_H
+
+#define STHYI_FC_CP_IFL_CAP	0
+
+#endif /* _UAPI_ASM_STHYI_H */
--- a/arch/s390/include/uapi/asm/unistd.h
+++ b/arch/s390/include/uapi/asm/unistd.h
@@ -315,7 +315,8 @@
 #define __NR_pwritev2		377
 #define __NR_s390_guarded_storage	378
 #define __NR_statx		379
-#define NR_syscalls 380
+#define __NR_s390_sthyi		380
+#define NR_syscalls 381
 
 /* 
  * There are some system calls that are not present on 64 bit, some
--- a/arch/s390/kernel/compat_wrapper.c
+++ b/arch/s390/kernel/compat_wrapper.c
@@ -180,3 +180,4 @@ COMPAT_SYSCALL_WRAP3(mlock2, unsigned lo
 COMPAT_SYSCALL_WRAP6(copy_file_range, int, fd_in, loff_t __user *, off_in, int, fd_out, loff_t __user *, off_out, size_t, len, unsigned int, flags);
 COMPAT_SYSCALL_WRAP2(s390_guarded_storage, int, command, struct gs_cb *, gs_cb);
 COMPAT_SYSCALL_WRAP5(statx, int, dfd, const char __user *, path, unsigned, flags, unsigned, mask, struct statx __user *, buffer);
+COMPAT_SYSCALL_WRAP4(s390_sthyi, unsigned long, code, void __user *, info, u64 __user *, rc, unsigned long, flags);
--- a/arch/s390/kernel/entry.h
+++ b/arch/s390/kernel/entry.h
@@ -77,6 +77,7 @@ long sys_s390_runtime_instr(int command,
 long sys_s390_guarded_storage(int command, struct gs_cb __user *);
 long sys_s390_pci_mmio_write(unsigned long, const void __user *, size_t);
 long sys_s390_pci_mmio_read(unsigned long, void __user *, size_t);
+long sys_s390_sthyi(unsigned long function_code, void __user *buffer, u64 __user *return_code, unsigned long flags);
 
 DECLARE_PER_CPU(u64, mt_cycles[8]);
 
--- a/arch/s390/kernel/sthyi.c
+++ b/arch/s390/kernel/sthyi.c
@@ -11,13 +11,16 @@
 #include <linux/errno.h>
 #include <linux/pagemap.h>
 #include <linux/vmalloc.h>
-
+#include <linux/syscalls.h>
+#include <linux/mutex.h>
 #include <asm/asm-offsets.h>
 #include <asm/sclp.h>
 #include <asm/diag.h>
 #include <asm/sysinfo.h>
 #include <asm/ebcdic.h>
 #include <asm/facility.h>
+#include <asm/sthyi.h>
+#include "entry.h"
 
 #define DED_WEIGHT 0xffff
 /*
@@ -484,3 +487,31 @@ out:
 	return r;
 }
 EXPORT_SYMBOL_GPL(sthyi_fill);
+
+SYSCALL_DEFINE4(s390_sthyi, unsigned long, function_code, void __user *, buffer,
+		u64 __user *, return_code, unsigned long, flags)
+{
+	u64 sthyi_rc;
+	void *info;
+	int r;
+
+	if (flags)
+		return -EINVAL;
+	if (function_code != STHYI_FC_CP_IFL_CAP)
+		return -EOPNOTSUPP;
+	info = (void *)get_zeroed_page(GFP_KERNEL);
+	if (!info)
+		return -ENOMEM;
+	r = sthyi_fill(info, &sthyi_rc);
+	if (r < 0)
+		goto out;
+	if (return_code && put_user(sthyi_rc, return_code)) {
+		r = -EFAULT;
+		goto out;
+	}
+	if (copy_to_user(buffer, info, PAGE_SIZE))
+		r = -EFAULT;
+out:
+	free_page((unsigned long)info);
+	return r;
+}
--- a/arch/s390/kernel/syscalls.S
+++ b/arch/s390/kernel/syscalls.S
@@ -388,3 +388,4 @@ SYSCALL(sys_preadv2,compat_sys_preadv2)
 SYSCALL(sys_pwritev2,compat_sys_pwritev2)
 SYSCALL(sys_s390_guarded_storage,compat_sys_s390_guarded_storage) /* 378 */
 SYSCALL(sys_statx,compat_sys_statx)
+SYSCALL(sys_s390_sthyi,compat_sys_s390_sthyi)
