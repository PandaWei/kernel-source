From: Sebastian Ott <sebott@linux.ibm.com>
Subject: s390/cio: update chpid descriptor after resource accessibility event
Patch-mainline: v4.17-rc3
Git-commit: af2e460ade0b0180d0f3812ca4f4f59cc9597f3e
References: bnc#1091659, LTC#167429

Description:  s390/cio: update chpid descriptor after event
Symptom:      Unused channel paths after HW maintenance.
Problem:      Stale channel path descriptors.
Solution:     Update channel path descriptors.
Reproduction: -

Upstream-Description:

              s390/cio: update chpid descriptor after resource accessibility event

              Channel path descriptors have been seen as something stable (as
              long as the chpid is configured). Recent tests have shown that the
              descriptor can also be altered when the link state of a channel path
              changes. Thus it is necessary to update the descriptor during
              handling of resource accessibility events.

              Cc: <stable@vger.kernel.org>
              Signed-off-by: Sebastian Ott <sebott@linux.ibm.com>
              Reviewed-by: Peter Oberparleiter <oberpar@linux.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Sebastian Ott <sebott@linux.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/s390/cio/chsc.c |   14 +++++++++++---
 1 file changed, 11 insertions(+), 3 deletions(-)

--- a/drivers/s390/cio/chsc.c
+++ b/drivers/s390/cio/chsc.c
@@ -310,6 +310,7 @@ static void chsc_process_sei_link_incide
 
 static void chsc_process_sei_res_acc(struct chsc_sei_nt0_area *sei_area)
 {
+	struct channel_path *chp;
 	struct chp_link link;
 	struct chp_id chpid;
 	int status;
@@ -322,10 +323,17 @@ static void chsc_process_sei_res_acc(str
 	chpid.id = sei_area->rsid;
 	/* allocate a new channel path structure, if needed */
 	status = chp_get_status(chpid);
-	if (status < 0)
-		chp_new(chpid);
-	else if (!status)
+	if (!status)
 		return;
+
+	if (status < 0) {
+		chp_new(chpid);
+	} else {
+		chp = chpid_to_chp(chpid);
+		mutex_lock(&chp->lock);
+		chp_update_desc(chp);
+		mutex_unlock(&chp->lock);
+	}
 	memset(&link, 0, sizeof(struct chp_link));
 	link.chpid = chpid;
 	if ((sei_area->vf & 0xc0) != 0) {
