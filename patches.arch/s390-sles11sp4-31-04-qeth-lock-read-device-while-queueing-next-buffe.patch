From: Julian Wiedmann <jwi@linux.ibm.com>
Subject: s390/qeth: lock read device while queueing next buffer
Patch-mainline: v4.16-rc7
Git-commit: 17bf8c9b3d499d5168537c98b61eb7a1fcbca6c2
References: bnc#1099709, LTC#169019

Description:  qeth: lock read device while queueing next buffer
Symptom:      Random IO misbehaviour on qeth's READ device.
Problem:      qeth_mpc_initialize() calls issue_next_read() to queue
              the first pending READ buffer for incoming MPC traffic.
              This calls ccw_device_start() without holding the
              ccw device's lock.
Solution:     Add the necessary locking.
Reproduction: -

Upstream-Description:

              s390/qeth: lock read device while queueing next buffer

              For calling ccw_device_start(), issue_next_read() needs to hold the
              device's ccwlock.
              This is satisfied for the IRQ handler path (where qeth_irq() gets called
              under the ccwlock), but we need explicit locking for the initial call by
              the MPC initialization.

              Signed-off-by: Julian Wiedmann <jwi@linux.vnet.ibm.com>
              Signed-off-by: David S. Miller <davem@davemloft.net>


Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/s390/net/qeth_core_main.c |   17 +++++++++++++----
 1 file changed, 13 insertions(+), 4 deletions(-)

--- a/drivers/s390/net/qeth_core_main.c
+++ b/drivers/s390/net/qeth_core_main.c
@@ -54,7 +54,6 @@ static struct mutex qeth_mod_mutex;
 
 static void qeth_send_control_data_cb(struct qeth_channel *,
 			struct qeth_cmd_buffer *);
-static int qeth_issue_next_read(struct qeth_card *);
 static struct qeth_cmd_buffer *qeth_get_buffer(struct qeth_channel *);
 static void qeth_setup_ccw(struct qeth_channel *, unsigned char *, __u32);
 static void qeth_free_buffer_pool(struct qeth_card *);
@@ -489,8 +488,7 @@ static inline int qeth_is_cq(struct qeth
 	    queue == card->qdio.no_in_queues - 1;
 }
 
-
-static int qeth_issue_next_read(struct qeth_card *card)
+static int __qeth_issue_next_read(struct qeth_card *card)
 {
 	int rc;
 	struct qeth_cmd_buffer *iob;
@@ -521,6 +519,17 @@ static int qeth_issue_next_read(struct q
 	return rc;
 }
 
+static int qeth_issue_next_read(struct qeth_card *card)
+{
+	int ret;
+
+	spin_lock_irq(get_ccwdev_lock(CARD_RDEV(card)));
+	ret = __qeth_issue_next_read(card);
+	spin_unlock_irq(get_ccwdev_lock(CARD_RDEV(card)));
+
+	return ret;
+}
+
 static struct qeth_reply *qeth_alloc_reply(struct qeth_card *card)
 {
 	struct qeth_reply *reply;
@@ -1132,7 +1141,7 @@ static void qeth_irq(struct ccw_device *
 		return;
 	if (channel == &card->read &&
 	    channel->state == CH_STATE_UP)
-		qeth_issue_next_read(card);
+		__qeth_issue_next_read(card);
 
 	iob = channel->iob;
 	index = channel->buf_no;
