From 5eb3f7cb759dd5746b9be5fc7523761829b26048 Mon Sep 17 00:00:00 2001
From: Michael Bringmann <mwb@linux.vnet.ibm.com>
Date: Sun, 29 Jul 2018 08:19:28 -0500
Subject: [PATCH 4/5] mobility/numa: Ensure numa update does not overlap

References: FATE#325308
Patch-mainline: submitted https://patchwork.ozlabs.org/cover/950609/

mobility/numa: Ensure that numa_update_cpu_topology() can not be
entered multiple times concurrently.  It may be accessed through
many different paths through the code.  Without some protection
against multiple entry, the code may acquire and update associativity
information from the PHYP in multiple threads, and apply changes
separately in each thread.  Applying the changes concurrently may
perform considerable work multiple times, but more importantly,
may acquire locks in other modules concurrently and end up blocking
each of the competing threads.  This patch allows only the first
entrant to the code to execute the operation and to recognize any
CPU topology changes.

Signed-off-by: Michael Bringmann <mwb@linux.vnet.ibm.com>
Acked-by: Michal Suchanek <msuchanek@suse.de>
---
 arch/powerpc/mm/numa.c | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/arch/powerpc/mm/numa.c b/arch/powerpc/mm/numa.c
index 5a0a09fbb134..833beb84052a 100644
--- a/arch/powerpc/mm/numa.c
+++ b/arch/powerpc/mm/numa.c
@@ -1072,6 +1072,7 @@ static int prrn_enabled;
 static void reset_topology_timer(void);
 static int topology_timer_secs = 1;
 static int topology_inited;
+static struct mutex topology_update_lock;
 
 /*
  * Change polling interval for associativity changes.
@@ -1310,6 +1311,11 @@ int numa_update_cpu_topology(bool cpus_locked)
 	if (!updates)
 		return 0;
 
+	if (!mutex_trylock(&topology_update_lock)) {
+		kfree(updates);
+		return 0;
+	}
+
 	cpumask_clear(&updated_cpus);
 
 	for_each_cpu(cpu, &cpu_associativity_changes_mask) {
@@ -1413,6 +1419,7 @@ int numa_update_cpu_topology(bool cpus_locked)
 
 out:
 	kfree(updates);
+	mutex_unlock(&topology_update_lock);
 	return changed;
 }
 
@@ -1597,6 +1604,8 @@ static const struct file_operations topology_ops = {
 
 static int topology_update_init(void)
 {
+	mutex_init(&topology_update_lock);
+
 	/* Do not poll for changes if disabled at boot */
 	if (topology_updates_enabled)
 		start_topology_update();
-- 
2.13.7

