From: Andi Kleen <ak@linux.intel.com>
Date: Thu, 25 Jan 2018 15:50:28 -0800
Subject: [PATCH 1/2] module/retpoline: Warn about missing retpoline in module
Git-commit: caf7501a1b4ec964190f31f9c3f163de252273b8
References: bnc#1099177
Patch-mainline: v4.16-rc1

There's a risk that a kernel which has full retpoline mitigations becomes
vulnerable when a module gets loaded that hasn't been compiled with the
right compiler or the right option.

To enable detection of that mismatch at module load time, add a module info
string "retpoline" at build time when the module was compiled with
retpoline support. This only covers compiled C source, but assembler source
or prebuilt object files are not checked.

If a retpoline enabled kernel detects a non retpoline protected module at
load time, print a warning and report it in the sysfs vulnerability file.

[ tglx: Massaged changelog ]

Signed-off-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Cc: David Woodhouse <dwmw2@infradead.org>
Cc: gregkh@linuxfoundation.org
Cc: torvalds@linux-foundation.org
Cc: jeyu@kernel.org
Cc: arjan@linux.intel.com
Link: https://lkml.kernel.org/r/20180125235028.31211-1-andi@firstfloor.org
Signed-off-by: Josef Cejka <jcejka@suse.com>

---
 arch/x86/kernel/cpu/bugs.c | 23 ++++++++++++++++++++---
 include/linux/module.h     |  9 +++++++++
 kernel/module.c            | 11 +++++++++++
 scripts/mod/modpost.c      |  9 +++++++++
 4 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c
index d85e06aa9db2..006c91468304 100644
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -11,6 +11,7 @@
 #include <linux/utsname.h>
 #include <linux/device.h>
 #include <linux/prctl.h>
+#include <linux/module.h>
 
 #include <asm/nospec-branch.h>
 #include <asm/spec_ctrl.h>
@@ -286,6 +287,19 @@ static const char *spectre_v2_strings[] = {
 #define pr_fmt(fmt)     "Spectre V2 mitigation: " fmt
 
 static enum spectre_v2_mitigation spectre_v2_enabled = SPECTRE_V2_NONE;
+static bool spectre_v2_bad_module;
+
+#ifdef RETPOLINE
+bool retpoline_module_ok(bool has_retpoline)
+{
+	if (spectre_v2_enabled == SPECTRE_V2_NONE || has_retpoline)
+		return true;
+
+	pr_err("System may be vunerable to spectre v2\n");
+	spectre_v2_bad_module = true;
+	return false;
+}
+#endif
 
 static const __initconst struct x86_cpu_id cpu_no_spec_store_bypass[] = {
         { X86_VENDOR_INTEL,	6,	INTEL_FAM6_ATOM_PINEVIEW	},
@@ -762,13 +776,16 @@ ssize_t cpu_show_spectre_v2(struct device *dev,
 		return sprintf(buf, "Not affected\n");
 
 	if (boot_cpu_has(X86_FEATURE_SPEC_CTRL) && x86_ibrs_enabled()) {
-		return sprintf(buf, "Mitigation: IBRS+IBPB\n");
+		return sprintf(buf, "Mitigation: IBRS+IBPB%s\n",
+			spectre_v2_bad_module ? " - vulnerable module loaded" : "");
 	}
 
 	if (x86_ibpb_enabled())
-		return sprintf(buf, "%s + IBPB\n", spectre_v2_strings[spectre_v2_enabled]);
+		return sprintf(buf, "%s + IBPB%s\n", spectre_v2_strings[spectre_v2_enabled],
+			spectre_v2_bad_module ? " - vulnerable module loaded" : "");
 	else
-		return sprintf(buf, "%s\n", spectre_v2_strings[spectre_v2_enabled]);
+		return sprintf(buf, "%s%s\n", spectre_v2_strings[spectre_v2_enabled],
+			spectre_v2_bad_module ? " - vulnerable module loaded" : "");
 }
 
 ssize_t __weak cpu_show_spec_store_bypass(struct device *dev,
diff --git a/include/linux/module.h b/include/linux/module.h
index 1aa371db2c8b..fe5d4236dca1 100644
--- a/include/linux/module.h
+++ b/include/linux/module.h
@@ -767,6 +767,15 @@ static inline void module_bug_finalize(const Elf_Ehdr *hdr,
 static inline void module_bug_cleanup(struct module *mod) {}
 #endif	/* CONFIG_GENERIC_BUG */
 
+#ifdef RETPOLINE
+extern bool retpoline_module_ok(bool has_retpoline);
+#else
+static inline bool retpoline_module_ok(bool has_retpoline)
+{
+	return true;
+}
+#endif
+
 static inline void taint_unsupported(void)
 {
 #ifdef CONFIG_ENTERPRISE_SUPPORT
diff --git a/kernel/module.c b/kernel/module.c
index 5f3a8cec9bb5..10bd9dacf8fc 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2461,6 +2461,15 @@ static int module_sig_check(struct load_info *info,
 }
 #endif /* !CONFIG_MODULE_SIG */
 
+static void check_modinfo_retpoline(struct module *mod, struct load_info *info)
+{
+	if (retpoline_module_ok(get_modinfo(info, "retpoline")))
+		return;
+
+	pr_warn("%s: loading module not compiled with retpoline compiler.\n",
+		mod->name);
+}
+
 /* Sets info->hdr, info->len and info->sig_ok. */
 static int copy_and_check(struct load_info *info,
 			  const void __user *umod, unsigned long len,
@@ -2624,6 +2633,8 @@ static int check_modinfo(struct module *mod, struct load_info *info)
 		return -ENOEXEC;
 	}
 
+	check_modinfo_retpoline(mod, info);
+
 	if (get_modinfo(info, "staging")) {
 		add_taint_module(mod, TAINT_CRAP);
 		printk(KERN_WARNING "%s: module is from the staging directory,"
diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c
index e063b44dffee..7cf3a04c09f8 100644
--- a/scripts/mod/modpost.c
+++ b/scripts/mod/modpost.c
@@ -1947,6 +1947,14 @@ static void add_header(struct buffer *b, struct module *mod)
 	buf_printf(b, "};\n");
 }
 
+/* Cannot check for assembler */
+static void add_retpoline(struct buffer *b)
+{
+	buf_printf(b, "\n#ifdef RETPOLINE\n");
+	buf_printf(b, "MODULE_INFO(retpoline, \"Y\");\n");
+	buf_printf(b, "#endif\n");
+}
+
 static void add_staging_flag(struct buffer *b, const char *name)
 {
 	static const char *staging_dir = "drivers/staging";
@@ -2287,6 +2295,7 @@ int main(int argc, char **argv)
 		buf.pos = 0;
 
 		add_header(&buf, mod);
+		add_retpoline(&buf);
 		add_staging_flag(&buf, mod->name);
 		add_supported_flag(&buf, mod);
 		err |= add_versions(&buf, mod);
-- 
2.13.7

