From 78eb304735e3d586cae24c6e502097131e02cccf Mon Sep 17 00:00:00 2001
From: David Howells <dhowells@redhat.com>
Date: Wed, 5 Apr 2017 17:40:30 +0100
Subject: [PATCH 1/5] Enforce module signatures if the kernel is locked down
Patch-mainline: No, submitted https://patchwork.kernel.org/patch/9664927/
References: bsc#1093666, fate#314486

If the kernel is locked down, require that all modules have valid
signatures that we can verify.

[ modified according to this proposed change: https://lkml.org/lkml/2018/2/22/359 ]

It adjusts the errors generated:

 (1) If there's no signature (ENODATA) or we can't check it (ENOPKG, ENOKEY),
     then:

     (a) If signatures are enforced then EKEYREJECTED is returned.

     (b) If IMA will have validated the image, return 0 (okay).

     (c) If there's no signature or we can't check it, but the kernel is
	 locked down then EPERM is returned (this is then consistent with
	 other lockdown cases).

 (2) If the signature is unparseable (EBADMSG, EINVAL), the signature fails
     the check (EKEYREJECTED) or a system error occurs (eg. ENOMEM), we return
     the error we got.

Note that the X.509 code doesn't check for key expiry as the RTC might not be
valid or might not have been transferred to the kernel's clock yet.

Jessica Yu:
This patch was taken + adapted from SLE15. It was needed because SLE11
doesn't log errors in module_sig_check() at all. Also, SLE15 lock down
patchset differentiates sig_enforce from kernel lock down, but SLE11
doesn't, so the patch was slightly modified to account for that.

Signed-off-by: David Howells <dhowells@redhat.com>
Acked-by: Jiri Bohac <jbohac@suse.cz>
Acked-by: Jessica Yu <jeyu@suse.de>
---
 kernel/module.c | 37 ++++++++++++++++++++++++++++++-------
 1 file changed, 30 insertions(+), 7 deletions(-)

diff --git a/kernel/module.c b/kernel/module.c
index 10bd9dacf8fc..d6963b48b514 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2431,9 +2431,10 @@ static inline void kmemleak_load_module(const struct module *mod,
 static int module_sig_check(struct load_info *info,
 			    const void *mod, unsigned long *_len)
 {
-	int err = -ENOKEY;
+	int err = -ENODATA;
 	unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	unsigned long len = *_len;
+	const char *reason;
 
 	if (len > markerlen &&
 	    memcmp(mod + len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
@@ -2442,16 +2443,38 @@ static int module_sig_check(struct load_info *info,
 		err = mod_verify_sig(mod, _len, !sig_check && !sig_enforce);
 	}
 
-	if (!err) {
+	switch (err) {
+	case 0:
 		info->sig_ok = true;
 		return 0;
-	}
 
-	/* Not having a signature is only an error if we're strict. */
-	if (err == -ENOKEY && !sig_enforce)
-		err = 0;
+		/* We don't permit modules to be loaded into trusted kernels
+		 * without a valid signature on them, but if we're not
+		 * enforcing, certain errors are non-fatal.
+		 */
+	case -ENODATA:
+		reason = "Loading of unsigned module";
+		goto decide;
+	case -ENOPKG:
+		reason = "Loading of module with unsupported crypto";
+		goto decide;
+	case -ENOKEY:
+		reason = "Loading of module with unavailable key";
+	decide:
+		if (secure_modules()) {
+			pr_notice("%s is rejected\n", reason);
+			return -EKEYREJECTED;
+		}
+		return 0;
+
+		/* All other errors are fatal, including nomem, unparseable
+		 * signatures and signature check failures - even if signatures
+		 * aren't required.
+		 */
+	default:
+		return err;
+	}
 
-	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
 static int module_sig_check(struct load_info *info,
-- 
2.16.4

