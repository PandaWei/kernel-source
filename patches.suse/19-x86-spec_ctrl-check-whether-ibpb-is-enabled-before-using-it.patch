From: Borislav Petkov <bp@suse.de>
Date: Sun, 17 Dec 2017 16:01:57 +0100
Subject: x86/spec_ctrl: Check whether IBPB is enabled before using it
Patch-mainline: submitted on 2018/1/9
References: bsc#1068032

Check whether IBPB is enabled before using it.

Carved out from a patch by Tim Chen <tim.c.chen@linux.intel.com>

Signed-off-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/include/asm/nospec-branch.h |    5 ++++-
 arch/x86/include/asm/spec_ctrl.h     |    1 +
 arch/x86/kernel/cpu/spec_ctrl.c      |    7 +++++++
 3 files changed, 12 insertions(+), 1 deletion(-)

--- a/arch/x86/include/asm/nospec-branch.h
+++ b/arch/x86/include/asm/nospec-branch.h
@@ -214,11 +214,14 @@ void alternative_msr_write(unsigned int
 		: "memory");
 }
 
+unsigned int x86_ibpb_enabled(void);
+
 static inline void indirect_branch_prediction_barrier(void)
 {
 	u64 val = PRED_CMD_IBPB;
 
-	alternative_msr_write(MSR_IA32_PRED_CMD, val, X86_FEATURE_USE_IBPB);
+	if (x86_ibpb_enabled())
+		alternative_msr_write(MSR_IA32_PRED_CMD, val, X86_FEATURE_USE_IBPB);
 }
 
 /* The Intel SPEC CTRL MSR base value cache */
--- a/arch/x86/include/asm/spec_ctrl.h
+++ b/arch/x86/include/asm/spec_ctrl.h
@@ -90,5 +90,6 @@
 void x86_enable_ibrs(void);
 void x86_disable_ibrs(void);
 unsigned int x86_ibrs_enabled(void);
+unsigned int x86_ibpb_enabled(void);
 #endif /* __ASSEMBLY__ */
 #endif /* _ASM_X86_SPEC_CTRL_H */
--- a/arch/x86/kernel/cpu/spec_ctrl.c
+++ b/arch/x86/kernel/cpu/spec_ctrl.c
@@ -11,6 +11,7 @@
  * Keep it open for more flags in case needed.
  */
 static unsigned int ibrs_state = 0;
+static unsigned int ibpb_state = 0;
 
 unsigned int notrace x86_ibrs_enabled(void)
 {
@@ -18,6 +19,12 @@ unsigned int notrace x86_ibrs_enabled(vo
 }
 EXPORT_SYMBOL_GPL(x86_ibrs_enabled);
 
+unsigned int notrace x86_ibpb_enabled(void)
+{
+	return ibpb_state;
+}
+EXPORT_SYMBOL_GPL(x86_ibpb_enabled);
+
 void x86_disable_ibrs(void)
 {
 	if (x86_ibrs_enabled())
