From d07afc54b928876e1efbdb7fd2e009c6c118a506 Mon Sep 17 00:00:00 2001
From: Jessica Yu <jeyu@kernel.org>
Date: Fri, 17 Aug 2018 15:07:51 +0200
Subject: [PATCH 3/5] module: setup load info before module_sig_check()
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: https://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux.git
Git-commit: 5fdc7db6448a4f558f298b1c98d6d124fdf2ad95
References: bsc#1093666

We want to be able to log the module name in early error messages, such as
when module signature verification fails.  Previously, the module name is
set in layout_and_allocate(), meaning that any error messages that happen
before (such as those in module_sig_check()) won't be logged with a module
name, which isn't terribly helpful.

In order to do this, reshuffle the order in load_module() and set up
load info earlier so that we can log the module name along with these
error messages. This requires splitting rewrite_section_headers() out of
setup_load_info().

While we're at it, clean up and split up the operations done in
layout_and_allocate(), setup_load_info(), and rewrite_section_headers()
more cleanly so these functions only perform what their names suggest.

Signed-off-by: Jessica Yu <jeyu@kernel.org>
Acked-by: Jessica Yu <jeyu@suse.de>
---
 kernel/module.c |   64 +++++++++++++++++++++++++++++---------------------------
 1 file changed, 34 insertions(+), 30 deletions(-)

--- a/kernel/module.c
+++ b/kernel/module.c
@@ -2170,7 +2170,11 @@ static char *get_modinfo(struct load_inf
 	Elf_Shdr *infosec = &info->sechdrs[info->index.info];
 	unsigned long size = infosec->sh_size;
 
-	for (p = (char *)infosec->sh_addr; p; p = next_string(p, &size)) {
+	/*
+	 * get_modinfo() calls made before rewrite_section_headers()
+	 * must use sh_offset, as sh_addr isn't set!
+	 */
+	for (p = (char *)info->hdr + infosec->sh_offset; p; p = next_string(p, &size)) {
 		if (strncmp(p, tag, taglen) == 0 && p[taglen] == '=')
 			return p + taglen + 1;
 	}
@@ -2486,7 +2490,7 @@ static int module_sig_check(struct load_
 }
 #endif /* !CONFIG_MODULE_SIG */
 
-/* Sets info->hdr, info->len and info->sig_ok. */
+/* Sets info->hdr and info->len */
 static int copy_and_check(struct load_info *info,
 			  const void __user *umod, unsigned long len,
 			  const char __user *uargs)
@@ -2506,10 +2510,6 @@ static int copy_and_check(struct load_in
 		goto free_hdr;
 	}
 
-	err = module_sig_check(info, hdr, &len);
-	if (err)
-		goto free_hdr;
-
 	/* Sanity checks against insmoding binaries or wrong arch,
 	   weird elf version */
 	if (memcmp(hdr->e_ident, ELFMAG, SELFMAG) != 0
@@ -2567,8 +2567,6 @@ static int rewrite_section_headers(struc
 	}
 
 	/* Track but don't keep modinfo and version sections. */
-	info->index.vers = find_sec(info, "__versions");
-	info->index.info = find_sec(info, ".modinfo");
 	info->sechdrs[info->index.info].sh_flags &= ~(unsigned long)SHF_ALLOC;
 	info->sechdrs[info->index.vers].sh_flags &= ~(unsigned long)SHF_ALLOC;
 	return 0;
@@ -2585,16 +2583,19 @@ static int rewrite_section_headers(struc
 static int setup_load_info(struct load_info *info)
 {
 	unsigned int i;
-	int err;
 
 	/* Set up the convenience variables */
 	info->sechdrs = (void *)info->hdr + info->hdr->e_shoff;
 	info->secstrings = (void *)info->hdr
 		+ info->sechdrs[info->hdr->e_shstrndx].sh_offset;
 
-	err = rewrite_section_headers(info);
-	if (err)
-		return err;
+	info->index.mod = find_sec(info, ".gnu.linkonce.this_module");
+	if (!info->index.mod) {
+		printk(KERN_WARNING "No module found in object\n");
+		return -ENOEXEC;
+	}
+	/* This is temporary: point mod into copy of data. */
+	info->mod = (void *)info->hdr + info->sechdrs[info->index.mod].sh_offset;
 
 	/* Find internal symbols and strings. */
 	for (i = 1; i < info->hdr->e_shnum; i++) {
@@ -2607,28 +2608,17 @@ static int setup_load_info(struct load_i
 		}
 	}
 
-	info->index.mod = find_sec(info, ".gnu.linkonce.this_module");
-	if (!info->index.mod) {
-		printk(KERN_WARNING "No module found in object\n");
-		return -ENOEXEC;
-	}
-	/* This is temporary: point mod into copy of data. */
-	info->mod = (void *)info->sechdrs[info->index.mod].sh_addr;
-
 	if (info->index.sym == 0) {
 		printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",
 		       info->mod->name);
 		return -ENOEXEC;
 	}
 
+	info->index.vers = find_sec(info, "__versions");
+	info->index.info = find_sec(info, ".modinfo");
 	info->index.pcpu = find_pcpusec(info);
-
 	info->index.unwind = find_unwind(info);
 
-	/* Check module struct version now, before we try to use module. */
-	if (!check_modstruct_version(info->sechdrs, info->index.vers, info->mod))
-		return -ENOEXEC;
-
 	return 0;
 }
 
@@ -2867,10 +2857,6 @@ static struct module *layout_and_allocat
 	Elf_Shdr *pcpusec;
 	int err;
 
-	err = setup_load_info(info);
-	if (err)
-		return ERR_PTR(err);
-
 	err = check_modinfo(info->mod, info);
 	if (err)
 		return ERR_PTR(err);
@@ -2955,7 +2941,7 @@ static struct module *load_module(void _
 {
 	struct load_info info = { NULL, };
 	struct module *mod;
-	long err;
+	long err = 0;
 
 	DEBUGP("load_module: umod=%p, len=%lu, uargs=%p\n",
 	       umod, len, uargs);
@@ -2965,6 +2951,24 @@ static struct module *load_module(void _
 	if (err)
 		return ERR_PTR(err);
 
+	err = setup_load_info(&info);
+	if (err)
+		goto free_copy;
+
+	err = module_sig_check(&info, info.hdr, &info.len);
+	if (err)
+		goto free_copy;
+
+	err = rewrite_section_headers(&info);
+	if (err)
+		goto free_copy;
+
+	/* Check module struct version now, before we try to use module. */
+	if (!check_modstruct_version(info.sechdrs, info.index.vers, info.mod)) {
+		err = -ENOEXEC;
+		goto free_copy;
+	}
+
 	/* Figure out module layout, and allocate all the memory. */
 	mod = layout_and_allocate(&info);
 	if (IS_ERR(mod)) {
