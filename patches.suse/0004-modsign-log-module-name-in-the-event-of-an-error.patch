From c86919b745ecf6dd88031918aa3b020c3e3baa7a Mon Sep 17 00:00:00 2001
From: Jessica Yu <jeyu@kernel.org>
Date: Fri, 17 Aug 2018 16:08:51 +0200
Subject: [PATCH 4/5] modsign: log module name in the event of an error
Patch-mainline: Queued in subsystem maintainer repository
Git-repo: https://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux.git
Git-commit: f314dfea16a085a58d2ff227ea9fa9e490ee5d18
References: bsc#1093666

Now that we have the load_info struct all initialized (including
info->name, which contains the name of the module) before
module_sig_check(), make the load_info struct and hence module name
available to mod_verify_sig() so that we can log the module name in the
event of an error.

Signed-off-by: Jessica Yu <jeyu@kernel.org>
Acked-by: Jessica Yu <jeyu@suse.de>
---
 kernel/module-internal.h |   22 +++++++++++++++++++++-
 kernel/module.c          |   32 +++++++-------------------------
 kernel/module_signing.c  |   11 +++++++----
 3 files changed, 35 insertions(+), 30 deletions(-)

--- a/kernel/module-internal.h
+++ b/kernel/module-internal.h
@@ -9,6 +9,26 @@
  * 2 of the Licence, or (at your option) any later version.
  */
 
+#include <linux/elf.h>
+#include <asm/module.h>
+
 extern struct key *modsign_keyring;
 
-extern int mod_verify_sig(const void *mod, unsigned long *_modlen, bool truncate_only);
+struct load_info {
+	/* pointer to module in temporary copy, freed at end of load_module() */
+	struct module *mod;
+	Elf_Ehdr *hdr;
+	unsigned long len;
+	Elf_Shdr *sechdrs;
+	char *secstrings, *strtab;
+	unsigned long *strmap;
+	unsigned long symoffs, stroffs;
+	struct _ddebug *debug;
+	unsigned int num_debug;
+	bool sig_ok;
+	struct {
+		unsigned int sym, str, mod, vers, info, pcpu, unwind;
+	} index;
+};
+
+extern int mod_verify_sig(const void *mod, struct load_info *info, bool truncate_only);
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -197,23 +197,6 @@ int unregister_module_notifier(struct no
 }
 EXPORT_SYMBOL(unregister_module_notifier);
 
-struct load_info {
-	/* pointer to module in temporary copy, freed at end of load_module() */
-	struct module *mod;
-	Elf_Ehdr *hdr;
-	unsigned long len;
-	Elf_Shdr *sechdrs;
-	char *secstrings, *strtab;
-	unsigned long *strmap;
-	unsigned long symoffs, stroffs;
-	struct _ddebug *debug;
-	unsigned int num_debug;
-	bool sig_ok;
-	struct {
-		unsigned int sym, str, mod, vers, info, pcpu, unwind;
-	} index;
-};
-
 /* We require a truly strong try_module_get(): 0 means failure due to
    ongoing or failed initialization etc. */
 static inline int strong_try_module_get(struct module *mod)
@@ -2434,19 +2417,19 @@ static inline void kmemleak_load_module(
 #endif
 
 #ifdef CONFIG_MODULE_SIG
-static int module_sig_check(struct load_info *info,
-			    const void *mod, unsigned long *_len)
+static int module_sig_check(struct load_info *info)
 {
 	int err = -ENODATA;
 	unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
-	unsigned long len = *_len;
+	unsigned long len = info->len;
 	const char *reason;
+	const void *mod = info->hdr;
 
 	if (len > markerlen &&
 	    memcmp(mod + len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
-		*_len -= markerlen;
-		err = mod_verify_sig(mod, _len, !sig_check && !sig_enforce);
+		info->len -= markerlen;
+		err = mod_verify_sig(mod, info, !sig_check && !sig_enforce);
 	}
 
 	switch (err) {
@@ -2483,8 +2466,7 @@ static int module_sig_check(struct load_
 
 }
 #else /* !CONFIG_MODULE_SIG */
-static int module_sig_check(struct load_info *info,
-			    void *mod, unsigned long *len)
+static int module_sig_check(struct load_info *info)
 {
 	return 0;
 }
@@ -2955,7 +2937,7 @@ static struct module *load_module(void _
 	if (err)
 		goto free_copy;
 
-	err = module_sig_check(&info, info.hdr, &info.len);
+	err = module_sig_check(&info);
 	if (err)
 		goto free_copy;
 
--- a/kernel/module_signing.c
+++ b/kernel/module_signing.c
@@ -184,13 +184,13 @@ static struct key *request_asymmetric_ke
 /*
  * Verify the signature on a module.
  */
-int mod_verify_sig(const void *mod, unsigned long *_modlen, bool truncate_only)
+int mod_verify_sig(const void *mod, struct load_info *info, bool truncate_only)
 {
 	struct public_key_signature *pks;
 	struct module_signature ms;
 	struct key *key;
 	const void *sig;
-	size_t modlen = *_modlen, sig_len;
+	size_t modlen = info->len, sig_len;
 	int ret;
 
 	pr_devel("==>%s(,%zu)\n", __func__, modlen);
@@ -209,7 +209,7 @@ int mod_verify_sig(const void *mod, unsi
 		return -EBADMSG;
 	modlen -= (size_t)ms.signer_len + ms.key_id_len;
 
-	*_modlen = modlen;
+	info->len = modlen;
 	if (truncate_only)
 		return 0;
 
@@ -217,8 +217,11 @@ int mod_verify_sig(const void *mod, unsi
 
 	/* For the moment, only support RSA and X.509 identifiers */
 	if (ms.algo != PKEY_ALGO_RSA ||
-	    ms.id_type != PKEY_ID_X509)
+	    ms.id_type != PKEY_ID_X509) {
+		printk(KERN_ERR "%s: Module signed with unsupported crypto\n",
+		       info->mod->name);
 		return -ENOPKG;
+	}
 
 	if (ms.hash >= PKEY_HASH__LAST ||
 	    !pkey_hash_algo[ms.hash])
