From d1ea2f287f28d1aeaa2da8b615a26a591f156483 Mon Sep 17 00:00:00 2001
From: Nikolay Borisov <nborisov@suse.com>
Date: Mon, 18 Jun 2018 11:24:52 +0300
Subject: [PATCH] jfs: Fix buffer overrun in ea_get
References: bsc#1097234, CVE-2018-12233
Patch-mainline: Submitted, 18.06.2018 lkml

Currently ea_buf->xattr buffer is allocated with min(min_size, ea_size).
This is wrong since after the xattr buffer is allocated the ->max_size
variable is actually rounded up to th next ->s_blocksize size. Fix this
by using the rounded up max_size as input to the malloc.

Suggested-by: Shankara Pailoor <shankarapailoor@gmail.com>
Reported-by: Shankara Pailoor <shankarapailoor@gmail.com>
Signed-off-by: Nikolay Borisov <nborisov@suse.com>
---
 fs/jfs/xattr.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/fs/jfs/xattr.c b/fs/jfs/xattr.c
index c60f3d32ee91..96b9355ff69a 100644
--- a/fs/jfs/xattr.c
+++ b/fs/jfs/xattr.c
@@ -493,14 +493,14 @@ static int ea_get(struct inode *inode, struct ea_buffer *ea_buf, int min_size)
 		 * To keep the rest of the code simple.  Allocate a
 		 * contiguous buffer to work with
 		 */
-		ea_buf->xattr = kmalloc(size, GFP_KERNEL);
-		if (ea_buf->xattr == NULL)
-			return -ENOMEM;
-
 		ea_buf->flag = EA_MALLOC;
 		ea_buf->max_size = (size + sb->s_blocksize - 1) &
 		    ~(sb->s_blocksize - 1);
 
+		ea_buf->xattr = kmalloc(ea_buf->max_size, GFP_KERNEL);
+		if (ea_buf->xattr == NULL)
+			return -ENOMEM;
+
 		if (ea_size == 0)
 			return 0;
 
-- 
2.7.4

