From: Jiri Kosina <jkosina@suse.cz>
Subject: [PATCH] x86/fpu: fix signal handling with eager FPU switching
References: bsc#1100091
Patch-mainline: Never, SUSE-specific implementation

[ this is actually losely related to upstream commit 377ffbcc53 ]

With eager FPU switching, we don't want signal handlers to clear
tsk->thread.has_fpu, as that'd make switch_fpu_prepare() stop from
saving the state on a context switch during preemption, leading to
corrupted FPU states in cases where signal handler utilizing FPU math
gets preempted in userspace before xstate would have chance to be
properly restored during sigreturn.
Debugged by Nicolai Stange.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
---
 arch/x86/kernel/i387.c  |   13 ++++++++++++-
 arch/x86/kernel/xsave.c |    7 ++++++-
 2 files changed, 18 insertions(+), 2 deletions(-)

--- a/arch/x86/kernel/i387.c
+++ b/arch/x86/kernel/i387.c
@@ -593,7 +593,18 @@ int save_i387_xstate_ia32(void __user *b
 				       NULL, fp) ? -1 : 1;
 	}
 
-	unlazy_fpu(tsk);
+	/*
+	 * We can't unlazy_fpu() here directly, as __thread_fpu_end() must not
+	 * be called in eager FPU mode, as we want switch_fpu_prepare() keep
+	 * saving the state
+	 */
+        if (__thread_has_fpu(tsk)) {
+                __save_init_fpu(tsk);
+		if (!use_eager_fpu())
+	                __thread_fpu_end(tsk);
+        } else
+                tsk->fpu_counter = 0;
+
 
 	if (cpu_has_xsave)
 		return save_i387_xsave(fp);
--- a/arch/x86/kernel/xsave.c
+++ b/arch/x86/kernel/xsave.c
@@ -175,7 +175,12 @@ int save_i387_xstate(void __user *buf)
 
 		if (err)
 			return err;
-		user_fpu_end();
+		/*
+		 * With eager FPU, we want switch_fpu_prepare() keep saving
+		 * the state
+		 */
+		if (!use_eager_fpu())
+			user_fpu_end();
 	} else {
 		sanitize_i387_state(tsk);
 		if (__copy_to_user(buf, &tsk->thread.fpu.state->fxsave,
