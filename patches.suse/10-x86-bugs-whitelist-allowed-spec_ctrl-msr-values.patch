From: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Date: Wed, 25 Apr 2018 22:04:23 -0400
Subject: x86/bugs: Whitelist allowed SPEC_CTRL MSR values
Git-commit: 1115a859f33276fe8afb31c60cf9d8e657872558
Patch-mainline: v4.18 or v4.17-rc7 (next release)
References: bsc#1087082 CVE-2018-3639

Intel and AMD SPEC_CTRL (0x48) MSR semantics may differ in the
future (or in fact use different MSRs for the same functionality).

As such a run-time mechanism is required to whitelist the appropriate MSR
values.

[ tglx: Made the variable __ro_after_init ]

Signed-off-by: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
Reviewed-by: Ingo Molnar <mingo@kernel.org>
Acked-by: Borislav Petkov <bp@suse.de>
---
 arch/x86/kernel/cpu/bugs.c      |   19 ++++++++++---------
 arch/x86/kernel/cpu/spec_ctrl.c |    6 +++---
 2 files changed, 13 insertions(+), 12 deletions(-)

--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -35,6 +35,12 @@ static void __init ssb_select_mitigation
  */
 static u64 __ro_after_init x86_spec_ctrl_base;
 
+/*
+ * The vendor and possibly platform specific bits which can be modified in
+ * x86_spec_ctrl_base.
+ */
+static u64 __ro_after_init x86_spec_ctrl_mask = ~SPEC_CTRL_IBRS;
+
 void __init check_bugs(void)
 {
 	identify_boot_cpu();
@@ -118,7 +124,7 @@ static enum spectre_v2_mitigation spectr
 
 void x86_spec_ctrl_set(u64 val)
 {
-	if (val & ~(SPEC_CTRL_IBRS | SPEC_CTRL_RDS))
+	if (val & x86_spec_ctrl_mask)
 		WARN_ONCE(1, "SPEC_CTRL MSR value 0x%16llx is unknown.\n", val);
 	else
 		wrmsrl(MSR_IA32_SPEC_CTRL, x86_spec_ctrl_base | val);
@@ -452,6 +458,7 @@ static enum ssb_mitigation_cmd __init __
 		switch (boot_cpu_data.x86_vendor) {
 		case X86_VENDOR_INTEL:
 			x86_spec_ctrl_base |= SPEC_CTRL_RDS;
+			x86_spec_ctrl_mask &= ~SPEC_CTRL_RDS;
 			x86_spec_ctrl_set(SPEC_CTRL_RDS);
 			break;
 		case X86_VENDOR_AMD:
@@ -474,14 +481,8 @@ static void ssb_select_mitigation()
 
 void x86_spec_ctrl_setup_ap(void)
 {
-	u64 mask = SPEC_CTRL_RDS;
-
-	if (boot_cpu_has(X86_FEATURE_SPEC_CTRL)) {
-		if (!x86_ibrs_enabled())
-			mask |= SPEC_CTRL_IBRS;
-
-		x86_spec_ctrl_set(x86_spec_ctrl_base & mask);
-	}
+	if (boot_cpu_has(X86_FEATURE_SPEC_CTRL))
+		x86_spec_ctrl_set(x86_spec_ctrl_base & ~x86_spec_ctrl_mask);
 }
 
 #ifdef CONFIG_SYSFS
--- a/arch/x86/kernel/cpu/spec_ctrl.c
+++ b/arch/x86/kernel/cpu/spec_ctrl.c
@@ -6,6 +6,7 @@
 #include <asm/msr.h>
 #include <asm/processor.h>
 #include <asm/spec_ctrl.h>
+#include <asm/nospec-branch.h>
 
 /*
  * Keep it open for more flags in case needed.
@@ -37,14 +38,14 @@ EXPORT_SYMBOL_GPL(x86_ibpb_enabled);
 void x86_disable_ibrs(void)
 {
 	if (x86_ibrs_enabled())
-		native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);
+		x86_spec_ctrl_set(x86_spec_ctrl_base);
 }
 EXPORT_SYMBOL_GPL(x86_disable_ibrs);
 
 void x86_enable_ibrs(void)
 {
 	if (x86_ibrs_enabled())
-		native_wrmsrl(MSR_IA32_SPEC_CTRL, FEATURE_ENABLE_IBRS);
+		x86_spec_ctrl_set(SPEC_CTRL_IBRS);
 }
 EXPORT_SYMBOL_GPL(x86_enable_ibrs);
 
@@ -53,7 +54,6 @@ EXPORT_SYMBOL_GPL(x86_enable_ibrs);
  */
 void x86_spec_check(void)
 {
-
 	if (ibpb_state == 0) {
 		printk_once(KERN_INFO "IBRS/IBPB: disabled\n");
 		return;
