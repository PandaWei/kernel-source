From: Jiri Kosina <jkosina@suse.cz>
Subject: [PATCH] x86/retpolines/spec_ctrl: disable IBRS on !SKL if retpolines are active
Patch-mainline: Not yet, under development
References: bsc#1068032

SKL is the only arch for which retpolines are not sufficient to mitigate spectre v2, and
IBRS is still needed there.

Disable IBRS in case it'd be "normally" enabled, but we have retpolines active and are
running on !SKL architecture.

This patch "decouples" IBRS and IBPB semantics in a sense that IBPB can be set
independently (when running on !SKL with retpolines), but SKL always implies
IBRS+IBPB.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
---
 arch/x86/include/asm/spec_ctrl.h |    1 +
 arch/x86/kernel/cpu/bugs.c       |   10 ++++++++--
 arch/x86/kernel/cpu/spec_ctrl.c  |   16 +++++++++++-----
 3 files changed, 20 insertions(+), 7 deletions(-)

--- a/arch/x86/include/asm/spec_ctrl.h
+++ b/arch/x86/include/asm/spec_ctrl.h
@@ -87,6 +87,7 @@
 .endm
 
 #else /* __ASSEMBLY__ */
+extern int ibrs_state;
 void x86_enable_ibrs(void);
 void x86_disable_ibrs(void);
 unsigned int x86_ibrs_enabled(void);
--- a/arch/x86/kernel/cpu/bugs.c
+++ b/arch/x86/kernel/cpu/bugs.c
@@ -26,6 +26,7 @@
 #include <asm/pgtable.h>
 #include <asm/cacheflush.h>
 #include <asm/intel-family.h>
+#include <asm/spec_ctrl.h>
 
 static void __init spectre_v2_select_mitigation(void);
 static void __init ssb_select_mitigation(void);
@@ -403,6 +404,11 @@ retpoline_auto:
 		pr_info("Spectre v2 mitigation: Filling RSB on context switch\n");
 	}
 
+	if (!is_skylake_era() && x86_ibrs_enabled()) {
+		pr_info("Retpolines enabled, force-disabling IBRS due to !SKL-era core\n");
+		ibrs_state = 0;
+	}
+
 	/* Initialize Indirect Branch Prediction Barrier if supported */
 	if (boot_cpu_has(X86_FEATURE_IBPB)) {
 		setup_force_cpu_cap(X86_FEATURE_USE_IBPB);
@@ -671,10 +677,10 @@ static ssize_t cpu_show_common(struct de
 		return sprintf(buf, "Mitigation: __user pointer sanitization\n");
 
 	case X86_BUG_SPECTRE_V2:
-		if (boot_cpu_has(X86_FEATURE_SPEC_CTRL))
+		if (boot_cpu_has(X86_FEATURE_SPEC_CTRL) && x86_ibrs_enabled())
 			return sprintf(buf, "Mitigation: IBRS+IBPB\n");
 		return sprintf(buf, "%s%s%s%s\n", spectre_v2_strings[spectre_v2_enabled],
-			       boot_cpu_has(X86_FEATURE_USE_IBPB) ? ", IBPB" : "",
+			       boot_cpu_has(X86_FEATURE_USE_IBPB) && x86_ibpb_enabled() ? ", IBPB" : "",
 			       boot_cpu_has(X86_FEATURE_USE_IBRS_FW) ? ", IBRS_FW" : "",
 			       spectre_v2_module_string());
 
--- a/arch/x86/kernel/cpu/spec_ctrl.c
+++ b/arch/x86/kernel/cpu/spec_ctrl.c
@@ -12,8 +12,11 @@
  * Keep it open for more flags in case needed.
  *
  * -1 means "not touched by nospec() earlyparam"
+ *
+ * If IBRS is set, IBPB is always set. IBPB can be set independently
+ * on IBRS state (SKL).
  */
-static int ibrs_state = -1;
+int ibrs_state = -1;
 static int ibpb_state = -1;
 
 unsigned int notrace x86_ibrs_enabled(void)
@@ -52,18 +55,21 @@ EXPORT_SYMBOL_GPL(x86_enable_ibrs);
 void x86_spec_check(void)
 {
 
-	if (ibrs_state == 0 || ibpb_state == 0) {
+	if (ibpb_state == 0) {
 		printk_once(KERN_INFO "IBRS/IBPB: disabled\n");
 		return;
 	}
 
 	if (cpuid_edx(7) & BIT(26)) {
-		ibrs_state = 1;
+		if (ibrs_state == -1) {
+			/* noone force-disabled IBRS */
+			ibrs_state = 1;
+			printk_once(KERN_INFO "IBRS: initialized\n");
+		}
+		printk_once(KERN_INFO "IBPB: initialized\n");
 		ibpb_state = 1;
 
 		setup_force_cpu_cap(X86_FEATURE_SPEC_CTRL);
-
-		printk_once(KERN_INFO "IBRS/IBPB: Initialized\n");
 	}
 
 	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
