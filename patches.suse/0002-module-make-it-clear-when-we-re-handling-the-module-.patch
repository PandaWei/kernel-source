From 807c90106fd1806ee90c0bdbaa09cf0c7691edb1 Mon Sep 17 00:00:00 2001
From: Jessica Yu <jeyu@kernel.org>
Date: Thu, 16 Aug 2018 12:05:57 +0200
Subject: [PATCH 2/5] module: make it clear when we're handling the module copy
 in info->hdr
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/jeyu/linux.git
Git-commit: 81a0abd9f213704fbeeea1550ff202000e3c3cdf
Patch-mainline: Queued in subsystem maintainer repository
References: bsc#1093666

In load_module(), it's not always clear whether we're handling the
temporary module copy in info->hdr (which is freed at the end of
load_module()) or if we're handling the module already allocated and
copied to it's final place. Adding an info->mod field and using it
whenever we're handling the temporary copy makes that explicitly clear.

Signed-off-by: Jessica Yu <jeyu@kernel.org>
Acked-by: Jessica Yu <jeyu@suse.de>
---
 kernel/module.c | 46 +++++++++++++++++++++++-----------------------
 1 file changed, 23 insertions(+), 23 deletions(-)

diff --git a/kernel/module.c b/kernel/module.c
index d6963b48b514..c4335a5cbaca 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -198,6 +198,8 @@ int unregister_module_notifier(struct notifier_block * nb)
 EXPORT_SYMBOL(unregister_module_notifier);
 
 struct load_info {
+	/* pointer to module in temporary copy, freed at end of load_module() */
+	struct module *mod;
 	Elf_Ehdr *hdr;
 	unsigned long len;
 	Elf_Shdr *sechdrs;
@@ -2586,14 +2588,13 @@ static int rewrite_section_headers(struct load_info *info)
  * search for module section index etc), and do some basic section
  * verification.
  *
- * Return the temporary module pointer (we'll replace it with the final
- * one when we move the module sections around).
+ * Set info->mod to the temporary copy of the module in info->hdr. The final one
+ * will be allocated in move_module().
  */
-static struct module *setup_load_info(struct load_info *info)
+static int setup_load_info(struct load_info *info)
 {
 	unsigned int i;
 	int err;
-	struct module *mod;
 
 	/* Set up the convenience variables */
 	info->sechdrs = (void *)info->hdr + info->hdr->e_shoff;
@@ -2602,7 +2603,7 @@ static struct module *setup_load_info(struct load_info *info)
 
 	err = rewrite_section_headers(info);
 	if (err)
-		return ERR_PTR(err);
+		return err;
 
 	/* Find internal symbols and strings. */
 	for (i = 1; i < info->hdr->e_shnum; i++) {
@@ -2618,15 +2619,15 @@ static struct module *setup_load_info(struct load_info *info)
 	info->index.mod = find_sec(info, ".gnu.linkonce.this_module");
 	if (!info->index.mod) {
 		printk(KERN_WARNING "No module found in object\n");
-		return ERR_PTR(-ENOEXEC);
+		return -ENOEXEC;
 	}
 	/* This is temporary: point mod into copy of data. */
-	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
+	info->mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 
 	if (info->index.sym == 0) {
 		printk(KERN_WARNING "%s: module has no symbols (stripped?)\n",
-		       mod->name);
-		return ERR_PTR(-ENOEXEC);
+		       info->mod->name);
+		return -ENOEXEC;
 	}
 
 	info->index.pcpu = find_pcpusec(info);
@@ -2634,10 +2635,10 @@ static struct module *setup_load_info(struct load_info *info)
 	info->index.unwind = find_unwind(info);
 
 	/* Check module struct version now, before we try to use module. */
-	if (!check_modstruct_version(info->sechdrs, info->index.vers, mod))
-		return ERR_PTR(-ENOEXEC);
+	if (!check_modstruct_version(info->sechdrs, info->index.vers, info->mod))
+		return -ENOEXEC;
 
-	return mod;
+	return 0;
 }
 
 static int check_modinfo(struct module *mod, struct load_info *info)
@@ -2873,29 +2874,28 @@ static void flush_module_icache(const struct module *mod)
 
 static struct module *layout_and_allocate(struct load_info *info)
 {
-	/* Module within temporary copy. */
 	struct module *mod;
 	Elf_Shdr *pcpusec;
 	int err;
 
-	mod = setup_load_info(info);
-	if (IS_ERR(mod))
-		return mod;
+	err = setup_load_info(info);
+	if (err)
+		return ERR_PTR(err);
 
-	err = check_modinfo(mod, info);
+	err = check_modinfo(info->mod, info);
 	if (err)
 		return ERR_PTR(err);
 
 	/* Allow arches to frob section contents and sizes.  */
 	err = module_frob_arch_sections(info->hdr, info->sechdrs,
-					info->secstrings, mod);
+					info->secstrings, info->mod);
 	if (err < 0)
 		goto out;
 
 	pcpusec = &info->sechdrs[info->index.pcpu];
 	if (pcpusec->sh_size) {
 		/* We have a special allocation for this section. */
-		err = percpu_modalloc(mod,
+		err = percpu_modalloc(info->mod,
 				      pcpusec->sh_size, pcpusec->sh_addralign);
 		if (err)
 			goto out;
@@ -2905,7 +2905,7 @@ static struct module *layout_and_allocate(struct load_info *info)
 	/* Determine total sizes, and put offsets in sh_entsize.  For now
 	   this is done generically; there doesn't appear to be any
 	   special cases for the architectures. */
-	layout_sections(mod, info);
+	layout_sections(info->mod, info);
 
 	info->strmap = kzalloc(BITS_TO_LONGS(info->sechdrs[info->index.str].sh_size)
 			 * sizeof(long), GFP_KERNEL);
@@ -2913,10 +2913,10 @@ static struct module *layout_and_allocate(struct load_info *info)
 		err = -ENOMEM;
 		goto free_percpu;
 	}
-	layout_symtab(mod, info);
+	layout_symtab(info->mod, info);
 
 	/* Allocate and move to the final place */
-	err = move_module(mod, info);
+	err = move_module(info->mod, info);
 	if (err)
 		goto free_strmap;
 
@@ -2928,7 +2928,7 @@ static struct module *layout_and_allocate(struct load_info *info)
 free_strmap:
 	kfree(info->strmap);
 free_percpu:
-	percpu_modfree(mod);
+	percpu_modfree(info->mod);
 out:
 	return ERR_PTR(err);
 }
-- 
2.16.4

