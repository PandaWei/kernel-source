From: Liu Bo <bo.li.liu@oracle.com>
Subject: Btrfs: fix up read_tree_block to return proper error
Git-commit: 64c043de466d5746e7ca306dab9d418cd871cefc
Patch-mainline: v4.2-rc1
References: bsc#1080837

The return value of read_tree_block() can confuse callers as it always
returns NULL for either -ENOMEM or -EIO, so it's likely that callers
parse it to a wrong error, for instance, in btrfs_read_tree_root().

This fixes the above issue.

Signed-off-by: Liu Bo <bo.li.liu@oracle.com>
Reviewed-by: David Sterba <dsterba@suse.cz>
Signed-off-by: Chris Mason <clm@fb.com>
Acked-by: Jeff Mahoney <jeffm@suse.com>
---
 fs/btrfs/backref.c     |    9 +++++++--
 fs/btrfs/ctree.c       |   22 ++++++++++++++--------
 fs/btrfs/disk-io.c     |   36 ++++++++++++++++++++++++------------
 fs/btrfs/extent-tree.c |    4 +++-
 fs/btrfs/print-tree.c  |    6 ++++++
 fs/btrfs/relocation.c  |   19 ++++++++++++++-----
 6 files changed, 68 insertions(+), 28 deletions(-)

--- a/fs/btrfs/backref.c
+++ b/fs/btrfs/backref.c
@@ -449,7 +449,9 @@ static int __add_missing_keys(struct btr
 		BUG_ON(!ref->wanted_disk_byte);
 		eb = read_tree_block(fs_info->tree_root, ref->wanted_disk_byte,
 				     0);
-		if (!eb || !extent_buffer_uptodate(eb)) {
+		if (IS_ERR(eb)) {
+			return PTR_ERR(eb);
+		} else if (!extent_buffer_uptodate(eb)) {
 			free_extent_buffer(eb);
 			return -EIO;
 		}
@@ -949,7 +951,10 @@ again:
 
 				eb = read_tree_block(fs_info->extent_root,
 							   ref->parent, 0);
-				if (!eb || !extent_buffer_uptodate(eb)) {
+				if (IS_ERR(eb)) {
+					ret = PTR_ERR(eb);
+					goto out;
+				} else if (!extent_buffer_uptodate(eb)) {
 					free_extent_buffer(eb);
 					ret = -EIO;
 					goto out;
--- a/fs/btrfs/ctree.c
+++ b/fs/btrfs/ctree.c
@@ -1318,8 +1318,9 @@ get_old_root(struct btrfs_root *root, u6
 		btrfs_tree_read_unlock(eb_root);
 		free_extent_buffer(eb_root);
 		old = read_tree_block(root, logical, 0);
-		if (!old || !extent_buffer_uptodate(old)) {
-			free_extent_buffer(old);
+		if (IS_ERR(old) || !extent_buffer_uptodate(old)) {
+			if (!IS_ERR(old))
+				free_extent_buffer(old);
 			pr_warn("btrfs: failed to read tree block %llu from get_old_root\n",
 				logical);
 			WARN_ON(1);
@@ -1563,7 +1564,9 @@ int btrfs_realloc_node(struct btrfs_tran
 		if (!cur || !uptodate) {
 			if (!cur) {
 				cur = read_tree_block(root, blocknr, gen);
-				if (!cur || !extent_buffer_uptodate(cur)) {
+				if (IS_ERR(cur)) {
+					return PTR_ERR(cur);
+				} else if (!extent_buffer_uptodate(cur)) {
 					free_extent_buffer(cur);
 					return -EIO;
 				}
@@ -1742,8 +1745,9 @@ static noinline struct extent_buffer *re
 
 	eb = read_tree_block(root, btrfs_node_blockptr(parent, slot),
 			     btrfs_node_ptr_generation(parent, slot));
-	if (eb && !extent_buffer_uptodate(eb)) {
-		free_extent_buffer(eb);
+	if (IS_ERR(eb) || !extent_buffer_uptodate(eb)) {
+		if (!IS_ERR(eb))
+			free_extent_buffer(eb);
 		eb = NULL;
 	}
 
@@ -2235,11 +2239,13 @@ static noinline int reada_for_balance(st
 
 		if (block1) {
 			eb = read_tree_block(root, block1, 0);
-			free_extent_buffer(eb);
+			if (!IS_ERR(eb))
+				free_extent_buffer(eb);
 		}
 		if (block2) {
 			eb = read_tree_block(root, block2, 0);
-			free_extent_buffer(eb);
+			if (!IS_ERR(eb))
+				free_extent_buffer(eb);
 		}
 	}
 	return ret;
@@ -2405,7 +2411,7 @@ read_block_for_search(struct btrfs_trans
 
 	ret = -EAGAIN;
 	tmp = read_tree_block(root, blocknr, 0);
-	if (tmp) {
+	if (!IS_ERR(tmp)) {
 		/*
 		 * If the read above didn't mark this buffer up to date,
 		 * it will never end up being up to date.  Set ret to EIO now
--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -1119,12 +1119,12 @@ struct extent_buffer *read_tree_block(st
 
 	buf = btrfs_find_create_tree_block(root, bytenr, root->nodesize);
 	if (!buf)
-		return NULL;
+		return ERR_PTR(-ENOMEM);
 
 	ret = btree_read_extent_buffer_pages(root, buf, 0, parent_transid);
 	if (ret) {
 		free_extent_buffer(buf);
-		return NULL;
+		return ERR_PTR(ret);
 	}
 	return buf;
 
@@ -1234,7 +1234,11 @@ static int __must_check find_and_setup_r
 	root->commit_root = NULL;
 	root->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),
 				     generation);
-	if (!root->node || !btrfs_buffer_uptodate(root->node, generation, 0)) {
+	if (IS_ERR(root->node)) {
+		ret = PTR_ERR(root->node);
+		root->node = NULL;
+		return ret;
+	} else if (!btrfs_buffer_uptodate(root->node, generation, 0)) {
 		free_extent_buffer(root->node);
 		root->node = NULL;
 		return -EIO;
@@ -1477,12 +1481,14 @@ struct btrfs_root *btrfs_read_fs_root_no
 	generation = btrfs_root_generation(&root->root_item);
 	root->node = read_tree_block(root, btrfs_root_bytenr(&root->root_item),
 				     generation);
-	if (!root->node || !extent_buffer_uptodate(root->node)) {
-		ret = (!root->node) ? -ENOMEM : -EIO;
-
-		free_extent_buffer(root->node);
+	if (IS_ERR(root->node)) {
+		ret = PTR_ERR(root->node);
 		kfree(root);
 		return ERR_PTR(ret);
+	} else if (!extent_buffer_uptodate(root->node)) {
+		free_extent_buffer(root->node);
+		kfree(root);
+		return ERR_PTR(-EIO);
 	}
 
 	root->commit_root = btrfs_root_node(root);
@@ -2568,10 +2574,13 @@ int open_ctree(struct super_block *sb,
 	chunk_root->node = read_tree_block(chunk_root,
 					   btrfs_super_chunk_root(disk_super),
 					   generation);
-	if (!chunk_root->node ||
+	if (IS_ERR(chunk_root->node) ||
 	    !test_bit(EXTENT_BUFFER_UPTODATE, &chunk_root->node->bflags)) {
 		printk(KERN_WARNING "btrfs: failed to read chunk root on %s\n",
 		       sb->s_id);
+		if (!IS_ERR(chunk_root->node))
+			free_extent_buffer(chunk_root->node);
+		chunk_root->node = NULL;
 		goto fail_tree_roots;
 	}
 	btrfs_set_root_node(&chunk_root->root_item, chunk_root->node);
@@ -2606,11 +2615,13 @@ retry_root_backup:
 	tree_root->node = read_tree_block(tree_root,
 					  btrfs_super_root(disk_super),
 					  generation);
-	if (!tree_root->node ||
+	if (IS_ERR(tree_root->node) ||
 	    !test_bit(EXTENT_BUFFER_UPTODATE, &tree_root->node->bflags)) {
 		printk(KERN_WARNING "btrfs: failed to read tree root on %s\n",
 		       sb->s_id);
-
+		if (!IS_ERR(tree_root->node))
+			free_extent_buffer(tree_root->node);
+		tree_root->node = NULL;
 		goto recovery_tree_root;
 	}
 
@@ -2748,10 +2759,11 @@ retry_root_backup:
 
 		log_tree_root->node = read_tree_block(tree_root, bytenr,
 						      generation + 1);
-		if (!log_tree_root->node ||
+		if (IS_ERR(log_tree_root->node) ||
 		    !extent_buffer_uptodate(log_tree_root->node)) {
 			printk(KERN_ERR "btrfs: failed to read log tree\n");
-			free_extent_buffer(log_tree_root->node);
+			if (!IS_ERR(log_tree_root->node))
+				free_extent_buffer(log_tree_root->node);
 			kfree(log_tree_root);
 			goto fail_trans_kthread;
 		}
--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -7287,7 +7287,9 @@ static noinline int do_walk_down(struct
 		if (reada && level == 1)
 			reada_walk_down(trans, root, wc, path);
 		next = read_tree_block(root, bytenr, generation);
-		if (!next || !extent_buffer_uptodate(next)) {
+		if (IS_ERR(next)) {
+			return PTR_ERR(next);
+		} else if (!extent_buffer_uptodate(next)) {
 			free_extent_buffer(next);
 			return -EIO;
 		}
--- a/fs/btrfs/print-tree.c
+++ b/fs/btrfs/print-tree.c
@@ -336,6 +336,12 @@ void btrfs_print_tree(struct btrfs_root
 		struct extent_buffer *next = read_tree_block(root,
 					btrfs_node_blockptr(c, i),
 					btrfs_node_ptr_generation(c, i));
+		if (IS_ERR(next)) {
+			continue;
+		} else if (!extent_buffer_uptodate(next)) {
+			free_extent_buffer(next);
+			continue;
+		}
 		if (btrfs_is_leaf(next) &&
 		   level != 1)
 			BUG();
--- a/fs/btrfs/relocation.c
+++ b/fs/btrfs/relocation.c
@@ -1786,8 +1786,10 @@ again:
 			}
 
 			eb = read_tree_block(dest, old_bytenr, old_ptr_gen);
-			if (!eb || !extent_buffer_uptodate(eb)) {
-				ret = (!eb) ? -ENOMEM : -EIO;
+			if (IS_ERR(eb)) {
+				ret = PTR_ERR(eb);
+			} else if (!extent_buffer_uptodate(eb)) {
+				ret = -EIO;
 				free_extent_buffer(eb);
 				break;
 			}
@@ -1941,7 +1943,9 @@ int walk_down_reloc_tree(struct btrfs_ro
 
 		bytenr = btrfs_node_blockptr(eb, path->slots[i]);
 		eb = read_tree_block(root, bytenr, ptr_gen);
-		if (!eb || !extent_buffer_uptodate(eb)) {
+		if (IS_ERR(eb)) {
+			return PTR_ERR(eb);
+		} else if (!extent_buffer_uptodate(eb)) {
 			free_extent_buffer(eb);
 			return -EIO;
 		}
@@ -2658,7 +2662,10 @@ static int do_relocation(struct btrfs_tr
 		blocksize = root->nodesize;
 		generation = btrfs_node_ptr_generation(upper->eb, slot);
 		eb = read_tree_block(root, bytenr, generation);
-		if (!eb || !extent_buffer_uptodate(eb)) {
+		if (IS_ERR(eb)) {
+			err = PTR_ERR(eb);
+			goto next;
+		} else if (!extent_buffer_uptodate(eb)) {
 			free_extent_buffer(eb);
 			err = -EIO;
 			goto next;
@@ -2820,7 +2827,9 @@ static int get_tree_block_key(struct rel
 	BUG_ON(block->key_ready);
 	eb = read_tree_block(rc->extent_root, block->bytenr,
 			     block->key.offset);
-	if (!eb || !extent_buffer_uptodate(eb)) {
+	if (IS_ERR(eb)) {
+		return PTR_ERR(eb);
+	} else if (!extent_buffer_uptodate(eb)) {
 		free_extent_buffer(eb);
 		return -EIO;
 	}
