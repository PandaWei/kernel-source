From: Dan Williams <dan.j.williams@intel.com>
Date: Fri, 30 Jun 2017 18:56:03 -0700
Subject: libnvdimm, region, pmem: fix 'badblocks' sysfs_get_dirent() reference
 lifetime
Patch-mainline: v4.13-rc1
Git-commit: 6aa734a2f38e2e17ac4de3561770b8676b27af2e
References: FATE#324634

We need to hold a reference on the 'dirent' until we are sure there are
no more notifications that will be sent. As noted in the new comments we
take advantage of the fact that the references are taken and dropped
under device_lock() and that nd_device_notify() holds device_lock() over
new badblocks notifications. The notifications that happen when
badblocks are cleared only occur while the device is active.

Also take the opportunity to fix up the error messages to report the
user visible effect of a sysfs_get_dirent() failure.

Fixes: 975750a98c26 ("libnvdimm, pmem: Add sysfs notifications to badblocks")
Cc: Toshi Kani <toshi.kani@hpe.com>
Signed-off-by: Dan Williams <dan.j.williams@intel.com>
Acked-by: Johannes Thumshirn <jthumshirn@suse.de>
---
 drivers/nvdimm/pmem.c   |   16 ++++++++++++----
 drivers/nvdimm/region.c |   13 +++++++++----
 2 files changed, 21 insertions(+), 8 deletions(-)

--- a/drivers/nvdimm/pmem.c
+++ b/drivers/nvdimm/pmem.c
@@ -381,10 +381,8 @@ static int pmem_attach_disk(struct devic
 
 	pmem->bb_state = sysfs_get_dirent(disk_to_dev(disk)->kobj.sd,
 					  "badblocks");
-	if (pmem->bb_state)
-		sysfs_put(pmem->bb_state);
-	else
-		dev_warn(dev, "sysfs_get_dirent 'badblocks' failed\n");
+	if (!pmem->bb_state)
+		dev_warn(dev, "'badblocks' notification disabled\n");
 
 	return 0;
 }
@@ -417,8 +415,18 @@ static int nd_pmem_probe(struct device *
 
 static int nd_pmem_remove(struct device *dev)
 {
+	struct pmem_device *pmem = dev_get_drvdata(dev);
+
 	if (is_nd_btt(dev))
 		nvdimm_namespace_detach_btt(to_nd_btt(dev));
+	else {
+		/*
+		 * Note, this assumes device_lock() context to not race
+		 * nd_pmem_notify()
+		 */
+		sysfs_put(pmem->bb_state);
+		pmem->bb_state = NULL;
+	}
 	nvdimm_flush(to_nd_region(dev->parent));
 
 	return 0;
--- a/drivers/nvdimm/region.c
+++ b/drivers/nvdimm/region.c
@@ -60,11 +60,9 @@ static int nd_region_probe(struct device
 			return -ENODEV;
 		nd_region->bb_state = sysfs_get_dirent(nd_region->dev.kobj.sd,
 						       "badblocks");
-		if (nd_region->bb_state)
-			sysfs_put(nd_region->bb_state);
-		else
+		if (!nd_region->bb_state)
 			dev_warn(&nd_region->dev,
-				"sysfs_get_dirent 'badblocks' failed\n");
+					"'badblocks' notification disabled\n");
 		ndr_res.start = nd_region->ndr_start;
 		ndr_res.end = nd_region->ndr_start + nd_region->ndr_size - 1;
 		nvdimm_badblocks_populate(nd_region, &nd_region->bb, &ndr_res);
@@ -111,6 +109,13 @@ static int nd_region_remove(struct devic
 	dev_set_drvdata(dev, NULL);
 	nvdimm_bus_unlock(dev);
 
+	/*
+	 * Note, this assumes device_lock() context to not race
+	 * nd_region_notify()
+	 */
+	sysfs_put(nd_region->bb_state);
+	nd_region->bb_state = NULL;
+
 	return 0;
 }
 
