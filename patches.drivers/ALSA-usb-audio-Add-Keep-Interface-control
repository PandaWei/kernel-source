From 4120fbedbb6c999686d03a9c74acc4f650ece8a2 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 2 May 2018 11:52:55 +0200
Subject: [PATCH] ALSA: usb-audio: Add "Keep Interface" control
Git-commit: 4120fbedbb6c999686d03a9c74acc4f650ece8a2
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/tiwai/sound.git
Patch-mainline: Queued in subsystem maintainer repository
References: bsc#1089467

This patch adds "Keep Interface" control for each USB-audio device.
The control element is with SND_CTL_IFACE_CARD, so that it won't
appear on any sane mixer applications.  For a device that is confirmed
to work well with "keep-interface" mode, user can flip the control via
amixer, e.g.
  % amixer -c1 cset iface=CARD,name='Keep Interface' on

and save/restore the state via alsactl.

The reason to provide this via control API is that the behavior must
be pretty depending on the device (and the firmware in it), so it's
not ideal to apply via module option.

For a device that certainly works, we may set it statically via a
quirk table entry.  But a device like Dell WD15 dock behaves so
differently depending on the firmware, and we can't set it
statically.  So leave this as a dynamic switch each user can adjust
freely.

Signed-off-by: Takashi Iwai <tiwai@suse.de>

---
 sound/usb/mixer.c |   45 +++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 45 insertions(+)

--- a/sound/usb/mixer.c
+++ b/sound/usb/mixer.c
@@ -2554,6 +2554,48 @@ static int snd_usb_mixer_status_create(s
 	return 0;
 }
 
+static int keep_iface_ctl_get(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);
+
+	ucontrol->value.integer.value[0] = mixer->chip->keep_iface;
+	return 0;
+}
+
+static int keep_iface_ctl_put(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct usb_mixer_interface *mixer = snd_kcontrol_chip(kcontrol);
+	bool keep_iface = !!ucontrol->value.integer.value[0];
+
+	if (mixer->chip->keep_iface == keep_iface)
+		return 0;
+	mixer->chip->keep_iface = keep_iface;
+	return 1;
+}
+
+static const struct snd_kcontrol_new keep_iface_ctl = {
+	.iface = SNDRV_CTL_ELEM_IFACE_CARD,
+	.name = "Keep Interface",
+	.info = snd_ctl_boolean_mono_info,
+	.get = keep_iface_ctl_get,
+	.put = keep_iface_ctl_put,
+};
+
+static int create_keep_iface_ctl(struct usb_mixer_interface *mixer)
+{
+	struct snd_kcontrol *kctl = snd_ctl_new1(&keep_iface_ctl, mixer);
+
+	/* need only one control per card */
+	if (snd_ctl_find_id(mixer->chip->card, &kctl->id)) {
+		snd_ctl_free_one(kctl);
+		return 0;
+	}
+
+	return snd_ctl_add(mixer->chip->card, kctl);
+}
+
 int snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,
 			 int ignore_error)
 {
@@ -2592,6 +2634,9 @@ int snd_usb_create_mixer(struct snd_usb_
 	if ((err = snd_usb_mixer_controls(mixer)) < 0 ||
 	    (err = snd_usb_mixer_status_create(mixer)) < 0)
 		goto _error;
+	err = create_keep_iface_ctl(mixer);
+	if (err < 0)
+		goto _error;
 
 	snd_usb_mixer_apply_create_quirk(mixer);
 
