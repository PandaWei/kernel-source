From: Babu Moger <babu.moger@amd.com>
Date: Fri, 16 Mar 2018 16:37:23 -0400
Subject: KVM: VMX: Remove ple_window_actual_max
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Git-commit: 18abdc3425aa546424672d3b1f932ecc55132368
Patch-mainline: v4.17-rc1
References: fate#325533

Get rid of ple_window_actual_max, because its benefits are really
minuscule and the logic is complicated.

The overflows(and underflow) are controlled in __ple_window_grow
and _ple_window_shrink respectively.

Suggested-by: Radim Krčmář <rkrcmar@redhat.com>
Signed-off-by: Babu Moger <babu.moger@amd.com>
[Fixed potential wraparound and change the max to UINT_MAX. - Radim]
Signed-off-by: Radim Krčmář <rkrcmar@redhat.com>
Acked-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/kvm/vmx.c | 31 ++++++-------------------------
 1 file changed, 6 insertions(+), 25 deletions(-)

diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c
index 4eb252b13121..7a92e2e1ea2e 100644
--- a/arch/x86/kvm/vmx.c
+++ b/arch/x86/kvm/vmx.c
@@ -172,8 +172,7 @@ module_param_named(preemption_timer, enable_preemption_timer, bool, S_IRUGO);
 #define KVM_VMX_DEFAULT_PLE_WINDOW        4096
 #define KVM_VMX_DEFAULT_PLE_WINDOW_GROW   2
 #define KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK 0
-#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    \
-		INT_MAX / KVM_VMX_DEFAULT_PLE_WINDOW_GROW
+#define KVM_VMX_DEFAULT_PLE_WINDOW_MAX    UINT_MAX
 
 static unsigned int ple_gap = KVM_VMX_DEFAULT_PLE_GAP;
 module_param(ple_gap, uint, 0444);
@@ -190,7 +189,6 @@ static unsigned int ple_window_shrink = KVM_VMX_DEFAULT_PLE_WINDOW_SHRINK;
 module_param(ple_window_shrink, uint, 0444);
 
 /* Default is to compute the maximum so we can never overflow. */
-static unsigned int ple_window_actual_max = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;
 static unsigned int ple_window_max        = KVM_VMX_DEFAULT_PLE_WINDOW_MAX;
 module_param(ple_window_max, uint, 0444);
 
@@ -6986,17 +6984,17 @@ out:
 
 static unsigned int __grow_ple_window(unsigned int val)
 {
+	u64 ret = val;
+
 	if (ple_window_grow < 1)
 		return ple_window;
 
-	val = min(val, ple_window_actual_max);
-
 	if (ple_window_grow < ple_window)
-		val *= ple_window_grow;
+		ret *= ple_window_grow;
 	else
-		val += ple_window_grow;
+		ret += ple_window_grow;
 
-	return val;
+	return min(ret, (u64)ple_window_max);
 }
 
 static unsigned int __shrink_ple_window(unsigned int val,
@@ -7041,21 +7039,6 @@ static void shrink_ple_window(struct kvm_vcpu *vcpu)
 }
 
 /*
- * ple_window_actual_max is computed to be one grow_ple_window() below
- * ple_window_max. (See __grow_ple_window for the reason.)
- * This prevents overflows, because ple_window_max is int.
- * ple_window_max effectively rounded down to a multiple of ple_window_grow in
- * this process.
- * ple_window_max is also prevented from setting vmx->ple_window < ple_window.
- */
-static void update_ple_window_actual_max(void)
-{
-	ple_window_actual_max =
-			__shrink_ple_window(max(ple_window_max, ple_window),
-			                    ple_window_grow, INT_MIN);
-}
-
-/*
  * Handler for POSTED_INTERRUPT_WAKEUP_VECTOR.
  */
 static void wakeup_handler(void)
@@ -7175,8 +7158,6 @@ static __init int hardware_setup(void)
 	else
 		kvm_disable_tdp();
 
-	update_ple_window_actual_max();
-
 	/*
 	 * Only enable PML when hardware supports PML feature, and both EPT
 	 * and EPT A/D bit features are enabled -- PML depends on them to work.

