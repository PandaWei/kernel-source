From 7ab1197df940e79801b220b98c0959ed31a5b203 Mon Sep 17 00:00:00 2001
From: Keerthi Reddy <keerthigd4990@gmail.com>
Date: Wed, 27 Sep 2017 23:19:46 +0530
Subject: [PATCH] staging: vc04_services: please do not use multiple blank lines
Git-commit: 7ab1197df940e79801b220b98c0959ed31a5b203
Patch-mainline: v4.15-rc1
References: FATE#324827

Blank lines use up extra space in file and makes the file
larger. So do not use multiple blanklines

Signed-off-by: Keerthi Reddy <keerthigd4990@gmail.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Acked-by: Takashi Iwai <tiwai@suse.de>

---
 drivers/staging/vc04_services/bcm2835-audio/bcm2835-pcm.c              |   11 ----------
 drivers/staging/vc04_services/bcm2835-audio/bcm2835-vchiq.c            |   11 ----------
 drivers/staging/vc04_services/interface/vchi/connections/connection.h  |    3 --
 drivers/staging/vc04_services/interface/vchi/message_drivers/message.h |    5 ----
 drivers/staging/vc04_services/interface/vchi/vchi.h                    |   10 ---------
 drivers/staging/vc04_services/interface/vchi/vchi_common.h             |    6 -----
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c          |    9 --------
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h          |    5 ----
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c         |   10 ---------
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h         |    1 
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_debugfs.c      |    3 --
 drivers/staging/vc04_services/interface/vchiq_arm/vchiq_shim.c         |    3 --
 12 files changed, 77 deletions(-)

--- a/drivers/staging/vc04_services/bcm2835-audio/bcm2835-pcm.c
+++ b/drivers/staging/vc04_services/bcm2835-audio/bcm2835-pcm.c
@@ -65,7 +65,6 @@ void bcm2835_playback_fifo(struct bcm283
 	unsigned int consumed = 0;
 	int new_period = 0;
 
-
 	audio_info("alsa_stream=%p substream=%p\n", alsa_stream,
 		alsa_stream ? alsa_stream->substream : 0);
 
@@ -111,7 +110,6 @@ static int snd_bcm2835_playback_open_gen
 	int idx;
 	int err;
 
-
 	if (mutex_lock_interruptible(&chip->audio_mutex)) {
 		audio_error("Interrupted whilst waiting for lock\n");
 		return -EINTR;
@@ -184,7 +182,6 @@ static int snd_bcm2835_playback_open_gen
 out:
 	mutex_unlock(&chip->audio_mutex);
 
-
 	return err;
 }
 
@@ -207,7 +204,6 @@ static int snd_bcm2835_playback_close(st
 	struct snd_pcm_runtime *runtime;
 	struct bcm2835_alsa_stream *alsa_stream;
 
-
 	chip = snd_pcm_substream_chip(substream);
 	if (mutex_lock_interruptible(&chip->audio_mutex)) {
 		audio_error("Interrupted whilst waiting for lock\n");
@@ -259,7 +255,6 @@ static int snd_bcm2835_pcm_hw_params(str
 	struct bcm2835_alsa_stream *alsa_stream = runtime->private_data;
 	int err;
 
-
 	err = snd_pcm_lib_malloc_pages(substream, params_buffer_bytes(params));
 	if (err < 0) {
 		audio_error
@@ -289,7 +284,6 @@ static int snd_bcm2835_pcm_prepare(struc
 	int channels;
 	int err;
 
-
 	if (mutex_lock_interruptible(&chip->audio_mutex))
 		return -EINTR;
 
@@ -307,13 +301,11 @@ static int snd_bcm2835_pcm_prepare(struc
 	if (err < 0)
 		audio_error(" error setting hw params\n");
 
-
 	bcm2835_audio_setup(alsa_stream);
 
 	/* in preparation of the stream, set the controls (volume level) of the stream */
 	bcm2835_audio_set_ctls(alsa_stream->chip);
 
-
 	memset(&alsa_stream->pcm_indirect, 0, sizeof(alsa_stream->pcm_indirect));
 
 	alsa_stream->pcm_indirect.hw_buffer_size =
@@ -364,7 +356,6 @@ static int snd_bcm2835_pcm_trigger(struc
 	struct bcm2835_alsa_stream *alsa_stream = runtime->private_data;
 	int err = 0;
 
-
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 		audio_debug("bcm2835_AUDIO_TRIGGER_START running=%d\n",
@@ -416,7 +407,6 @@ snd_bcm2835_pcm_pointer(struct snd_pcm_s
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct bcm2835_alsa_stream *alsa_stream = runtime->private_data;
 
-
 	audio_debug("pcm_pointer... (%d) hwptr=%d appl=%d pos=%d\n", 0,
 		frames_to_bytes(runtime, runtime->status->hw_ptr),
 		frames_to_bytes(runtime, runtime->control->appl_ptr),
@@ -493,7 +483,6 @@ int snd_bcm2835_new_pcm(struct bcm2835_c
 					      snd_bcm2835_playback_hw.buffer_bytes_max,
 					      snd_bcm2835_playback_hw.buffer_bytes_max);
 
-
 out:
 	mutex_unlock(&chip->audio_mutex);
 
--- a/drivers/staging/vc04_services/bcm2835-audio/bcm2835-vchiq.c
+++ b/drivers/staging/vc04_services/bcm2835-audio/bcm2835-vchiq.c
@@ -337,7 +337,6 @@ static int vc_vchi_audio_deinit(struct b
 {
 	unsigned int i;
 
-
 	if (!instance) {
 		LOG_ERR("%s: invalid handle %p\n", __func__, instance);
 
@@ -369,7 +368,6 @@ static int vc_vchi_audio_deinit(struct b
 
 	kfree(instance);
 
-
 	return 0;
 }
 
@@ -382,7 +380,6 @@ static int bcm2835_audio_open_connection
 		(struct bcm2835_audio_instance *)alsa_stream->instance;
 	int ret;
 
-
 	LOG_INFO("%s: start\n", __func__);
 	BUG_ON(instance);
 	if (instance) {
@@ -438,7 +435,6 @@ int bcm2835_audio_open(struct bcm2835_al
 	int status;
 	int ret;
 
-
 	my_workqueue_init(alsa_stream);
 
 	ret = bcm2835_audio_open_connection(alsa_stream);
@@ -486,7 +482,6 @@ static int bcm2835_audio_set_ctls_chan(s
 	int status;
 	int ret;
 
-
 	LOG_INFO(" Setting ALSA dest(%d), volume(%d)\n",
 		 chip->dest, chip->volume);
 
@@ -570,7 +565,6 @@ int bcm2835_audio_set_params(struct bcm2
 	int status;
 	int ret;
 
-
 	LOG_INFO(" Setting ALSA channels(%d), samplerate(%d), bits-per-sample(%d)\n",
 		 channels, samplerate, bps);
 
@@ -631,7 +625,6 @@ unlock:
 int bcm2835_audio_setup(struct bcm2835_alsa_stream *alsa_stream)
 {
 
-
 	return 0;
 }
 
@@ -642,7 +635,6 @@ static int bcm2835_audio_start_worker(st
 	int status;
 	int ret;
 
-
 	if (mutex_lock_interruptible(&instance->vchi_mutex)) {
 		LOG_DBG("Interrupted whilst waiting for lock on (%d)\n",
 			instance->num_connections);
@@ -679,7 +671,6 @@ static int bcm2835_audio_stop_worker(str
 	int status;
 	int ret;
 
-
 	if (mutex_lock_interruptible(&instance->vchi_mutex)) {
 		LOG_DBG("Interrupted whilst waiting for lock on (%d)\n",
 			instance->num_connections);
@@ -717,7 +708,6 @@ int bcm2835_audio_close(struct bcm2835_a
 	int status;
 	int ret;
 
-
 	my_workqueue_quit(alsa_stream);
 
 	if (mutex_lock_interruptible(&instance->vchi_mutex)) {
@@ -775,7 +765,6 @@ static int bcm2835_audio_write_worker(st
 	int status;
 	int ret;
 
-
 	LOG_INFO(" Writing %d bytes from %p\n", count, src);
 
 	if (mutex_lock_interruptible(&instance->vchi_mutex)) {
--- a/drivers/staging/vc04_services/interface/vchi/connections/connection.h
+++ b/drivers/staging/vc04_services/interface/vchi/connections/connection.h
@@ -54,7 +54,6 @@ typedef struct opaque_vchi_connection_in
 
 typedef struct vchi_connection_t VCHI_CONNECTION_T;
 
-
 /******************************************************************************
  API
  *****************************************************************************/
@@ -212,7 +211,6 @@ typedef void * (*VCHI_BUFFER_ALLOCATE)(V
 // free memory allocated by buffer_allocate
 typedef void   (*VCHI_BUFFER_FREE)(VCHI_CONNECTION_SERVICE_HANDLE_T service_handle, void * address);
 
-
 /******************************************************************************
  System driver struct
  *****************************************************************************/
@@ -321,7 +319,6 @@ struct vchi_connection_t {
 #endif
 };
 
-
 #endif /* CONNECTION_H_ */
 
 /****************************** End of file **********************************/
--- a/drivers/staging/vc04_services/interface/vchi/message_drivers/message.h
+++ b/drivers/staging/vc04_services/interface/vchi/message_drivers/message.h
@@ -41,7 +41,6 @@
 #include "interface/vchi/vchi_cfg_internal.h"
 #include "interface/vchi/vchi_common.h"
 
-
 typedef enum message_event_type {
    MESSAGE_EVENT_NONE,
    MESSAGE_EVENT_NOP,
@@ -111,7 +110,6 @@ typedef struct rx_bulk_slotinfo_t {
    VCHI_FLAGS_T flags;
 } RX_BULK_SLOTINFO_T;
 
-
 /* ----------------------------------------------------------------------
  * each connection driver will have a pool of the following struct.
  *
@@ -155,7 +153,6 @@ typedef struct {
 
 } MESSAGE_EVENT_T;
 
-
 // callbacks
 typedef void VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T( void *state );
 
@@ -163,7 +160,6 @@ typedef struct {
    VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T *event_callback;
 } VCHI_MESSAGE_DRIVER_OPEN_T;
 
-
 // handle to this instance of message driver (as returned by ->open)
 typedef struct opaque_mhandle_t *VCHI_MDRIVER_HANDLE_T;
 
@@ -195,7 +191,6 @@ struct opaque_vchi_message_driver_t {
    void    (*debug)( VCHI_MDRIVER_HANDLE_T *handle );
 };
 
-
 #endif // _VCHI_MESSAGE_H_
 
 /****************************** End of file ***********************************/
--- a/drivers/staging/vc04_services/interface/vchi/vchi.h
+++ b/drivers/staging/vc04_services/interface/vchi/vchi.h
@@ -39,7 +39,6 @@
 #include "interface/vchi/connections/connection.h"
 #include "vchi_mh.h"
 
-
 /******************************************************************************
  Global defs
  *****************************************************************************/
@@ -92,7 +91,6 @@ typedef struct vchi_msg_vector_ex {
    } u;
 } VCHI_MSG_VECTOR_EX_T;
 
-
 // Construct an entry in a msg vector for a pointer (p) of length (l)
 #define VCHI_VEC_POINTER(p,l)  VCHI_VEC_POINTER, { { (VCHI_MEM_HANDLE_T)(p), (l) } }
 
@@ -103,7 +101,6 @@ typedef struct vchi_msg_vector_ex {
 #define MAKE_FOURCC(x) ((int32_t)( (x[0] << 24) | (x[1] << 16) | (x[2] << 8) | x[3] ))
 #define FOURCC_TO_CHAR(x) (x >> 24) & 0xFF,(x >> 16) & 0xFF,(x >> 8) & 0xFF, x & 0xFF
 
-
 // Opaque service information
 struct opaque_vchi_service_t;
 
@@ -114,8 +111,6 @@ typedef struct {
    void *message;
 } VCHI_HELD_MSG_T;
 
-
-
 // structure used to provide the information needed to open a server or a client
 typedef struct {
 	struct vchi_version version;
@@ -162,7 +157,6 @@ extern "C" {
 extern /*@observer@*/ VCHI_CONNECTION_T * vchi_create_connection( const VCHI_CONNECTION_API_T * function_table,
                                                    const VCHI_MESSAGE_DRIVER_T * low_level);
 
-
 // Routine used to initialise the vchi on both local + remote connections
 extern int32_t vchi_initialise( VCHI_INSTANCE_T *instance_handle );
 
@@ -185,7 +179,6 @@ extern void * vchi_allocate_buffer(VCHI_
 extern void vchi_free_buffer(VCHI_SERVICE_HANDLE_T handle, void *address);
 extern uint32_t vchi_current_time(VCHI_INSTANCE_T instance_handle);
 
-
 /******************************************************************************
  Global service API
  *****************************************************************************/
@@ -307,7 +300,6 @@ extern int32_t vchi_msg_iter_hold_next(
                                         uint32_t *msg_size, // }
                                         VCHI_HELD_MSG_T *message );
 
-
 /******************************************************************************
  Global bulk API
  *****************************************************************************/
@@ -319,7 +311,6 @@ extern int32_t vchi_bulk_queue_receive(
                                         VCHI_FLAGS_T flags,
                                         void *transfer_handle );
 
-
 // Prepare interface for a transfer from the other side into relocatable memory.
 int32_t vchi_bulk_queue_receive_reloc( const VCHI_SERVICE_HANDLE_T handle,
                                        VCHI_MEM_HANDLE_T h_dst,
@@ -335,7 +326,6 @@ extern int32_t vchi_bulk_queue_transmit(
                                          VCHI_FLAGS_T flags,
                                          void *transfer_handle );
 
-
 /******************************************************************************
  Configuration plumbing
  *****************************************************************************/
--- a/drivers/staging/vc04_services/interface/vchi/vchi_common.h
+++ b/drivers/staging/vc04_services/interface/vchi/vchi_common.h
@@ -34,7 +34,6 @@
 #ifndef VCHI_COMMON_H_
 #define VCHI_COMMON_H_
 
-
 //flags used when sending messages (must be bitmapped)
 typedef enum {
    VCHI_FLAGS_NONE                      = 0x0,
@@ -118,14 +117,11 @@ typedef enum {
    VCHI_SERVICE_OPTION_MAX
 } VCHI_SERVICE_OPTION_T;
 
-
 //Callback used by all services / bulk transfers
 typedef void (*VCHI_CALLBACK_T)(void *callback_param, //my service local param
 				 VCHI_CALLBACK_REASON_T reason,
 				 void *handle); //for transmitting msg's only
 
-
-
 /*
  * Define vector struct for scatter-gather (vector) operations
  * Vectors can be nested - if a vector element has negative length, then
@@ -154,7 +150,6 @@ typedef struct opaque_vchi_connection_ap
 // Opaque type for a message driver
 typedef struct opaque_vchi_message_driver_t VCHI_MESSAGE_DRIVER_T;
 
-
 // Iterator structure for reading ahead through received message queue. Allocated by client,
 // initialised by vchi_msg_look_ahead. Fields are for internal VCHI use only.
 // Iterates over messages in queue at the instant of the call to vchi_msg_lookahead -
@@ -168,5 +163,4 @@ typedef struct {
    void *remove;
 } VCHI_MSG_ITER_T;
 
-
 #endif // VCHI_COMMON_H_
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.c
@@ -109,10 +109,8 @@ static const char *const resume_state_na
  * requested */
 #define FORCE_SUSPEND_TIMEOUT_MS 200
 
-
 static void suspend_timer_callback(unsigned long context);
 
-
 typedef struct user_service_struct {
 	VCHIQ_SERVICE_T *service;
 	void *userdata;
@@ -2307,8 +2305,6 @@ exit:
 	return 0;
 }
 
-
-
 VCHIQ_STATUS_T
 vchiq_arm_init_state(VCHIQ_STATE_T *state, VCHIQ_ARM_STATE_T *arm_state)
 {
@@ -2469,7 +2465,6 @@ set_resume_state(VCHIQ_ARM_STATE_T *arm_
 	}
 }
 
-
 /* should be called with the write lock held */
 inline void
 start_suspend_timer(VCHIQ_ARM_STATE_T *arm_state)
@@ -2589,7 +2584,6 @@ vchiq_arm_vcsuspend(VCHIQ_STATE_T *state
 	vchiq_log_trace(vchiq_susp_log_level, "%s", __func__);
 	status = VCHIQ_SUCCESS;
 
-
 	switch (arm_state->vc_suspend_state) {
 	case VC_SUSPEND_REQUESTED:
 		vchiq_log_info(vchiq_susp_log_level, "%s: suspend already "
@@ -2654,7 +2648,6 @@ out:
 	return;
 }
 
-
 static void
 output_timeout_error(VCHIQ_STATE_T *state)
 {
@@ -2834,7 +2827,6 @@ out:
 	return;
 }
 
-
 int
 vchiq_arm_allow_resume(VCHIQ_STATE_T *state)
 {
@@ -2996,7 +2988,6 @@ vchiq_use_internal(VCHIQ_STATE_T *state,
 			"%s %s count %d, state count %d",
 			__func__, entity, *entity_uc, local_uc);
 
-
 	write_unlock_bh(&arm_state->susp_res_lock);
 
 	/* Completion is in a done state when we're not suspended, so this won't
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_arm.h
@@ -42,7 +42,6 @@
 #include "vchiq_core.h"
 #include "vchiq_debugfs.h"
 
-
 enum vc_suspend_status {
 	VC_SUSPEND_FORCE_CANCELED = -3, /* Force suspend canceled, too busy */
 	VC_SUSPEND_REJECTED = -2,  /* Videocore rejected suspend request */
@@ -61,15 +60,12 @@ enum vc_resume_status {
 	VC_RESUME_RESUMED      /* Videocore resumed successfully (active) */
 };
 
-
 enum USE_TYPE_E {
 	USE_TYPE_SERVICE,
 	USE_TYPE_SERVICE_NO_RESUME,
 	USE_TYPE_VCHIQ
 };
 
-
-
 typedef struct vchiq_arm_state_struct {
 	/* Keepalive-related data */
 	struct task_struct *ka_thread;
@@ -216,5 +212,4 @@ set_resume_state(VCHIQ_ARM_STATE_T *arm_
 extern void
 start_suspend_timer(VCHIQ_ARM_STATE_T *arm_state);
 
-
 #endif /* VCHIQ_ARM_H */
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.c
@@ -130,7 +130,6 @@ static const char *const conn_state_name
 	"RESUME_TIMEOUT"
 };
 
-
 static void
 release_message_sync(VCHIQ_STATE_T *state, VCHIQ_HEADER_T *header);
 
@@ -2151,7 +2150,6 @@ slot_handler_func(void *v)
 				break;
 			}
 
-
 		}
 
 		DEBUG_TRACE(SLOT_HANDLER_LINE);
@@ -2160,7 +2158,6 @@ slot_handler_func(void *v)
 	return 0;
 }
 
-
 /* Called by the recycle thread */
 static int
 recycle_func(void *v)
@@ -2176,7 +2173,6 @@ recycle_func(void *v)
 	return 0;
 }
 
-
 /* Called by the sync thread */
 static int
 sync_func(void *v)
@@ -2284,7 +2280,6 @@ sync_func(void *v)
 	return 0;
 }
 
-
 static void
 init_bulk_queue(VCHIQ_BULK_QUEUE_T *queue)
 {
@@ -2295,14 +2290,12 @@ init_bulk_queue(VCHIQ_BULK_QUEUE_T *queu
 	queue->remove = 0;
 }
 
-
 inline const char *
 get_conn_state_name(VCHIQ_CONNSTATE_T conn_state)
 {
 	return conn_state_names[conn_state];
 }
 
-
 VCHIQ_SLOT_ZERO_T *
 vchiq_init_slots(void *mem_base, int mem_size)
 {
@@ -3277,7 +3270,6 @@ vchiq_remove_service(VCHIQ_SERVICE_HANDL
 	return status;
 }
 
-
 /* This function may be called by kernel threads or user threads.
  * User threads may receive VCHIQ_RETRY to indicate that a signal has been
  * received and the call should be retried after being returned to user
@@ -3857,7 +3849,6 @@ vchiq_dump_service_state(void *dump_cont
 		vchiq_dump_platform_service_state(dump_context, service);
 }
 
-
 void
 vchiq_loud_error_header(void)
 {
@@ -3882,7 +3873,6 @@ vchiq_loud_error_footer(void)
 		"================");
 }
 
-
 VCHIQ_STATUS_T vchiq_send_remote_use(VCHIQ_STATE_T *state)
 {
 	VCHIQ_STATUS_T status = VCHIQ_RETRY;
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_core.h
@@ -702,7 +702,6 @@ vchiq_platform_handle_timeout(VCHIQ_STAT
 extern void
 vchiq_set_conn_state(VCHIQ_STATE_T *state, VCHIQ_CONNSTATE_T newstate);
 
-
 extern void
 vchiq_log_dump_mem(const char *label, uint32_t addr, const void *voidMem,
 	size_t numBytes);
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_debugfs.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_debugfs.c
@@ -32,7 +32,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 #include <linux/debugfs.h>
 #include "vchiq_core.h"
 #include "vchiq_arm.h"
@@ -52,7 +51,6 @@
 #define VCHIQ_LOG_INFO_STR    "info"
 #define VCHIQ_LOG_TRACE_STR   "trace"
 
-
 /* Top-level debug info */
 struct vchiq_debugfs_info {
 	/* Global 'vchiq' debugfs entry used by all instances */
@@ -316,7 +314,6 @@ void vchiq_debugfs_remove_instance(VCHIQ
 	debugfs_remove_recursive(node->dentry);
 }
 
-
 int vchiq_debugfs_init(void)
 {
 	BUG_ON(debugfs_info.vchiq_cfg_dir != NULL);
--- a/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_shim.c
+++ b/drivers/staging/vc04_services/interface/vchiq_arm/vchiq_shim.c
@@ -84,7 +84,6 @@ VCHI_CONNECTION_T *vchi_create_connectio
  *             void **data,
  *             uint32_t *msg_size,
 
-
  *             VCHI_FLAGS_T flags
  *
  * Description: Routine to return a pointer to the current message (to allow in
@@ -541,7 +540,6 @@ int32_t vchi_connect(VCHI_CONNECTION_T *
 }
 EXPORT_SYMBOL(vchi_connect);
 
-
 /***********************************************************
  * Name: vchi_disconnect
  *
@@ -561,7 +559,6 @@ int32_t vchi_disconnect(VCHI_INSTANCE_T
 }
 EXPORT_SYMBOL(vchi_disconnect);
 
-
 /***********************************************************
  * Name: vchi_service_open
  * Name: vchi_service_create
