From 6cf27e5a30e55211d004f00a9c3a6374708f2ef7 Mon Sep 17 00:00:00 2001
From: Tadeusz Struk <tadeusz.struk@intel.com>
Date: Tue, 22 May 2018 14:37:18 -0700
Subject: [PATCH] tpm: fix race condition in tpm_common_write()

References: bsc#1050381
Patch-mainline: v4.18-rc1
Git-commit: 3ab2011ea368ec3433ad49e1b9e1c7b70d2e65df

There is a race condition in tpm_common_write function allowing
two threads on the same /dev/tpm<N>, or two different applications
on the same /dev/tpmrm<N> to overwrite each other commands/responses.
Fixed this by taking the priv->buffer_mutex early in the function.

Also converted the priv->data_pending from atomic to a regular size_t
type. There is no need for it to be atomic since it is only touched
under the protection of the priv->buffer_mutex.

[KABI: do not change the type of data_pending]

Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
Cc: stable@vger.kernel.org
Signed-off-by: Tadeusz Struk <tadeusz.struk@intel.com>
Reviewed-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Signed-off-by: Jarkko Sakkinen <jarkko.sakkinen@linux.intel.com>
Acked-by: Michal Suchanek <msuchanek@suse.de>
---
 drivers/char/tpm/tpm.c | 42 +++++++++++++++++++-----------------------
 1 file changed, 19 insertions(+), 23 deletions(-)

diff --git a/drivers/char/tpm/tpm.c b/drivers/char/tpm/tpm.c
index 1a6ba190f6d2..02dbfe062ca5 100644
--- a/drivers/char/tpm/tpm.c
+++ b/drivers/char/tpm/tpm.c
@@ -342,7 +342,7 @@ static void timeout_work(struct work_struct *work)
 	struct tpm_chip *chip = container_of(work, struct tpm_chip, work);
 
 	mutex_lock(&chip->buffer_mutex);
-	atomic_set(&chip->data_pending, 0);
+	chip->data_pending.counter = 0;
 	memset(chip->data_buffer, 0, TPM_BUFSIZE);
 	mutex_unlock(&chip->buffer_mutex);
 }
@@ -991,8 +991,6 @@ int tpm_open(struct inode *inode, struct file *file)
 		return -ENOMEM;
 	}
 
-	atomic_set(&chip->data_pending, 0);
-
 	file->private_data = chip;
 	return 0;
 }
@@ -1008,7 +1006,7 @@ int tpm_release(struct inode *inode, struct file *file)
 	del_singleshot_timer_sync(&chip->user_read_timer);
 	flush_work_sync(&chip->work);
 	file->private_data = NULL;
-	atomic_set(&chip->data_pending, 0);
+	chip->data_pending.counter = 0;
 	kfree(chip->data_buffer);
 	clear_bit(0, &chip->is_open);
 	put_device(chip->dev);
@@ -1023,17 +1021,19 @@ ssize_t tpm_write(struct file *file, const char __user *buf,
 	size_t in_size = size;
 	ssize_t out_size;
 
+	if (in_size > TPM_BUFSIZE)
+		return -E2BIG;
+
+	mutex_lock(&chip->buffer_mutex);
+
 	/* cannot perform a write until the read has cleared
 	   either via tpm_read or a user_read_timer timeout.
 	   This also prevents splitted buffered writes from blocking here.
 	*/
-	if (atomic_read(&chip->data_pending) != 0)
+	if (chip->data_pending.counter != 0) {
+		mutex_unlock(&chip->buffer_mutex);
 		return -EBUSY;
-
-	if (in_size > TPM_BUFSIZE)
-		return -E2BIG;
-
-	mutex_lock(&chip->buffer_mutex);
+	}
 
 	if (copy_from_user
 	    (chip->data_buffer, (void __user *) buf, in_size)) {
@@ -1048,7 +1048,7 @@ ssize_t tpm_write(struct file *file, const char __user *buf,
 		return out_size;
 	}
 
-	atomic_set(&chip->data_pending, out_size);
+	chip->data_pending.counter = out_size;
 	mutex_unlock(&chip->buffer_mutex);
 
 	/* Set a timeout by which the reader must come claim the result */
@@ -1062,28 +1062,24 @@ ssize_t tpm_read(struct file *file, char __user *buf,
 		 size_t size, loff_t *off)
 {
 	struct tpm_chip *chip = file->private_data;
-	ssize_t ret_size;
-	ssize_t orig_ret_size;
+	ssize_t ret_size = 0;
 	int rc;
 
 	del_singleshot_timer_sync(&chip->user_read_timer);
 	flush_work_sync(&chip->work);
-	ret_size = atomic_read(&chip->data_pending);
-	atomic_set(&chip->data_pending, 0);
-	if (ret_size > 0) {	/* relay data */
-		orig_ret_size = ret_size;
-		if (size < ret_size)
-			ret_size = size;
-
-		mutex_lock(&chip->buffer_mutex);
+	mutex_lock(&chip->buffer_mutex);
+
+	if (chip->data_pending.counter) {
+		ret_size = min_t(ssize_t, size, chip->data_pending.counter);
 		rc = copy_to_user(buf, chip->data_buffer, ret_size);
-		memset(chip->data_buffer, 0, orig_ret_size);
+		memset(chip->data_buffer, 0, chip->data_pending.counter);
 		if (rc)
 			ret_size = -EFAULT;
 
-		mutex_unlock(&chip->buffer_mutex);
+		chip->data_pending.counter = 0;
 	}
 
+	mutex_unlock(&chip->buffer_mutex);
 	return ret_size;
 }
 EXPORT_SYMBOL_GPL(tpm_read);
-- 
2.13.7

